kernel/fork.c:				atomic_dec(&inode->i_writecount);
kernel/trace/trace_stat.c:	struct stat_session *session = inode->i_private;
kernel/trace/trace_events.c:	struct ftrace_event_call *call = inode->i_private;
kernel/trace/trace_events.c:	if (!inode->i_private)
kernel/trace/trace_events.c:		if (system == inode->i_private) {
kernel/trace/trace_events.c:	if (system != inode->i_private)
kernel/trace/trace_events.c:	struct event_subsystem *system = inode->i_private;
kernel/trace/trace.c:	long cpu_file = (long) inode->i_private;
kernel/trace/trace.c:	filp->private_data = inode->i_private;
kernel/trace/trace.c:		long cpu = (long) inode->i_private;
kernel/trace/trace.c:	long cpu_file = (long) inode->i_private;
kernel/trace/trace.c:	info->cpu = (unsigned long)inode->i_private;
kernel/trace/trace.c:	int cpu = (int)(long)inode->i_private;
kernel/cgroup.c:		inode->i_ino = get_next_ino();
kernel/cgroup.c:		inode->i_mode = mode;
kernel/cgroup.c:		inode->i_uid = current_fsuid();
kernel/cgroup.c:		inode->i_gid = current_fsgid();
kernel/cgroup.c:		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
kernel/cgroup.c:		inode->i_mapping->backing_dev_info = &cgroup_backing_dev_info;
kernel/cgroup.c:	if (S_ISDIR(inode->i_mode)) {
kernel/cgroup.c:	lockdep_assert_held(&cgrp->dentry->d_inode->i_mutex);
kernel/cgroup.c:	mutex_lock(&cgrp->dentry->d_inode->i_mutex);
kernel/cgroup.c:	mutex_unlock(&cgrp->dentry->d_inode->i_mutex);
kernel/cgroup.c:	inode->i_fop = &simple_dir_operations;
kernel/cgroup.c:	inode->i_op = &cgroup_dir_inode_operations;
kernel/cgroup.c:		mutex_lock(&inode->i_mutex);
kernel/cgroup.c:		mutex_unlock(&inode->i_mutex);
kernel/cgroup.c:	mutex_unlock(&inode->i_mutex);
kernel/cgroup.c:	if (!S_ISDIR(old_dentry->d_inode->i_mode))
kernel/cgroup.c:	if (S_ISDIR(dentry->d_inode->i_mode))
kernel/cgroup.c:	if (file->f_dentry->d_inode->i_fop != &cgroup_file_operations)
kernel/cgroup.c:		inode->i_op = &cgroup_dir_inode_operations;
kernel/cgroup.c:		inode->i_fop = &simple_dir_operations;
kernel/cgroup.c:		 * @inode->i_mutex should nest outside cgroup_mutex but we
kernel/cgroup.c:		WARN_ON_ONCE(!mutex_trylock(&inode->i_mutex));
kernel/cgroup.c:		inode->i_size = 0;
kernel/cgroup.c:		inode->i_fop = &cgroup_file_operations;
kernel/cgroup.c:		inode->i_op = &cgroup_file_inode_operations;
kernel/cgroup.c:	BUG_ON(!mutex_is_locked(&dir->d_inode->i_mutex));
kernel/cgroup.c:		mutex_lock(&inode->i_mutex);
kernel/cgroup.c:		mutex_unlock(&inode->i_mutex);
kernel/cgroup.c:	    !S_ISDIR(dentry->d_inode->i_mode))
kernel/cgroup.c:	lockdep_assert_held(&dentry->d_inode->i_mutex);
kernel/cgroup.c:	mutex_unlock(&cgrp->dentry->d_inode->i_mutex);
kernel/cgroup.c:	mutex_unlock(&dentry->d_inode->i_mutex);
kernel/cgroup.c:	/* the vfs holds inode->i_mutex already */
kernel/cgroup.c:	lockdep_assert_held(&d->d_inode->i_mutex);
kernel/cgroup.c:	if (inode->i_op != &cgroup_dir_inode_operations)
kernel/relay.c:	buf->dentry->d_inode->i_size = buf->early_bytes;
kernel/relay.c:			buf->dentry->d_inode->i_size +=
kernel/relay.c:	struct rchan_buf *buf = inode->i_private;
kernel/relay.c:	mutex_lock(&filp->f_path.dentry->d_inode->i_mutex);
kernel/relay.c:	mutex_unlock(&filp->f_path.dentry->d_inode->i_mutex);
kernel/cred.c:	new->fsuid = inode->i_uid;
kernel/cred.c:	new->fsgid = inode->i_gid;
kernel/sysctl.c:		.procname	= "inode-nr",
kernel/sysctl.c:		.procname	= "inode-state",
kernel/sys.c:	if (!S_ISREG(dentry->d_inode->i_mode)	||
kernel/futex.c:		key->both.offset |= FUT_OFF_INODE; /* inode-based key */
kernel/gcov/fs.c:	struct gcov_node *node = inode->i_private;
kernel/audit.c:/* Hash for inode-based rules */
kernel/audit.c:	audit_log_untrustedstring(ab, link->dentry->d_inode->i_sb->s_id);
kernel/audit.c:	audit_log_format(ab, " ino=%lu", link->dentry->d_inode->i_ino);
kernel/sysctl_binary.c:	{ CTL_INT,	FS_NRINODE,		"inode-nr" },
kernel/sysctl_binary.c:	{ CTL_INT,	FS_STATINODE,		"inode-state" },
kernel/irq/irqdomain.c:	return single_open(file, virq_debug_show, inode->i_private);
kernel/rcutree_trace.c:		m->private = inode->i_private;
kernel/rcutree_trace.c:	return single_open(file, show_rcubarrier, inode->i_private);
kernel/rcutree_trace.c:	return single_open(file, show_rcuexp, inode->i_private);
kernel/rcutree_trace.c:	return single_open(file, show_rcuhier, inode->i_private);
kernel/rcutree_trace.c:	return single_open(file, show_rcugp, inode->i_private);
kernel/auditsc.c:	if (likely(hlist_empty(&inode->i_fsnotify_marks)))
kernel/auditsc.c:		if (inode && unlikely(!hlist_empty(&inode->i_fsnotify_marks))) {
kernel/auditsc.c:	name->ino   = inode->i_ino;
kernel/auditsc.c:	name->dev   = inode->i_sb->s_dev;
kernel/auditsc.c:	name->mode  = inode->i_mode;
kernel/auditsc.c:	name->uid   = inode->i_uid;
kernel/auditsc.c:	name->gid   = inode->i_gid;
kernel/auditsc.c:	name->rdev  = inode->i_rdev;
kernel/acct.c:	if (!S_ISREG(file->f_path.dentry->d_inode->i_mode)) {
kernel/time/posix-clock.c:		container_of(inode->i_cdev, struct posix_clock, cdev);
kernel/audit_watch.c:		/* If the update involves invalidating rules, do the inode-based
kernel/audit_watch.c:	mutex_unlock(&parent->dentry->d_inode->i_mutex);
kernel/audit_watch.c:		watch->dev = d->d_inode->i_sb->s_dev;
kernel/audit_watch.c:		watch->ino = d->d_inode->i_ino;
kernel/audit_watch.c:		audit_update_watch(parent, dname, inode->i_sb->s_dev, inode->i_ino, 0);
kernel/capability.c:	return ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);
kernel/events/uprobes.c:	mapping = uprobe->inode->i_mapping;
kernel/events/uprobes.c:	if (uprobe->offset + MAX_UINSN_BYTES > uprobe->inode->i_size)
kernel/events/uprobes.c:		bytes = uprobe->inode->i_size - uprobe->offset;
kernel/events/uprobes.c:	info = build_map_info(uprobe->inode->i_mapping,
kernel/events/core.c:	mutex_lock(&inode->i_mutex);
kernel/events/core.c:	mutex_unlock(&inode->i_mutex);
net/socket.c:				dentry->d_inode->i_ino);
net/socket.c:	inode->i_ino = get_next_ino();
net/socket.c:	inode->i_mode = S_IFSOCK | S_IRWXUGO;
net/socket.c:	inode->i_uid = current_fsuid();
net/socket.c:	inode->i_gid = current_fsgid();
net/socket.c:	inode->i_op = &sockfs_inode_ops;
net/ipv4/fib_trie.c:		    inode->pos == oldtnode->pos + oldtnode->bits &&
net/ipv4/fib_trie.c:		    inode->bits > 1) {
net/ipv4/fib_trie.c:			t_key m = ~0U << (KEYLENGTH - 1) >> inode->pos;
net/ipv4/fib_trie.c:			left = tnode_new(inode->key&(~m), inode->pos + 1,
net/ipv4/fib_trie.c:					 inode->bits - 1);
net/ipv4/fib_trie.c:			right = tnode_new(inode->key|m, inode->pos + 1,
net/ipv4/fib_trie.c:					  inode->bits - 1);
net/ipv4/fib_trie.c:		if (inode->bits == 1) {
net/ipv4/fib_trie.c:			put_child(tn, 2*i, rtnl_dereference(inode->child[0]));
net/ipv4/fib_trie.c:			put_child(tn, 2*i+1, rtnl_dereference(inode->child[1]));
net/ipv4/fib_trie.c:		 * (inode->pos) - is the one that will differ between
net/ipv4/fib_trie.c:		 * the position (inode->pos)
net/ipv4/fib_trie.c:			put_child(left, j, rtnl_dereference(inode->child[j]));
net/ipv4/fib_trie.c:			put_child(right, j, rtnl_dereference(inode->child[j + size]));
net/bluetooth/hci_sysfs.c:	return single_open(file, inquiry_cache_show, inode->i_private);
net/bluetooth/hci_sysfs.c:	return single_open(file, blacklist_show, inode->i_private);
net/bluetooth/hci_sysfs.c:	return single_open(file, uuids_show, inode->i_private);
net/bluetooth/l2cap_core.c:	return single_open(file, l2cap_debugfs_show, inode->i_private);
net/bluetooth/rfcomm/sock.c:	return single_open(file, rfcomm_sock_debugfs_show, inode->i_private);
net/bluetooth/rfcomm/core.c:	return single_open(file, rfcomm_dlc_debugfs_show, inode->i_private);
net/bluetooth/sco.c:	return single_open(file, sco_debugfs_show, inode->i_private);
net/mac80211/rc80211_minstrel_debugfs.c:	struct minstrel_sta_info *mi = inode->i_private;
net/mac80211/rc80211_minstrel_ht_debugfs.c:	struct minstrel_ht_sta_priv *msp = inode->i_private;
net/mac80211/rc80211_minstrel_ht_debugfs.c:		inode->i_private = &msp->legacy;
net/mac80211/rc80211_minstrel_ht_debugfs.c:		inode->i_private = msp;
net/mac80211/rc80211_pid_debugfs.c:	struct rc_pid_sta_info *sinfo = inode->i_private;
net/unix/diag.c:			.udiag_vfs_ino = dentry->d_inode->i_ino,
net/unix/af_unix.c:		if (!S_ISSOCK(inode->i_mode))
net/unix/af_unix.c:		hash = path.dentry->d_inode->i_ino & (UNIX_HASH_SIZE-1);
net/unix/garbage.c:	if (S_ISSOCK(inode->i_mode) && !(filp->f_mode & FMODE_PATH)) {
net/sunrpc/rpc_pipe.c:	mutex_lock(&inode->i_mutex);
net/sunrpc/rpc_pipe.c:	mutex_unlock(&inode->i_mutex);
net/sunrpc/rpc_pipe.c:	call_rcu(&inode->i_rcu, rpc_i_callback);
net/sunrpc/rpc_pipe.c:	mutex_lock(&inode->i_mutex);
net/sunrpc/rpc_pipe.c:	mutex_unlock(&inode->i_mutex);
net/sunrpc/rpc_pipe.c:	mutex_lock(&inode->i_mutex);
net/sunrpc/rpc_pipe.c:	mutex_unlock(&inode->i_mutex);
net/sunrpc/rpc_pipe.c:	mutex_lock(&inode->i_mutex);
net/sunrpc/rpc_pipe.c:	mutex_unlock(&inode->i_mutex);
net/sunrpc/rpc_pipe.c:	mutex_lock(&inode->i_mutex);
net/sunrpc/rpc_pipe.c:	mutex_unlock(&inode->i_mutex);
net/sunrpc/rpc_pipe.c:	mutex_lock(&inode->i_mutex);
net/sunrpc/rpc_pipe.c:	mutex_unlock(&inode->i_mutex);
net/sunrpc/rpc_pipe.c:		mutex_lock(&inode->i_mutex);
net/sunrpc/rpc_pipe.c:			mutex_unlock(&inode->i_mutex);
net/sunrpc/rpc_pipe.c:		mutex_unlock(&inode->i_mutex);
net/sunrpc/rpc_pipe.c:	inode->i_ino = get_next_ino();
net/sunrpc/rpc_pipe.c:	inode->i_mode = mode;
net/sunrpc/rpc_pipe.c:	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
net/sunrpc/rpc_pipe.c:		inode->i_fop = &simple_dir_operations;
net/sunrpc/rpc_pipe.c:		inode->i_op = &simple_dir_inode_operations;
net/sunrpc/rpc_pipe.c:	inode->i_ino = iunique(dir->i_sb, 100);
net/sunrpc/rpc_pipe.c:		inode->i_fop = i_fop;
net/sunrpc/rpc_pipe.c:		switch (dentry->d_inode->i_mode & S_IFMT) {
net/sunrpc/cache.c:	mutex_lock(&inode->i_mutex); /* protect against multiple concurrent
net/sunrpc/cache.c:		mutex_unlock(&inode->i_mutex);
net/sunrpc/cache.c:	mutex_unlock(&inode->i_mutex);
net/sunrpc/cache.c:	mutex_lock(&inode->i_mutex);
net/sunrpc/cache.c:	mutex_unlock(&inode->i_mutex);
net/batman-adv/debugfs.c:	file->private_data = inode->i_private;
net/batman-adv/debugfs.c:	struct net_device *net_dev = (struct net_device *)inode->i_private;
net/batman-adv/debugfs.c:	struct net_device *net_dev = (struct net_device *)inode->i_private;
net/batman-adv/debugfs.c:	struct net_device *net_dev = (struct net_device *)inode->i_private;
net/batman-adv/debugfs.c:	struct net_device *net_dev = (struct net_device *)inode->i_private;
net/batman-adv/debugfs.c:	struct net_device *net_dev = (struct net_device *)inode->i_private;
net/batman-adv/debugfs.c:	struct net_device *net_dev = (struct net_device *)inode->i_private;
net/batman-adv/debugfs.c:	struct net_device *net_dev = (struct net_device *)inode->i_private;
net/batman-adv/debugfs.c:	struct net_device *net_dev = (struct net_device *)inode->i_private;
net/batman-adv/icmp_socket.c:	socket_client->bat_priv = inode->i_private;
net/netlink/af_netlink.c:	if (!S_ISSOCK(inode->i_mode))
block/partition-generic.c:	struct address_space *mapping = bdev->bd_inode->i_mapping;
block/compat_ioctl.c:	struct block_device *bdev = inode->i_bdev;
block/partitions/efi.c:	return div_u64(bdev->bd_inode->i_size,
block/partitions/atari.c:	hd_size = state->bdev->bd_inode->i_size >> 9;
block/partitions/ldm.c:	num_sects = state->bdev->bd_inode->i_size >> 9;
block/partitions/acorn.c:	nr_sects = (state->bdev->bd_inode->i_size >> 9) - start_sect;
block/bsg.c:		format_dev_t(buf, inode->i_rdev), bd->max_queue);
samples/tracepoints/tracepoint-probe-sample2.c:		inode->i_ino);
Binary file .git/index matches
mm/mmap.c: * Requires inode->i_mapping->i_mmap_mutex
mm/mmap.c:		atomic_inc(&file->f_path.dentry->d_inode->i_writecount);
mm/mmap.c:			atomic_dec(&file->f_path.dentry->d_inode->i_writecount);
mm/mmap.c:		atomic_inc(&inode->i_writecount);
mm/mmap.c:		atomic_inc(&inode->i_writecount);
mm/filemap.c: *    ->inode->i_lock		(page_remove_rmap->set_page_dirty)
mm/filemap.c: *    ->inode->i_lock		(zap_pte_range->set_page_dirty)
mm/filemap.c:			if (inode->i_blkbits == PAGE_CACHE_SHIFT ||
mm/filemap.c:	sb_start_pagefault(inode->i_sb);
mm/filemap.c:	if (page->mapping != inode->i_mapping) {
mm/filemap.c:	sb_end_pagefault(inode->i_sb);
mm/filemap.c:		if (unlikely(*pos >= inode->i_sb->s_maxbytes)) {
mm/filemap.c:			if (*count || *pos > inode->i_sb->s_maxbytes) {
mm/filemap.c:		if (unlikely(*pos + *count > inode->i_sb->s_maxbytes))
mm/filemap.c:			*count = inode->i_sb->s_maxbytes - *pos;
mm/filemap.c:		if (pos > i_size_read(inode) && !S_ISBLK(inode->i_mode)) {
mm/filemap.c:	err = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));
mm/filemap.c:	sb_start_write(inode->i_sb);
mm/filemap.c:	mutex_lock(&inode->i_mutex);
mm/filemap.c:	mutex_unlock(&inode->i_mutex);
mm/filemap.c:	sb_end_write(inode->i_sb);
mm/memory-failure.c:	ino = css->cgroup->dentry->d_inode->i_ino;
mm/truncate.c: * Called under (and serialised by) inode->i_mutex.
mm/truncate.c:	struct address_space *mapping = inode->i_mapping;
mm/truncate.c:	oldsize = inode->i_size;
mm/truncate.c:	struct address_space *mapping = inode->i_mapping;
mm/memblock.c:	return single_open(file, memblock_debug_show, inode->i_private);
mm/swapfile.c:	if (S_ISBLK(inode->i_mode)) {
mm/swapfile.c:	if (S_ISBLK(inode->i_mode)) {
mm/swapfile.c:		mutex_lock(&inode->i_mutex);
mm/swapfile.c:		inode->i_flags &= ~S_SWAPFILE;
mm/swapfile.c:		mutex_unlock(&inode->i_mutex);
mm/swapfile.c:			S_ISBLK(file->f_path.dentry->d_inode->i_mode) ?
mm/swapfile.c:	if (S_ISBLK(inode->i_mode)) {
mm/swapfile.c:	} else if (S_ISREG(inode->i_mode)) {
mm/swapfile.c:		p->bdev = inode->i_sb->s_bdev;
mm/swapfile.c:		mutex_lock(&inode->i_mutex);
mm/swapfile.c:	if (swap_header->info.nr_badpages && S_ISREG(inode->i_mode))
mm/swapfile.c:	/* If S_ISREG(inode->i_mode) will do mutex_lock(&inode->i_mutex); */
mm/swapfile.c:	if (S_ISREG(inode->i_mode))
mm/swapfile.c:		inode->i_flags |= S_SWAPFILE;
mm/swapfile.c:	if (inode && S_ISBLK(inode->i_mode) && p->bdev) {
mm/swapfile.c:		if (inode && S_ISREG(inode->i_mode)) {
mm/swapfile.c:			mutex_unlock(&inode->i_mutex);
mm/swapfile.c:	if (inode && S_ISREG(inode->i_mode))
mm/swapfile.c:		mutex_unlock(&inode->i_mutex);
mm/fadvise.c:	if (S_ISFIFO(f.file->f_path.dentry->d_inode->i_mode)) {
mm/backing-dev.c:	return single_open(file, bdi_debug_stats_show, inode->i_private);
mm/nommu.c:			mapping = file->f_path.dentry->d_inode->i_mapping;
mm/nommu.c:			switch (file->f_path.dentry->d_inode->i_mode & S_IFMT) {
mm/nommu.c:	mutex_lock(&inode->i_mapping->i_mmap_mutex);
mm/nommu.c:	vma_interval_tree_foreach(vma, &inode->i_mapping->i_mmap, low, high) {
mm/nommu.c:			mutex_unlock(&inode->i_mapping->i_mmap_mutex);
mm/nommu.c:	vma_interval_tree_foreach(vma, &inode->i_mapping->i_mmap,
mm/nommu.c:	mutex_unlock(&inode->i_mapping->i_mmap_mutex);
mm/shmem.c: * shmem_fallocate and shmem_writepage communicate via inode->i_private
mm/shmem.c:			mapping_gfp_mask(inode->i_mapping), fault_type);
mm/shmem.c: * But normally   info->alloced == inode->i_mapping->nrpages + info->swapped
mm/shmem.c: * So mm freed is info->alloced - (inode->i_mapping->nrpages + info->swapped)
mm/shmem.c:	freed = info->alloced - info->swapped - inode->i_mapping->nrpages;
mm/shmem.c:		struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
mm/shmem.c:		inode->i_blocks -= freed * BLOCKS_PER_PAGE;
mm/shmem.c:	struct address_space *mapping = inode->i_mapping;
mm/shmem.c:	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
mm/shmem.c:	if (S_ISREG(inode->i_mode) && (attr->ia_valid & ATTR_SIZE)) {
mm/shmem.c:		loff_t oldsize = inode->i_size;
mm/shmem.c:			inode->i_ctime = inode->i_mtime = CURRENT_TIME;
mm/shmem.c:			unmap_mapping_range(inode->i_mapping, holebegin, 0, 1);
mm/shmem.c:			unmap_mapping_range(inode->i_mapping, holebegin, 0, 1);
mm/shmem.c:	if (inode->i_mapping->a_ops == &shmem_aops) {
mm/shmem.c:		shmem_unacct_size(info->flags, inode->i_size);
mm/shmem.c:		inode->i_size = 0;
mm/shmem.c:	WARN_ON(inode->i_blocks);
mm/shmem.c:	shmem_free_inode(inode->i_sb);
mm/shmem.c:		if (inode->i_private) {
mm/shmem.c:			spin_lock(&inode->i_lock);
mm/shmem.c:			shmem_falloc = inode->i_private;
mm/shmem.c:			spin_unlock(&inode->i_lock);
mm/shmem.c:	struct address_space *mapping = inode->i_mapping;
mm/shmem.c:	sbinfo = SHMEM_SB(inode->i_sb);
mm/shmem.c:		inode->i_blocks += BLOCKS_PER_PAGE;
mm/shmem.c:	inode->i_blocks -= BLOCKS_PER_PAGE;
mm/shmem.c:	sbinfo = SHMEM_SB(inode->i_sb);
mm/shmem.c:		if (!user_shm_lock(inode->i_size, user))
mm/shmem.c:		user_shm_unlock(inode->i_size, user);
mm/shmem.c:		inode->i_ino = get_next_ino();
mm/shmem.c:		inode->i_blocks = 0;
mm/shmem.c:		inode->i_mapping->backing_dev_info = &shmem_backing_dev_info;
mm/shmem.c:		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
mm/shmem.c:		inode->i_generation = get_seconds();
mm/shmem.c:			inode->i_op = &shmem_special_inode_operations;
mm/shmem.c:			inode->i_mapping->a_ops = &shmem_aops;
mm/shmem.c:			inode->i_op = &shmem_inode_operations;
mm/shmem.c:			inode->i_fop = &shmem_file_operations;
mm/shmem.c:			inode->i_size = 2 * BOGO_DIRENT_SIZE;
mm/shmem.c:			inode->i_op = &shmem_dir_inode_operations;
mm/shmem.c:			inode->i_fop = &simple_dir_operations;
mm/shmem.c:	if (pos + copied > inode->i_size)
mm/shmem.c:	struct address_space *mapping = inode->i_mapping;
mm/shmem.c:	mutex_lock(&inode->i_mutex);
mm/shmem.c:	else if (offset >= inode->i_size)
mm/shmem.c:		end = (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
mm/shmem.c:			if (new_offset < inode->i_size)
mm/shmem.c:				offset = inode->i_size;
mm/shmem.c:	mutex_unlock(&inode->i_mutex);
mm/shmem.c:	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
mm/shmem.c:	mutex_lock(&inode->i_mutex);
mm/shmem.c:	spin_lock(&inode->i_lock);
mm/shmem.c:	inode->i_private = &shmem_falloc;
mm/shmem.c:	spin_unlock(&inode->i_lock);
mm/shmem.c:	if (!(mode & FALLOC_FL_KEEP_SIZE) && offset + len > inode->i_size)
mm/shmem.c:	inode->i_ctime = CURRENT_TIME;
mm/shmem.c:	spin_lock(&inode->i_lock);
mm/shmem.c:	inode->i_private = NULL;
mm/shmem.c:	spin_unlock(&inode->i_lock);
mm/shmem.c:	mutex_unlock(&inode->i_mutex);
mm/shmem.c:	ret = shmem_reserve_inode(inode->i_sb);
mm/shmem.c:	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
mm/shmem.c:	if (inode->i_nlink > 1 && !S_ISDIR(inode->i_mode))
mm/shmem.c:		shmem_free_inode(inode->i_sb);
mm/shmem.c:	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
mm/shmem.c:	int they_are_dirs = S_ISDIR(inode->i_mode);
mm/shmem.c:	inode->i_ctime = CURRENT_TIME;
mm/shmem.c:	inode->i_size = len-1;
mm/shmem.c:		inode->i_op = &shmem_short_symlink_operations;
mm/shmem.c:		inode->i_mapping->a_ops = &shmem_aops;
mm/shmem.c:		inode->i_op = &shmem_symlink_inode_operations;
mm/shmem.c:					    inode->i_ino + inode->i_generation);
mm/shmem.c:	fh[0] = inode->i_generation;
mm/shmem.c:	fh[1] = inode->i_ino;
mm/shmem.c:	fh[2] = ((__u64)inode->i_ino) >> 32;
mm/shmem.c:	inode->i_uid = sbinfo->uid;
mm/shmem.c:	inode->i_gid = sbinfo->gid;
mm/shmem.c:	if (S_ISREG(inode->i_mode))
mm/shmem.c:	call_rcu(&inode->i_rcu, shmem_destroy_callback);
mm/shmem.c:	truncate_inode_pages_range(inode->i_mapping, lstart, lend);
mm/shmem.c:	inode->i_size = size;
mm/rmap.c: * inode->i_mutex	(while writing or truncating, not reading or faulting)
mm/rmap.c: *               inode->i_lock (in set_page_dirty's __mark_inode_dirty)
mm/cleancache.c:	struct super_block *sb = inode->i_sb;
mm/cleancache.c:	key->u.ino = inode->i_ino;
mm/hugetlb.c:	return HUGETLBFS_SB(inode->i_sb)->spool;
mm/hugetlb.c:		return region_chg(&inode->i_mapping->private_list,
mm/hugetlb.c:		region_add(&inode->i_mapping->private_list, idx, idx + 1);
mm/hugetlb.c:	mapping = vma->vm_file->f_dentry->d_inode->i_mapping;
mm/hugetlb.c:			spin_lock(&inode->i_lock);
mm/hugetlb.c:			inode->i_blocks += blocks_per_huge_page(h);
mm/hugetlb.c:			spin_unlock(&inode->i_lock);
mm/hugetlb.c:		chg = region_chg(&inode->i_mapping->private_list, from, to);
mm/hugetlb.c:		region_add(&inode->i_mapping->private_list, from, to);
mm/hugetlb.c:	long chg = region_truncate(&inode->i_mapping->private_list, offset);
mm/hugetlb.c:	spin_lock(&inode->i_lock);
mm/hugetlb.c:	inode->i_blocks -= (blocks_per_huge_page(h) * freed);
mm/hugetlb.c:	spin_unlock(&inode->i_lock);
mm/page_io.c:	blkbits = inode->i_blkbits;
mm/filemap_xip.c:	if (pos > inode->i_size) {
mm/filemap_xip.c:	sb_start_write(inode->i_sb);
mm/filemap_xip.c:	mutex_lock(&inode->i_mutex);
mm/filemap_xip.c:	ret = generic_write_checks(filp, &pos, &count, S_ISBLK(inode->i_mode));
mm/filemap_xip.c:	mutex_unlock(&inode->i_mutex);
mm/filemap_xip.c:	sb_end_write(inode->i_sb);
Documentation/lockstat.txt:              &inode->i_data.tree_lock-W:            15          21657           0.18     1093295.30 11547131054.85             58          10415           0.16          87.51        6387.60
Documentation/lockstat.txt:              &inode->i_data.tree_lock-R:             0              0           0.00           0.00           0.00          23302         231198           0.25           8.45       98023.38
Documentation/lockstat.txt:                         &inode->i_mutex:           161            286 18446744073709       62882.54     1244614.55           3653          20598 18446744073709       62318.60     1693822.74
Documentation/lockstat.txt:              &inode->i_data.i_mmap_mutex:            79             79           0.40           3.77          53.03          11779          87755           0.28         116.93       29898.44
Documentation/filesystems/vfs.txt:	with the inode->i_lock spinlock held.
Documentation/filesystems/vfs.txt:				dentry->d_inode->i_ino);
Documentation/filesystems/porting:Remove inode->u.foo_inode_i
Documentation/filesystems/porting:Use FOO_I(inode) instead of &inode->u.foo_inode_i;
Documentation/filesystems/porting:	if (inode->i_state & I_NEW) {
Documentation/filesystems/porting:remaining links or not.  Caller does *not* evict the pagecache or inode-associated
Documentation/filesystems/porting:inode->i_lock held and it returns true if filesystems wants the inode to be
Documentation/filesystems/porting:before, if you are using inode-associated metadata buffers (i.e.
Documentation/filesystems/Locking:drop_inode:				!!!inode->i_lock!!!
Documentation/sysctl/fs.txt:- inode-max
Documentation/sysctl/fs.txt:- inode-nr
Documentation/sysctl/fs.txt:- inode-state
Documentation/sysctl/fs.txt:inode-max, inode-nr & inode-state:
Documentation/sysctl/fs.txt:The value in inode-max denotes the maximum number of inode
Documentation/sysctl/fs.txt:The file inode-nr contains the first two items from
Documentation/sysctl/fs.txt:inode-state, so we'll skip to that file...
Documentation/sysctl/fs.txt:allocated, this can be slightly more than inode-max because
Documentation/sysctl/fs.txt:preshrink is nonzero when the nr_inodes > inode-max and the
fs/cramfs/inode.c:	 * cramfs_inode->offset is set to a non zero value for entries
fs/cramfs/inode.c:	if (!(inode->i_state & I_NEW))
fs/cramfs/inode.c:	switch (cramfs_inode->mode & S_IFMT) {
fs/cramfs/inode.c:		inode->i_fop = &generic_ro_fops;
fs/cramfs/inode.c:		inode->i_data.a_ops = &cramfs_aops;
fs/cramfs/inode.c:		inode->i_op = &cramfs_dir_inode_operations;
fs/cramfs/inode.c:		inode->i_fop = &cramfs_directory_operations;
fs/cramfs/inode.c:		inode->i_op = &page_symlink_inode_operations;
fs/cramfs/inode.c:		inode->i_data.a_ops = &cramfs_aops;
fs/cramfs/inode.c:		init_special_inode(inode, cramfs_inode->mode,
fs/cramfs/inode.c:				old_decode_dev(cramfs_inode->size));
fs/cramfs/inode.c:	inode->i_mode = cramfs_inode->mode;
fs/cramfs/inode.c:	i_uid_write(inode, cramfs_inode->uid);
fs/cramfs/inode.c:	i_gid_write(inode, cramfs_inode->gid);
fs/cramfs/inode.c:	if (!(inode->i_ino & 3)) {
fs/cramfs/inode.c:		inode->i_size = cramfs_inode->size;
fs/cramfs/inode.c:		inode->i_blocks = (cramfs_inode->size - 1) / 512 + 1;
fs/cramfs/inode.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = zerotime;
fs/cramfs/inode.c:	/* inode->i_nlink is left 1 - arguably wrong for directories,
fs/cramfs/inode.c:	struct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;
fs/cramfs/inode.c:	struct super_block *sb = inode->i_sb;
fs/cramfs/inode.c:	if (offset >= inode->i_size)
fs/cramfs/inode.c:	while (offset < inode->i_size) {
fs/cramfs/inode.c:	maxblock = (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
fs/cramfs/inode.c:		struct super_block *sb = inode->i_sb;
fs/devpts/inode.c:	if (inode->i_sb->s_magic == DEVPTS_SUPER_MAGIC)
fs/devpts/inode.c:		return inode->i_sb;
fs/devpts/inode.c:	mutex_lock(&root->d_inode->i_mutex);
fs/devpts/inode.c:	inode->i_ino = 2;
fs/devpts/inode.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
fs/devpts/inode.c:	mutex_unlock(&root->d_inode->i_mutex);
fs/devpts/inode.c:		inode->i_mode = S_IFCHR|fsi->mount_opts.ptmxmode;
fs/devpts/inode.c:	inode->i_ino = 1;
fs/devpts/inode.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
fs/devpts/inode.c:	inode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO | S_IWUSR;
fs/devpts/inode.c:	inode->i_op = &simple_dir_inode_operations;
fs/devpts/inode.c:	inode->i_fop = &simple_dir_operations;
fs/devpts/inode.c:	inode->i_ino = index + 3;
fs/devpts/inode.c:	inode->i_uid = opts->setuid ? opts->uid : current_fsuid();
fs/devpts/inode.c:	inode->i_gid = opts->setgid ? opts->gid : current_fsgid();
fs/devpts/inode.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
fs/devpts/inode.c:	inode->i_private = priv;
fs/devpts/inode.c:	mutex_lock(&root->d_inode->i_mutex);
fs/devpts/inode.c:	mutex_unlock(&root->d_inode->i_mutex);
fs/devpts/inode.c:	BUG_ON(pts_inode->i_rdev == MKDEV(TTYAUX_MAJOR, PTMX_MINOR));
fs/devpts/inode.c:	if (pts_inode->i_sb->s_magic == DEVPTS_SUPER_MAGIC)
fs/devpts/inode.c:		priv = pts_inode->i_private;
fs/devpts/inode.c:	BUG_ON(inode->i_rdev == MKDEV(TTYAUX_MAJOR, PTMX_MINOR));
fs/devpts/inode.c:	mutex_lock(&root->d_inode->i_mutex);
fs/devpts/inode.c:	mutex_unlock(&root->d_inode->i_mutex);
fs/jbd/journal.c:	journal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;
fs/jbd/journal.c:		  journal, inode->i_sb->s_id, inode->i_ino,
fs/jbd/journal.c:		  (long long) inode->i_size,
fs/jbd/journal.c:		  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);
fs/jbd/journal.c:	journal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;
fs/jbd/journal.c:	journal->j_blocksize = inode->i_sb->s_blocksize;
fs/jbd/journal.c:		bdev = journal->j_inode->i_sb->s_bdev;
fs/jbd/journal.c:	return 1 << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);
fs/bfs/inode.c:	if (!(inode->i_state & I_NEW))
fs/bfs/inode.c:	if ((ino < BFS_ROOT_INO) || (ino > BFS_SB(inode->i_sb)->si_lasti)) {
fs/bfs/inode.c:		printf("Bad inode number %s:%08lx\n", inode->i_sb->s_id, ino);
fs/bfs/inode.c:	bh = sb_bread(inode->i_sb, block);
fs/bfs/inode.c:		printf("Unable to read inode %s:%08lx\n", inode->i_sb->s_id,
fs/bfs/inode.c:	inode->i_mode = 0x0000FFFF & le32_to_cpu(di->i_mode);
fs/bfs/inode.c:		inode->i_mode |= S_IFDIR;
fs/bfs/inode.c:		inode->i_op = &bfs_dir_inops;
fs/bfs/inode.c:		inode->i_fop = &bfs_dir_operations;
fs/bfs/inode.c:		inode->i_mode |= S_IFREG;
fs/bfs/inode.c:		inode->i_op = &bfs_file_inops;
fs/bfs/inode.c:		inode->i_fop = &bfs_file_operations;
fs/bfs/inode.c:		inode->i_mapping->a_ops = &bfs_aops;
fs/bfs/inode.c:	inode->i_size = BFS_FILESIZE(di);
fs/bfs/inode.c:	inode->i_blocks = BFS_FILEBLOCKS(di);
fs/bfs/inode.c:	inode->i_atime.tv_sec =  le32_to_cpu(di->i_atime);
fs/bfs/inode.c:	inode->i_mtime.tv_sec =  le32_to_cpu(di->i_mtime);
fs/bfs/inode.c:	inode->i_ctime.tv_sec =  le32_to_cpu(di->i_ctime);
fs/bfs/inode.c:	inode->i_atime.tv_nsec = 0;
fs/bfs/inode.c:	inode->i_mtime.tv_nsec = 0;
fs/bfs/inode.c:	inode->i_ctime.tv_nsec = 0;
fs/bfs/inode.c:	struct bfs_sb_info *info = BFS_SB(inode->i_sb);
fs/bfs/inode.c:	unsigned int ino = (u16)inode->i_ino;
fs/bfs/inode.c:	di = find_inode(inode->i_sb, ino, &bh);
fs/bfs/inode.c:	di->i_mode = cpu_to_le32(inode->i_mode);
fs/bfs/inode.c:	di->i_nlink = cpu_to_le32(inode->i_nlink);
fs/bfs/inode.c:	di->i_atime = cpu_to_le32(inode->i_atime.tv_sec);
fs/bfs/inode.c:	di->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);
fs/bfs/inode.c:	di->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);
fs/bfs/inode.c:	di->i_eoffset = cpu_to_le32(i_sblock * BFS_BSIZE + inode->i_size - 1);
fs/bfs/inode.c:	unsigned long ino = inode->i_ino;
fs/bfs/inode.c:	struct super_block *s = inode->i_sb;
fs/bfs/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/bfs/inode.c:	if (inode->i_nlink)
fs/bfs/inode.c:	di = find_inode(s, inode->i_ino, &bh);
fs/bfs/inode.c:	call_rcu(&inode->i_rcu, bfs_i_callback);
fs/bfs/dir.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
fs/bfs/dir.c:	inode->i_blocks = 0;
fs/bfs/dir.c:	inode->i_op = &bfs_file_inops;
fs/bfs/dir.c:	inode->i_fop = &bfs_file_operations;
fs/bfs/dir.c:	inode->i_mapping->a_ops = &bfs_aops;
fs/bfs/dir.c:	inode->i_ino = ino;
fs/bfs/dir.c:							inode->i_ino);
fs/bfs/dir.c:	struct bfs_sb_info *info = BFS_SB(inode->i_sb);
fs/bfs/dir.c:							inode->i_ino);
fs/bfs/dir.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/bfs/dir.c:	struct bfs_sb_info *info = BFS_SB(inode->i_sb);
fs/bfs/dir.c:	if (!bh || (le16_to_cpu(de->ino) != inode->i_ino))
fs/bfs/dir.c:	if (!inode->i_nlink) {
fs/bfs/dir.c:					inode->i_sb->s_id, inode->i_ino,
fs/bfs/dir.c:					inode->i_nlink);
fs/bfs/dir.c:	inode->i_ctime = dir->i_ctime;
fs/bfs/dir.c:	if (S_ISDIR(old_inode->i_mode))
fs/bfs/dir.c:	info = BFS_SB(old_inode->i_sb);
fs/bfs/dir.c:	if (!old_bh || (le16_to_cpu(old_de->ino) != old_inode->i_ino))
fs/bfs/dir.c:					old_inode->i_ino);
fs/bfs/dir.c:		new_inode->i_ctime = CURRENT_TIME_SEC;
fs/bfs/file.c:	struct super_block *sb = inode->i_sb;
fs/bfs/file.c:		err = bfs_move_blocks(inode->i_sb, bi->i_sblock, 
fs/bfs/file.c:								inode->i_ino);
fs/bfs/file.c:	 * and thus update inode->i_blocks! (XXX)
fs/bfs/file.c:	info->si_freeb -= bi->i_eblock - bi->i_sblock + 1 - inode->i_blocks;
fs/bfs/file.c:	if (to > inode->i_size)
fs/bfs/file.c:		truncate_pagecache(inode, to, inode->i_size);
fs/inode.c: * inode->i_lock protects:
fs/inode.c: *   inode->i_state, inode->i_hash, __iget()
fs/inode.c: * inode->i_sb->s_inode_lru_lock protects:
fs/inode.c: *   inode->i_sb->s_inode_lru, inode->i_lru
fs/inode.c: *   sb->s_inodes, inode->i_sb_list
fs/inode.c: *   bdi->wb.b_{dirty,io,more_io}, inode->i_wb_list
fs/inode.c: *   inode_hashtable, inode->i_hash
fs/inode.c: *   inode->i_lock
fs/inode.c: *     inode->i_sb->s_inode_lru_lock
fs/inode.c: *   inode->i_lock
fs/inode.c: *   inode->i_lock
fs/inode.c:	struct address_space *const mapping = &inode->i_data;
fs/inode.c:	inode->i_sb = sb;
fs/inode.c:	inode->i_blkbits = sb->s_blocksize_bits;
fs/inode.c:	inode->i_flags = 0;
fs/inode.c:	atomic_set(&inode->i_count, 1);
fs/inode.c:	inode->i_op = &empty_iops;
fs/inode.c:	inode->i_fop = &empty_fops;
fs/inode.c:	inode->__i_nlink = 1;
fs/inode.c:	inode->i_opflags = 0;
fs/inode.c:	atomic_set(&inode->i_writecount, 0);
fs/inode.c:	inode->i_size = 0;
fs/inode.c:	inode->i_blocks = 0;
fs/inode.c:	inode->i_bytes = 0;
fs/inode.c:	inode->i_generation = 0;
fs/inode.c:	memset(&inode->i_dquot, 0, sizeof(inode->i_dquot));
fs/inode.c:	inode->i_pipe = NULL;
fs/inode.c:	inode->i_bdev = NULL;
fs/inode.c:	inode->i_cdev = NULL;
fs/inode.c:	inode->i_rdev = 0;
fs/inode.c:	inode->dirtied_when = 0;
fs/inode.c:	spin_lock_init(&inode->i_lock);
fs/inode.c:	lockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);
fs/inode.c:	mutex_init(&inode->i_mutex);
fs/inode.c:	lockdep_set_class(&inode->i_mutex, &sb->s_type->i_mutex_key);
fs/inode.c:	atomic_set(&inode->i_dio_count, 0);
fs/inode.c:		bdi = sb->s_bdev->bd_inode->i_mapping->backing_dev_info;
fs/inode.c:	inode->i_private = NULL;
fs/inode.c:	inode->i_mapping = mapping;
fs/inode.c:	INIT_HLIST_HEAD(&inode->i_dentry);	/* buggered by rcu freeing */
fs/inode.c:	inode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;
fs/inode.c:	inode->i_fsnotify_mask = 0;
fs/inode.c:		if (inode->i_sb->s_op->destroy_inode)
fs/inode.c:			inode->i_sb->s_op->destroy_inode(inode);
fs/inode.c:	if (!inode->i_nlink) {
fs/inode.c:		WARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);
fs/inode.c:		atomic_long_dec(&inode->i_sb->s_remove_count);
fs/inode.c:	if (inode->i_acl && inode->i_acl != ACL_NOT_CACHED)
fs/inode.c:		posix_acl_release(inode->i_acl);
fs/inode.c:	if (inode->i_default_acl && inode->i_default_acl != ACL_NOT_CACHED)
fs/inode.c:		posix_acl_release(inode->i_default_acl);
fs/inode.c:	BUG_ON(!list_empty(&inode->i_lru));
fs/inode.c:	if (inode->i_sb->s_op->destroy_inode)
fs/inode.c:		inode->i_sb->s_op->destroy_inode(inode);
fs/inode.c:		call_rcu(&inode->i_rcu, i_callback);
fs/inode.c:	WARN_ON(inode->i_nlink == 0);
fs/inode.c:	inode->__i_nlink--;
fs/inode.c:	if (!inode->i_nlink)
fs/inode.c:		atomic_long_inc(&inode->i_sb->s_remove_count);
fs/inode.c:	if (inode->i_nlink) {
fs/inode.c:		inode->__i_nlink = 0;
fs/inode.c:		atomic_long_inc(&inode->i_sb->s_remove_count);
fs/inode.c:		if (inode->i_nlink == 0)
fs/inode.c:			atomic_long_dec(&inode->i_sb->s_remove_count);
fs/inode.c:		inode->__i_nlink = nlink;
fs/inode.c:	if (WARN_ON(inode->i_nlink == 0))
fs/inode.c:		atomic_long_dec(&inode->i_sb->s_remove_count);
fs/inode.c:	inode->__i_nlink++;
fs/inode.c:	INIT_HLIST_NODE(&inode->i_hash);
fs/inode.c:	INIT_LIST_HEAD(&inode->i_devices);
fs/inode.c:	INIT_LIST_HEAD(&inode->i_wb_list);
fs/inode.c:	INIT_LIST_HEAD(&inode->i_lru);
fs/inode.c:	address_space_init_once(&inode->i_data);
fs/inode.c:	INIT_HLIST_HEAD(&inode->i_fsnotify_marks);
fs/inode.c: * inode->i_lock must be held
fs/inode.c:	atomic_inc(&inode->i_count);
fs/inode.c:	WARN_ON(atomic_inc_return(&inode->i_count) < 2);
fs/inode.c:	spin_lock(&inode->i_sb->s_inode_lru_lock);
fs/inode.c:	if (list_empty(&inode->i_lru)) {
fs/inode.c:		list_add(&inode->i_lru, &inode->i_sb->s_inode_lru);
fs/inode.c:		inode->i_sb->s_nr_inodes_unused++;
fs/inode.c:	spin_unlock(&inode->i_sb->s_inode_lru_lock);
fs/inode.c: * Needs inode->i_lock held.
fs/inode.c:	if (!(inode->i_state & (I_DIRTY | I_SYNC | I_FREEING | I_WILL_FREE)) &&
fs/inode.c:	    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & MS_ACTIVE)
fs/inode.c:	spin_lock(&inode->i_sb->s_inode_lru_lock);
fs/inode.c:	if (!list_empty(&inode->i_lru)) {
fs/inode.c:		list_del_init(&inode->i_lru);
fs/inode.c:		inode->i_sb->s_nr_inodes_unused--;
fs/inode.c:	spin_unlock(&inode->i_sb->s_inode_lru_lock);
fs/inode.c:	list_add(&inode->i_sb_list, &inode->i_sb->s_inodes);
fs/inode.c:	if (!list_empty(&inode->i_sb_list)) {
fs/inode.c:		list_del_init(&inode->i_sb_list);
fs/inode.c:	struct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);
fs/inode.c:	spin_lock(&inode->i_lock);
fs/inode.c:	hlist_add_head(&inode->i_hash, b);
fs/inode.c:	spin_unlock(&inode->i_lock);
fs/inode.c:	spin_lock(&inode->i_lock);
fs/inode.c:	hlist_del_init(&inode->i_hash);
fs/inode.c:	spin_unlock(&inode->i_lock);
fs/inode.c:	spin_lock_irq(&inode->i_data.tree_lock);
fs/inode.c:	BUG_ON(inode->i_data.nrpages);
fs/inode.c:	spin_unlock_irq(&inode->i_data.tree_lock);
fs/inode.c:	BUG_ON(!list_empty(&inode->i_data.private_list));
fs/inode.c:	BUG_ON(!(inode->i_state & I_FREEING));
fs/inode.c:	BUG_ON(inode->i_state & I_CLEAR);
fs/inode.c:	inode->i_state = I_FREEING | I_CLEAR;
fs/inode.c:	const struct super_operations *op = inode->i_sb->s_op;
fs/inode.c:	BUG_ON(!(inode->i_state & I_FREEING));
fs/inode.c:	BUG_ON(!list_empty(&inode->i_lru));
fs/inode.c:	if (!list_empty(&inode->i_wb_list))
fs/inode.c:		if (inode->i_data.nrpages)
fs/inode.c:			truncate_inode_pages(&inode->i_data, 0);
fs/inode.c:	if (S_ISBLK(inode->i_mode) && inode->i_bdev)
fs/inode.c:	if (S_ISCHR(inode->i_mode) && inode->i_cdev)
fs/inode.c:	spin_lock(&inode->i_lock);
fs/inode.c:	wake_up_bit(&inode->i_state, __I_NEW);
fs/inode.c:	BUG_ON(inode->i_state != (I_FREEING | I_CLEAR));
fs/inode.c:	spin_unlock(&inode->i_lock);
fs/inode.c:		list_del_init(&inode->i_lru);
fs/inode.c:		if (atomic_read(&inode->i_count))
fs/inode.c:		spin_lock(&inode->i_lock);
fs/inode.c:		if (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {
fs/inode.c:			spin_unlock(&inode->i_lock);
fs/inode.c:		inode->i_state |= I_FREEING;
fs/inode.c:		spin_unlock(&inode->i_lock);
fs/inode.c:		list_add(&inode->i_lru, &dispose);
fs/inode.c:		spin_lock(&inode->i_lock);
fs/inode.c:		if (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {
fs/inode.c:			spin_unlock(&inode->i_lock);
fs/inode.c:		if (inode->i_state & I_DIRTY && !kill_dirty) {
fs/inode.c:			spin_unlock(&inode->i_lock);
fs/inode.c:		if (atomic_read(&inode->i_count)) {
fs/inode.c:			spin_unlock(&inode->i_lock);
fs/inode.c:		inode->i_state |= I_FREEING;
fs/inode.c:		spin_unlock(&inode->i_lock);
fs/inode.c:		list_add(&inode->i_lru, &dispose);
fs/inode.c:	if (inode->i_state & ~I_REFERENCED)
fs/inode.c:	if (atomic_read(&inode->i_count))
fs/inode.c:	if (inode->i_data.nrpages)
fs/inode.c:		 * we are inverting the sb->s_inode_lru_lock/inode->i_lock here,
fs/inode.c:		if (!spin_trylock(&inode->i_lock)) {
fs/inode.c:			list_move(&inode->i_lru, &sb->s_inode_lru);
fs/inode.c:		if (atomic_read(&inode->i_count) ||
fs/inode.c:		    (inode->i_state & ~I_REFERENCED)) {
fs/inode.c:			list_del_init(&inode->i_lru);
fs/inode.c:			spin_unlock(&inode->i_lock);
fs/inode.c:		if (inode->i_state & I_REFERENCED) {
fs/inode.c:			inode->i_state &= ~I_REFERENCED;
fs/inode.c:			list_move(&inode->i_lru, &sb->s_inode_lru);
fs/inode.c:			spin_unlock(&inode->i_lock);
fs/inode.c:		if (inode_has_buffers(inode) || inode->i_data.nrpages) {
fs/inode.c:			spin_unlock(&inode->i_lock);
fs/inode.c:				reap += invalidate_mapping_pages(&inode->i_data,
fs/inode.c:			if (!spin_trylock(&inode->i_lock))
fs/inode.c:				spin_unlock(&inode->i_lock);
fs/inode.c:		WARN_ON(inode->i_state & I_NEW);
fs/inode.c:		inode->i_state |= I_FREEING;
fs/inode.c:		spin_unlock(&inode->i_lock);
fs/inode.c:		list_move(&inode->i_lru, &freeable);
fs/inode.c:		spin_lock(&inode->i_lock);
fs/inode.c:		if (inode->i_sb != sb) {
fs/inode.c:			spin_unlock(&inode->i_lock);
fs/inode.c:			spin_unlock(&inode->i_lock);
fs/inode.c:		if (inode->i_state & (I_FREEING|I_WILL_FREE)) {
fs/inode.c:		spin_unlock(&inode->i_lock);
fs/inode.c:		spin_lock(&inode->i_lock);
fs/inode.c:		if (inode->i_ino != ino) {
fs/inode.c:			spin_unlock(&inode->i_lock);
fs/inode.c:		if (inode->i_sb != sb) {
fs/inode.c:			spin_unlock(&inode->i_lock);
fs/inode.c:		if (inode->i_state & (I_FREEING|I_WILL_FREE)) {
fs/inode.c:		spin_unlock(&inode->i_lock);
fs/inode.c:		spin_lock(&inode->i_lock);
fs/inode.c:		inode->i_state = 0;
fs/inode.c:		spin_unlock(&inode->i_lock);
fs/inode.c:		INIT_LIST_HEAD(&inode->i_sb_list);
fs/inode.c: *	for allocations related to inode->i_mapping is GFP_HIGHUSER_MOVABLE.
fs/inode.c:	if (S_ISDIR(inode->i_mode)) {
fs/inode.c:		struct file_system_type *type = inode->i_sb->s_type;
fs/inode.c:		if (lockdep_match_class(&inode->i_mutex, &type->i_mutex_key)) {
fs/inode.c:			mutex_destroy(&inode->i_mutex);
fs/inode.c:			mutex_init(&inode->i_mutex);
fs/inode.c:			lockdep_set_class(&inode->i_mutex,
fs/inode.c:	spin_lock(&inode->i_lock);
fs/inode.c:	WARN_ON(!(inode->i_state & I_NEW));
fs/inode.c:	inode->i_state &= ~I_NEW;
fs/inode.c:	wake_up_bit(&inode->i_state, __I_NEW);
fs/inode.c:	spin_unlock(&inode->i_lock);
fs/inode.c:			spin_lock(&inode->i_lock);
fs/inode.c:			inode->i_state = I_NEW;
fs/inode.c:			hlist_add_head(&inode->i_hash, head);
fs/inode.c:			spin_unlock(&inode->i_lock);
fs/inode.c:			inode->i_ino = ino;
fs/inode.c:			spin_lock(&inode->i_lock);
fs/inode.c:			inode->i_state = I_NEW;
fs/inode.c:			hlist_add_head(&inode->i_hash, head);
fs/inode.c:			spin_unlock(&inode->i_lock);
fs/inode.c:		if (inode->i_ino == ino && inode->i_sb == sb) {
fs/inode.c:	spin_lock(&inode->i_lock);
fs/inode.c:	if (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {
fs/inode.c:		spin_unlock(&inode->i_lock);
fs/inode.c:		spin_unlock(&inode->i_lock);
fs/inode.c:	struct super_block *sb = inode->i_sb;
fs/inode.c:	ino_t ino = inode->i_ino;
fs/inode.c:			spin_lock(&inode->i_lock);
fs/inode.c:			inode->i_state |= I_NEW;
fs/inode.c:			hlist_add_head(&inode->i_hash, head);
fs/inode.c:			spin_unlock(&inode->i_lock);
fs/inode.c:	struct super_block *sb = inode->i_sb;
fs/inode.c:			spin_lock(&inode->i_lock);
fs/inode.c:			inode->i_state |= I_NEW;
fs/inode.c:			hlist_add_head(&inode->i_hash, head);
fs/inode.c:			spin_unlock(&inode->i_lock);
fs/inode.c:	struct super_block *sb = inode->i_sb;
fs/inode.c:	const struct super_operations *op = inode->i_sb->s_op;
fs/inode.c:	WARN_ON(inode->i_state & I_NEW);
fs/inode.c:		inode->i_state |= I_REFERENCED;
fs/inode.c:		spin_unlock(&inode->i_lock);
fs/inode.c:		inode->i_state |= I_WILL_FREE;
fs/inode.c:		spin_unlock(&inode->i_lock);
fs/inode.c:		spin_lock(&inode->i_lock);
fs/inode.c:		WARN_ON(inode->i_state & I_NEW);
fs/inode.c:		inode->i_state &= ~I_WILL_FREE;
fs/inode.c:	inode->i_state |= I_FREEING;
fs/inode.c:	if (!list_empty(&inode->i_lru))
fs/inode.c:	spin_unlock(&inode->i_lock);
fs/inode.c:		BUG_ON(inode->i_state & I_CLEAR);
fs/inode.c:		if (atomic_dec_and_lock(&inode->i_count, &inode->i_lock))
fs/inode.c:	if (inode->i_mapping->a_ops->bmap)
fs/inode.c:		res = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);
fs/inode.c:	if (timespec_compare(&inode->i_mtime, &inode->i_atime) >= 0)
fs/inode.c:	if (timespec_compare(&inode->i_ctime, &inode->i_atime) >= 0)
fs/inode.c:	if ((long)(now.tv_sec - inode->i_atime.tv_sec) >= 24*60*60)
fs/inode.c:	if (inode->i_op->update_time)
fs/inode.c:		return inode->i_op->update_time(inode, time, flags);
fs/inode.c:		inode->i_atime = *time;
fs/inode.c:		inode->i_ctime = *time;
fs/inode.c:		inode->i_mtime = *time;
fs/inode.c:	if (inode->i_flags & S_NOATIME)
fs/inode.c:	if ((inode->i_sb->s_flags & MS_NODIRATIME) && S_ISDIR(inode->i_mode))
fs/inode.c:	if ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))
fs/inode.c:	now = current_fs_time(inode->i_sb);
fs/inode.c:	if (timespec_equal(&inode->i_atime, &now))
fs/inode.c:	if (!sb_start_write_trylock(inode->i_sb))
fs/inode.c:	sb_end_write(inode->i_sb);
fs/inode.c:	umode_t mode = dentry->d_inode->i_mode;
fs/inode.c:	if (!error && (inode->i_sb->s_flags & MS_NOSEC))
fs/inode.c:		inode->i_flags |= S_NOSEC;
fs/inode.c:	now = current_fs_time(inode->i_sb);
fs/inode.c:	if (!timespec_equal(&inode->i_mtime, &now))
fs/inode.c:	if (!timespec_equal(&inode->i_ctime, &now))
fs/inode.c:	if (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))
fs/inode.c: * wake_up_bit(&inode->i_state, __I_NEW) after removing from the hash list
fs/inode.c:	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
fs/inode.c:	wq = bit_waitqueue(&inode->i_state, __I_NEW);
fs/inode.c:	spin_unlock(&inode->i_lock);
fs/inode.c:	inode->i_mode = mode;
fs/inode.c:		inode->i_fop = &def_chr_fops;
fs/inode.c:		inode->i_rdev = rdev;
fs/inode.c:		inode->i_fop = &def_blk_fops;
fs/inode.c:		inode->i_rdev = rdev;
fs/inode.c:		inode->i_fop = &def_fifo_fops;
fs/inode.c:		inode->i_fop = &bad_sock_fops;
fs/inode.c:				  " inode %s:%lu\n", mode, inode->i_sb->s_id,
fs/inode.c:				  inode->i_ino);
fs/inode.c:	inode->i_uid = current_fsuid();
fs/inode.c:		inode->i_gid = dir->i_gid;
fs/inode.c:		inode->i_gid = current_fsgid();
fs/inode.c:	inode->i_mode = mode;
fs/inode.c:	if (uid_eq(current_fsuid(), inode->i_uid))
fs/inode.c:	wait_queue_head_t *wq = bit_waitqueue(&inode->i_state, __I_DIO_WAKEUP);
fs/inode.c:	DEFINE_WAIT_BIT(q, &inode->i_state, __I_DIO_WAKEUP);
fs/inode.c:		if (atomic_read(&inode->i_dio_count))
fs/inode.c:	} while (atomic_read(&inode->i_dio_count));
fs/inode.c: * to i_dio_count, usually by inode->i_mutex.
fs/inode.c:	if (atomic_read(&inode->i_dio_count))
fs/inode.c:	if (atomic_dec_and_test(&inode->i_dio_count))
fs/inode.c:		wake_up_bit(&inode->i_state, __I_DIO_WAKEUP);
fs/adfs/inode.c:		if (block >= inode->i_blocks)
fs/adfs/inode.c:		block = __adfs_block_map(inode->i_sb, inode->i_ino, block);
fs/adfs/inode.c:			map_bh(bh, inode->i_sb, block);
fs/adfs/inode.c:	if (to > inode->i_size)
fs/adfs/inode.c:		truncate_pagecache(inode, to, inode->i_size);
fs/adfs/inode.c:	if (S_ISLNK(inode->i_mode))
fs/adfs/inode.c:	if (S_ISDIR(inode->i_mode))
fs/adfs/inode.c:	mode = inode->i_mode & asb->s_owner_mask;
fs/adfs/inode.c:	mode = inode->i_mode & asb->s_other_mask;
fs/adfs/inode.c: * Note that this is an inode-less filesystem, so we can't use the inode
fs/adfs/inode.c:	inode->i_uid	 = ADFS_SB(sb)->s_uid;
fs/adfs/inode.c:	inode->i_gid	 = ADFS_SB(sb)->s_gid;
fs/adfs/inode.c:	inode->i_ino	 = obj->file_id;
fs/adfs/inode.c:	inode->i_size	 = obj->size;
fs/adfs/inode.c:	inode->i_blocks	 = (inode->i_size + sb->s_blocksize - 1) >>
fs/adfs/inode.c:	inode->i_mode	 = adfs_atts2mode(sb, inode);
fs/adfs/inode.c:	adfs_adfs2unix_time(&inode->i_mtime, inode);
fs/adfs/inode.c:	inode->i_atime = inode->i_mtime;
fs/adfs/inode.c:	inode->i_ctime = inode->i_mtime;
fs/adfs/inode.c:	if (S_ISDIR(inode->i_mode)) {
fs/adfs/inode.c:		inode->i_op	= &adfs_dir_inode_operations;
fs/adfs/inode.c:		inode->i_fop	= &adfs_dir_operations;
fs/adfs/inode.c:	} else if (S_ISREG(inode->i_mode)) {
fs/adfs/inode.c:		inode->i_op	= &adfs_file_inode_operations;
fs/adfs/inode.c:		inode->i_fop	= &adfs_file_operations;
fs/adfs/inode.c:		inode->i_mapping->a_ops = &adfs_aops;
fs/adfs/inode.c:		ADFS_I(inode)->mmu_private = inode->i_size;
fs/adfs/inode.c:	struct super_block *sb = inode->i_sb;
fs/adfs/inode.c:		inode->i_mtime = attr->ia_mtime;
fs/adfs/inode.c:		inode->i_atime = attr->ia_atime;
fs/adfs/inode.c:		inode->i_ctime = attr->ia_ctime;
fs/adfs/inode.c:		inode->i_mode = adfs_atts2mode(sb, inode);
fs/adfs/inode.c:	struct super_block *sb = inode->i_sb;
fs/adfs/inode.c:	obj.file_id	= inode->i_ino;
fs/adfs/inode.c:	obj.size	= inode->i_size;
fs/adfs/super.c:	call_rcu(&inode->i_rcu, adfs_i_callback);
fs/adfs/dir.c:	struct super_block *sb = inode->i_sb;
fs/adfs/dir.c:	ret = ops->read(sb, inode->i_ino, inode->i_size, &dir);
fs/adfs/dir.c:		if (filldir(dirent, ".", 1, 0, inode->i_ino, DT_DIR) < 0)
fs/adfs/dir.c:	struct super_block *sb = inode->i_sb;
fs/adfs/dir.c:	ret = ops->read(sb, inode->i_ino, inode->i_size, &dir);
fs/adfs/dir.c:	obj->parent_id = inode->i_ino;
fs/nilfs2/inode.c:	inode_add_bytes(inode, (1 << inode->i_blkbits) * n);
fs/nilfs2/inode.c:	inode_sub_bytes(inode, (1 << inode->i_blkbits) * n);
fs/nilfs2/inode.c:	struct the_nilfs *nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/inode.c:	unsigned maxblocks = bh_result->b_size >> inode->i_blkbits;
fs/nilfs2/inode.c:		map_bh(bh_result, inode->i_sb, blknum);
fs/nilfs2/inode.c:			bh_result->b_size = (ret << inode->i_blkbits);
fs/nilfs2/inode.c:		err = nilfs_transaction_begin(inode->i_sb, &ti, 1);
fs/nilfs2/inode.c:				       inode->i_ino,
fs/nilfs2/inode.c:			nilfs_transaction_abort(inode->i_sb);
fs/nilfs2/inode.c:		nilfs_transaction_commit(inode->i_sb); /* never fails */
fs/nilfs2/inode.c:		map_bh(bh_result, inode->i_sb, 0); /* dbn must be changed
fs/nilfs2/inode.c:		err = nilfs_construct_dsync_segment(inode->i_sb, inode,
fs/nilfs2/inode.c:		err = nilfs_construct_segment(inode->i_sb);
fs/nilfs2/inode.c:		nilfs_flush_segment(inode->i_sb, inode->i_ino);
fs/nilfs2/inode.c:		unsigned nr_dirty = 1 << (PAGE_SHIFT - inode->i_blkbits);
fs/nilfs2/inode.c:	if (to > inode->i_size) {
fs/nilfs2/inode.c:		truncate_pagecache(inode, to, inode->i_size);
fs/nilfs2/inode.c:	int err = nilfs_transaction_begin(inode->i_sb, NULL, 1);
fs/nilfs2/inode.c:		nilfs_transaction_abort(inode->i_sb);
fs/nilfs2/inode.c:	err = nilfs_transaction_commit(inode->i_sb);
fs/nilfs2/inode.c:	mapping_set_gfp_mask(inode->i_mapping,
fs/nilfs2/inode.c:			     mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);
fs/nilfs2/inode.c:	inode->i_ino = ino;
fs/nilfs2/inode.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
fs/nilfs2/inode.c:	inode->i_generation = nilfs->ns_next_generation++;
fs/nilfs2/inode.c:	inode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |
fs/nilfs2/inode.c:		inode->i_flags |= S_SYNC;
fs/nilfs2/inode.c:		inode->i_flags |= S_APPEND;
fs/nilfs2/inode.c:		inode->i_flags |= S_IMMUTABLE;
fs/nilfs2/inode.c:		inode->i_flags |= S_NOATIME;
fs/nilfs2/inode.c:		inode->i_flags |= S_DIRSYNC;
fs/nilfs2/inode.c:	mapping_set_gfp_mask(inode->i_mapping,
fs/nilfs2/inode.c:			     mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);
fs/nilfs2/inode.c:	inode->i_mode = le16_to_cpu(raw_inode->i_mode);
fs/nilfs2/inode.c:	i_uid_write(inode, le32_to_cpu(raw_inode->i_uid));
fs/nilfs2/inode.c:	i_gid_write(inode, le32_to_cpu(raw_inode->i_gid));
fs/nilfs2/inode.c:	set_nlink(inode, le16_to_cpu(raw_inode->i_links_count));
fs/nilfs2/inode.c:	inode->i_size = le64_to_cpu(raw_inode->i_size);
fs/nilfs2/inode.c:	inode->i_atime.tv_sec = le64_to_cpu(raw_inode->i_mtime);
fs/nilfs2/inode.c:	inode->i_ctime.tv_sec = le64_to_cpu(raw_inode->i_ctime);
fs/nilfs2/inode.c:	inode->i_mtime.tv_sec = le64_to_cpu(raw_inode->i_mtime);
fs/nilfs2/inode.c:	inode->i_atime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);
fs/nilfs2/inode.c:	inode->i_ctime.tv_nsec = le32_to_cpu(raw_inode->i_ctime_nsec);
fs/nilfs2/inode.c:	inode->i_mtime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);
fs/nilfs2/inode.c:	if (inode->i_nlink == 0 && inode->i_mode == 0)
fs/nilfs2/inode.c:	inode->i_blocks = le64_to_cpu(raw_inode->i_blocks);
fs/nilfs2/inode.c:	ii->i_flags = le32_to_cpu(raw_inode->i_flags);
fs/nilfs2/inode.c:	ii->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);
fs/nilfs2/inode.c:	ii->i_dir_acl = S_ISREG(inode->i_mode) ?
fs/nilfs2/inode.c:		0 : le32_to_cpu(raw_inode->i_dir_acl);
fs/nilfs2/inode.c:	inode->i_generation = le32_to_cpu(raw_inode->i_generation);
fs/nilfs2/inode.c:	if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
fs/nilfs2/inode.c:	    S_ISLNK(inode->i_mode)) {
fs/nilfs2/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/nilfs2/inode.c:		inode->i_op = &nilfs_file_inode_operations;
fs/nilfs2/inode.c:		inode->i_fop = &nilfs_file_operations;
fs/nilfs2/inode.c:		inode->i_mapping->a_ops = &nilfs_aops;
fs/nilfs2/inode.c:	} else if (S_ISDIR(inode->i_mode)) {
fs/nilfs2/inode.c:		inode->i_op = &nilfs_dir_inode_operations;
fs/nilfs2/inode.c:		inode->i_fop = &nilfs_dir_operations;
fs/nilfs2/inode.c:		inode->i_mapping->a_ops = &nilfs_aops;
fs/nilfs2/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/nilfs2/inode.c:		inode->i_op = &nilfs_symlink_inode_operations;
fs/nilfs2/inode.c:		inode->i_mapping->a_ops = &nilfs_aops;
fs/nilfs2/inode.c:		inode->i_op = &nilfs_special_inode_operations;
fs/nilfs2/inode.c:			inode, inode->i_mode,
fs/nilfs2/inode.c:			huge_decode_dev(le64_to_cpu(raw_inode->i_device_code)));
fs/nilfs2/inode.c:	if (args->ino != inode->i_ino || args->root != NILFS_I(inode)->i_root)
fs/nilfs2/inode.c:	inode->i_ino = args->ino;
fs/nilfs2/inode.c:	if (!(inode->i_state & I_NEW))
fs/nilfs2/inode.c:	if (!(inode->i_state & I_NEW))
fs/nilfs2/inode.c:	raw_inode->i_mode = cpu_to_le16(inode->i_mode);
fs/nilfs2/inode.c:	raw_inode->i_uid = cpu_to_le32(i_uid_read(inode));
fs/nilfs2/inode.c:	raw_inode->i_gid = cpu_to_le32(i_gid_read(inode));
fs/nilfs2/inode.c:	raw_inode->i_links_count = cpu_to_le16(inode->i_nlink);
fs/nilfs2/inode.c:	raw_inode->i_size = cpu_to_le64(inode->i_size);
fs/nilfs2/inode.c:	raw_inode->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);
fs/nilfs2/inode.c:	raw_inode->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);
fs/nilfs2/inode.c:	raw_inode->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);
fs/nilfs2/inode.c:	raw_inode->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);
fs/nilfs2/inode.c:	raw_inode->i_blocks = cpu_to_le64(inode->i_blocks);
fs/nilfs2/inode.c:	raw_inode->i_flags = cpu_to_le32(ii->i_flags);
fs/nilfs2/inode.c:	raw_inode->i_generation = cpu_to_le32(inode->i_generation);
fs/nilfs2/inode.c:	if (NILFS_ROOT_METADATA_FILE(inode->i_ino)) {
fs/nilfs2/inode.c:		struct the_nilfs *nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/inode.c:		raw_inode->i_xattr = 0;
fs/nilfs2/inode.c:		raw_inode->i_pad = 0;
fs/nilfs2/inode.c:	else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
fs/nilfs2/inode.c:		raw_inode->i_device_code =
fs/nilfs2/inode.c:			cpu_to_le64(huge_encode_dev(inode->i_rdev));
fs/nilfs2/inode.c:	ino_t ino = inode->i_ino;
fs/nilfs2/inode.c:	struct super_block *sb = inode->i_sb;
fs/nilfs2/inode.c:	blkoff = (inode->i_size + blocksize - 1) >> sb->s_blocksize_bits;
fs/nilfs2/inode.c:	block_truncate_page(inode->i_mapping, inode->i_size, nilfs_get_block);
fs/nilfs2/inode.c:	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/nilfs2/inode.c:	if (ii->i_root && inode->i_ino == NILFS_ROOT_INO)
fs/nilfs2/inode.c:	struct super_block *sb = inode->i_sb;
fs/nilfs2/inode.c:	if (inode->i_nlink || !ii->i_root || unlikely(is_bad_inode(inode))) {
fs/nilfs2/inode.c:		if (inode->i_data.nrpages)
fs/nilfs2/inode.c:			truncate_inode_pages(&inode->i_data, 0);
fs/nilfs2/inode.c:	if (inode->i_data.nrpages)
fs/nilfs2/inode.c:		truncate_inode_pages(&inode->i_data, 0);
fs/nilfs2/inode.c:	ret = nilfs_ifile_delete_inode(ii->i_root->ifile, inode->i_ino);
fs/nilfs2/inode.c:	struct super_block *sb = inode->i_sb;
fs/nilfs2/inode.c:	struct the_nilfs *nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/inode.c:						  inode->i_ino, pbh);
fs/nilfs2/inode.c:	struct the_nilfs *nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/inode.c:	struct the_nilfs *nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/inode.c:			nilfs_warning(inode->i_sb, __func__,
fs/nilfs2/inode.c:				      inode->i_ino);
fs/nilfs2/inode.c:		nilfs_warning(inode->i_sb, __func__,
fs/nilfs2/inode.c:		nilfs_warning(inode->i_sb, __func__,
fs/nilfs2/inode.c:	nilfs_transaction_begin(inode->i_sb, &ti, 0);
fs/nilfs2/inode.c:	nilfs_transaction_commit(inode->i_sb); /* never fails */
fs/nilfs2/inode.c:	struct the_nilfs *nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/inode.c:	unsigned int blkbits = inode->i_blkbits;
fs/nilfs2/inode.c:	mutex_lock(&inode->i_mutex);
fs/nilfs2/inode.c:	mutex_unlock(&inode->i_mutex);
fs/nilfs2/alloc.c:	return (1UL << inode->i_blkbits) /
fs/nilfs2/alloc.c:	return 1UL << (BITS_PER_LONG - (inode->i_blkbits + 3 /* log2(8) */));
fs/nilfs2/mdt.h:	return inode->i_private;
fs/nilfs2/mdt.h:	return ((struct the_nilfs *)inode->i_sb->s_fs_info)->ns_cno;
fs/nilfs2/super.c:	call_rcu(&inode->i_rcu, nilfs_i_callback);
fs/nilfs2/super.c:	if (!S_ISDIR(inode->i_mode) || !inode->i_blocks || !inode->i_size) {
fs/nilfs2/super.c:	bdi = sb->s_bdev->bd_inode->i_mapping->backing_dev_info;
fs/nilfs2/page.c:	int blkbits = inode->i_blkbits;
fs/nilfs2/page.c:	if (inode->i_mapping->nrpages == 0)
fs/nilfs2/page.c:	index = start_blk >> (PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/nilfs2/page.c:	nblocks_in_page = 1U << (PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/nilfs2/page.c:	pvec.nr = find_get_pages_contig(inode->i_mapping, index, PAGEVEC_SIZE,
fs/nilfs2/page.c:	b = pvec.pages[0]->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/nilfs2/alloc.h:	return 1UL << (inode->i_blkbits + 3 /* log2(8 = CHAR_BITS) */);
fs/nilfs2/nilfs.h:	inode->i_mode &= ~current_umask();
fs/nilfs2/dir.c:	return inode->i_sb->s_blocksize;
fs/nilfs2/dir.c:	return (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;
fs/nilfs2/dir.c:	unsigned last_byte = inode->i_size;
fs/nilfs2/dir.c:	umode_t mode = inode->i_mode;
fs/nilfs2/dir.c:	struct super_block *sb = inode->i_sb;
fs/nilfs2/dir.c:	if (pos > inode->i_size - NILFS_DIR_REC_LEN(1))
fs/nilfs2/dir.c:				    inode->i_ino);
fs/nilfs2/dir.c:	de->inode = cpu_to_le64(inode->i_ino);
fs/nilfs2/dir.c:	de->inode = cpu_to_le64(inode->i_ino);
fs/nilfs2/dir.c:			nilfs_error(inode->i_sb, __func__,
fs/nilfs2/dir.c:	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
fs/nilfs2/dir.c:	struct address_space *mapping = inode->i_mapping;
fs/nilfs2/dir.c:	de->inode = cpu_to_le64(inode->i_ino);
fs/nilfs2/dir.c:				nilfs_error(inode->i_sb, __func__,
fs/nilfs2/dir.c:					    cpu_to_le64(inode->i_ino))
fs/nilfs2/mdt.c:	memset(kaddr + bh_offset(bh), 0, 1 << inode->i_blkbits);
fs/nilfs2/mdt.c:	struct super_block *sb = inode->i_sb;
fs/nilfs2/mdt.c:	bh = nilfs_grab_buffer(inode, inode->i_mapping, block, 0);
fs/nilfs2/mdt.c:	bh = nilfs_grab_buffer(inode, inode->i_mapping, blkoff, 0);
fs/nilfs2/mdt.c:	map_bh(bh, inode->i_sb, (sector_t)blknum);
fs/nilfs2/mdt.c:		(PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/nilfs2/mdt.c:	page = find_lock_page(inode->i_mapping, index);
fs/nilfs2/mdt.c:		(PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/nilfs2/mdt.c:	    invalidate_inode_pages2_range(inode->i_mapping, index, index) != 0)
fs/nilfs2/mdt.c:	sb = inode->i_sb;
fs/nilfs2/mdt.c:		nilfs_flush_segment(sb, inode->i_ino);
fs/nilfs2/mdt.c:	inode->i_private = mi;
fs/nilfs2/mdt.c:	inode->i_mode = S_IFREG;
fs/nilfs2/mdt.c:	mapping_set_gfp_mask(inode->i_mapping, gfp_mask);
fs/nilfs2/mdt.c:	inode->i_mapping->backing_dev_info = inode->i_sb->s_bdi;
fs/nilfs2/mdt.c:	inode->i_op = &def_mdt_iops;
fs/nilfs2/mdt.c:	inode->i_fop = &def_mdt_fops;
fs/nilfs2/mdt.c:	inode->i_mapping->a_ops = &def_mdt_aops;
fs/nilfs2/mdt.c:	mi->mi_entries_per_block = (1 << inode->i_blkbits) / entry_size;
fs/nilfs2/mdt.c:	struct backing_dev_info *bdi = inode->i_sb->s_bdi;
fs/nilfs2/mdt.c:	ret = nilfs_copy_dirty_pages(&shadow->frozen_data, inode->i_mapping);
fs/nilfs2/mdt.c:	int blkbits = inode->i_blkbits;
fs/nilfs2/mdt.c:			n = bh_offset(bh) >> inode->i_blkbits;
fs/nilfs2/mdt.c:	nilfs_clear_dirty_pages(inode->i_mapping);
fs/nilfs2/mdt.c:	nilfs_copy_back_pages(inode->i_mapping, &shadow->frozen_data);
fs/nilfs2/btree.c:	return 1 << btree->b_inode->i_blkbits;
fs/nilfs2/btree.c:			   1 << btree->b_inode->i_blkbits)) {
fs/nilfs2/recovery.c:		pos = rb->blkoff << inode->i_blkbits;
fs/nilfs2/recovery.c:		err = block_write_begin(inode->i_mapping, pos, blocksize,
fs/nilfs2/recovery.c:			loff_t isize = inode->i_size;
fs/nilfs2/recovery.c:				nilfs_write_failed(inode->i_mapping,
fs/nilfs2/recovery.c:		block_write_end(NULL, inode->i_mapping, pos, blocksize,
fs/nilfs2/segment.c:	else if (NILFS_ROOT_METADATA_FILE(inode->i_ino))
fs/nilfs2/segment.c:	finfo->fi_ino = cpu_to_le64(inode->i_ino);
fs/nilfs2/segment.c:	struct address_space *mapping = inode->i_mapping;
fs/nilfs2/segment.c:			create_empty_buffers(page, 1 << inode->i_blkbits, 0);
fs/nilfs2/btnode.c:	memset(bh->b_data, 0, 1 << inode->i_blkbits);
fs/nilfs2/btnode.c:	bh->b_bdev = inode->i_sb->s_bdev;
fs/nilfs2/btnode.c:		if (inode->i_ino != NILFS_DAT_INO) {
fs/nilfs2/btnode.c:			struct the_nilfs *nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/btnode.c:	bh->b_bdev = inode->i_sb->s_bdev;
fs/nilfs2/btnode.c:	if (inode->i_blkbits == PAGE_CACHE_SHIFT) {
fs/nilfs2/file.c:	err = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/nilfs2/file.c:	mutex_lock(&inode->i_mutex);
fs/nilfs2/file.c:			err = nilfs_construct_dsync_segment(inode->i_sb, inode,
fs/nilfs2/file.c:			err = nilfs_construct_segment(inode->i_sb);
fs/nilfs2/file.c:	mutex_unlock(&inode->i_mutex);
fs/nilfs2/file.c:	nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/file.c:		err = blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);
fs/nilfs2/file.c:	if (unlikely(nilfs_near_disk_full(inode->i_sb->s_fs_info)))
fs/nilfs2/file.c:	sb_start_pagefault(inode->i_sb);
fs/nilfs2/file.c:	if (page->mapping != inode->i_mapping ||
fs/nilfs2/file.c:	ret = nilfs_transaction_begin(inode->i_sb, &ti, 1);
fs/nilfs2/file.c:		nilfs_transaction_abort(inode->i_sb);
fs/nilfs2/file.c:	nilfs_set_file_dirty(inode, 1 << (PAGE_SHIFT - inode->i_blkbits));
fs/nilfs2/file.c:	nilfs_transaction_commit(inode->i_sb);
fs/nilfs2/file.c:	sb_end_pagefault(inode->i_sb);
fs/nilfs2/bmap.c:	struct the_nilfs *nilfs = bmap->b_inode->i_sb->s_fs_info;
fs/nilfs2/bmap.c:		nilfs_error(inode->i_sb, fname,
fs/nilfs2/bmap.c:			    "broken bmap (inode number=%lu)\n", inode->i_ino);
fs/nilfs2/bmap.c:					 bmap->b_inode->i_blkbits);
fs/nilfs2/bmap.c:	unsigned long group = bmap->b_inode->i_ino / entries_per_group;
fs/nilfs2/bmap.c:		(bmap->b_inode->i_ino % NILFS_BMAP_GROUP_DIV) *
fs/nilfs2/bmap.c:		memcpy(bmap->b_u.u_data, raw_inode->i_bmap, NILFS_BMAP_SIZE);
fs/nilfs2/bmap.c:	switch (bmap->b_inode->i_ino) {
fs/nilfs2/bmap.c:	memcpy(raw_inode->i_bmap, bmap->b_u.u_data,
fs/nilfs2/bmap.c:	if (bmap->b_inode->i_ino == NILFS_DAT_INO)
fs/nilfs2/ifile.c:	raw_inode->i_flags = 0;
fs/nilfs2/ioctl.c:	flags = nilfs_mask_flags(inode->i_mode, flags);
fs/nilfs2/ioctl.c:	mutex_lock(&inode->i_mutex);
fs/nilfs2/ioctl.c:	ret = nilfs_transaction_begin(inode->i_sb, &ti, 0);
fs/nilfs2/ioctl.c:	inode->i_ctime = CURRENT_TIME;
fs/nilfs2/ioctl.c:	ret = nilfs_transaction_commit(inode->i_sb);
fs/nilfs2/ioctl.c:	mutex_unlock(&inode->i_mutex);
fs/nilfs2/ioctl.c:	return put_user(inode->i_generation, (int __user *)argp);
fs/nilfs2/ioctl.c:	struct the_nilfs *nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/ioctl.c:	nilfs_transaction_begin(inode->i_sb, &ti, 0);
fs/nilfs2/ioctl.c:		nilfs_transaction_abort(inode->i_sb);
fs/nilfs2/ioctl.c:		nilfs_transaction_commit(inode->i_sb); /* never fails */
fs/nilfs2/ioctl.c:	struct the_nilfs *nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/ioctl.c:	nilfs_transaction_begin(inode->i_sb, &ti, 0);
fs/nilfs2/ioctl.c:		nilfs_transaction_abort(inode->i_sb);
fs/nilfs2/ioctl.c:		nilfs_transaction_commit(inode->i_sb); /* never fails */
fs/nilfs2/ioctl.c:	struct the_nilfs *nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/ioctl.c:	struct the_nilfs *nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/ioctl.c:	struct the_nilfs *nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/ioctl.c:	nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/ioctl.c:	ret = nilfs_ioctl_move_blocks(inode->i_sb, &argv[0], kbufs[0]);
fs/nilfs2/ioctl.c:		ret = nilfs_clean_segments(inode->i_sb, argv, kbufs);
fs/nilfs2/ioctl.c:	ret = nilfs_construct_segment(inode->i_sb);
fs/nilfs2/ioctl.c:	nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/ioctl.c:		ret = blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);
fs/nilfs2/ioctl.c:	ret = nilfs_resize_fs(inode->i_sb, newsize);
fs/nilfs2/ioctl.c:	struct the_nilfs *nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/ioctl.c:	if (range[1] > i_size_read(inode->i_sb->s_bdev->bd_inode))
fs/nilfs2/ioctl.c:	struct the_nilfs *nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/the_nilfs.c:	u64 sb2off = NILFS_SB2_OFFSET_BYTES(nilfs->ns_bdev->bd_inode->i_size);
fs/nilfs2/gcinode.c:	bh = nilfs_grab_buffer(inode, inode->i_mapping, blkoff, 0);
fs/nilfs2/gcinode.c:		struct the_nilfs *nilfs = inode->i_sb->s_fs_info;
fs/nilfs2/gcinode.c:		bh->b_bdev = inode->i_sb->s_bdev;
fs/nilfs2/gcinode.c:	inode->i_mode = S_IFREG;
fs/nilfs2/gcinode.c:	mapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);
fs/nilfs2/gcinode.c:	inode->i_mapping->a_ops = &empty_aops;
fs/nilfs2/gcinode.c:	inode->i_mapping->backing_dev_info = inode->i_sb->s_bdi;
fs/nilfs2/namei.c:		inode->i_op = &nilfs_file_inode_operations;
fs/nilfs2/namei.c:		inode->i_fop = &nilfs_file_operations;
fs/nilfs2/namei.c:		inode->i_mapping->a_ops = &nilfs_aops;
fs/nilfs2/namei.c:		init_special_inode(inode, inode->i_mode, rdev);
fs/nilfs2/namei.c:	inode->i_op = &nilfs_symlink_inode_operations;
fs/nilfs2/namei.c:	inode->i_mapping->a_ops = &nilfs_aops;
fs/nilfs2/namei.c:	inode->i_ctime = CURRENT_TIME;
fs/nilfs2/namei.c:	inode->i_op = &nilfs_dir_inode_operations;
fs/nilfs2/namei.c:	inode->i_fop = &nilfs_dir_operations;
fs/nilfs2/namei.c:	inode->i_mapping->a_ops = &nilfs_aops;
fs/nilfs2/namei.c:	if (le64_to_cpu(de->inode) != inode->i_ino)
fs/nilfs2/namei.c:	if (!inode->i_nlink) {
fs/nilfs2/namei.c:		nilfs_warning(inode->i_sb, __func__,
fs/nilfs2/namei.c:			      inode->i_ino, inode->i_nlink);
fs/nilfs2/namei.c:	inode->i_ctime = dir->i_ctime;
fs/nilfs2/namei.c:			inode->i_size = 0;
fs/nilfs2/namei.c:	if (S_ISDIR(old_inode->i_mode)) {
fs/nilfs2/namei.c:		new_inode->i_ctime = CURRENT_TIME;
fs/nilfs2/namei.c:	old_inode->i_ctime = CURRENT_TIME;
fs/nilfs2/namei.c:	inode = nilfs_iget(child->d_inode->i_sb, root, ino);
fs/nilfs2/namei.c:	if (gen && inode->i_generation != gen) {
fs/nilfs2/namei.c:	fid->ino = inode->i_ino;
fs/nilfs2/namei.c:	fid->gen = inode->i_generation;
fs/freevxfs/vxfs_inode.c:	kmem_cache_free(vxfs_inode_cachep, inode->i_private);
fs/freevxfs/vxfs_lookup.c:	return (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
fs/ocfs2/mmap.c:	struct address_space *mapping = inode->i_mapping;
fs/ocfs2/mmap.c:	if ((page->mapping != inode->i_mapping) ||
fs/ocfs2/mmap.c:	sb_start_pagefault(inode->i_sb);
fs/ocfs2/mmap.c:	sb_end_pagefault(inode->i_sb);
fs/ocfs2/inode.c:	inode->i_flags &= ~(S_IMMUTABLE |
fs/ocfs2/inode.c:		inode->i_flags |= S_IMMUTABLE;
fs/ocfs2/inode.c:		inode->i_flags |= S_SYNC;
fs/ocfs2/inode.c:		inode->i_flags |= S_APPEND;
fs/ocfs2/inode.c:		inode->i_flags |= S_NOATIME;
fs/ocfs2/inode.c:		inode->i_flags |= S_DIRSYNC;
fs/ocfs2/inode.c:	trace_ocfs2_iget5_locked(inode->i_state);
fs/ocfs2/inode.c:	if (inode->i_state & I_NEW) {
fs/ocfs2/inode.c:	trace_ocfs2_find_actor(inode, inode->i_ino, opaque, args->fi_blkno);
fs/ocfs2/inode.c:	inode->i_ino = args->fi_ino;
fs/ocfs2/inode.c:		lockdep_set_class(&inode->i_mutex,
fs/ocfs2/inode.c:	sb = inode->i_sb;
fs/ocfs2/inode.c:	inode->i_version = 1;
fs/ocfs2/inode.c:	inode->i_generation = le32_to_cpu(fe->i_generation);
fs/ocfs2/inode.c:	inode->i_rdev = huge_decode_dev(le64_to_cpu(fe->id1.dev1.i_rdev));
fs/ocfs2/inode.c:	inode->i_mode = le16_to_cpu(fe->i_mode);
fs/ocfs2/inode.c:	inode->i_uid = le32_to_cpu(fe->i_uid);
fs/ocfs2/inode.c:	inode->i_gid = le32_to_cpu(fe->i_gid);
fs/ocfs2/inode.c:	if (S_ISLNK(inode->i_mode) && !fe->i_clusters) {
fs/ocfs2/inode.c:		inode->i_blocks = 0;
fs/ocfs2/inode.c:		inode->i_mapping->a_ops = &ocfs2_fast_symlink_aops;
fs/ocfs2/inode.c:		inode->i_blocks = ocfs2_inode_sector_count(inode);
fs/ocfs2/inode.c:		inode->i_mapping->a_ops = &ocfs2_aops;
fs/ocfs2/inode.c:	inode->i_atime.tv_sec = le64_to_cpu(fe->i_atime);
fs/ocfs2/inode.c:	inode->i_atime.tv_nsec = le32_to_cpu(fe->i_atime_nsec);
fs/ocfs2/inode.c:	inode->i_mtime.tv_sec = le64_to_cpu(fe->i_mtime);
fs/ocfs2/inode.c:	inode->i_mtime.tv_nsec = le32_to_cpu(fe->i_mtime_nsec);
fs/ocfs2/inode.c:	inode->i_ctime.tv_sec = le64_to_cpu(fe->i_ctime);
fs/ocfs2/inode.c:	inode->i_ctime.tv_nsec = le32_to_cpu(fe->i_ctime_nsec);
fs/ocfs2/inode.c:		inode->i_flags |= S_NOQUOTA;
fs/ocfs2/inode.c:		inode->i_flags |= S_NOQUOTA;
fs/ocfs2/inode.c:	switch (inode->i_mode & S_IFMT) {
fs/ocfs2/inode.c:			    inode->i_fop = &ocfs2_fops;
fs/ocfs2/inode.c:			    inode->i_fop = &ocfs2_fops_no_plocks;
fs/ocfs2/inode.c:		    inode->i_op = &ocfs2_file_iops;
fs/ocfs2/inode.c:		    inode->i_op = &ocfs2_dir_iops;
fs/ocfs2/inode.c:			    inode->i_fop = &ocfs2_dops;
fs/ocfs2/inode.c:			    inode->i_fop = &ocfs2_dops_no_plocks;
fs/ocfs2/inode.c:		    inode->i_op = &ocfs2_symlink_inode_operations;
fs/ocfs2/inode.c:		    inode->i_op = &ocfs2_special_file_iops;
fs/ocfs2/inode.c:		    init_special_inode(inode, inode->i_mode,
fs/ocfs2/inode.c:				       inode->i_rdev);
fs/ocfs2/inode.c:		inode->i_ino = ino_from_blkno(inode->i_sb,
fs/ocfs2/inode.c:				  OCFS2_LOCK_TYPE_RW, inode->i_generation,
fs/ocfs2/inode.c:	if (S_ISDIR(inode->i_mode))
fs/ocfs2/inode.c:	if (inode == NULL || inode->i_sb == NULL) {
fs/ocfs2/inode.c:	sb = inode->i_sb;
fs/ocfs2/inode.c:		inode->i_rdev = huge_decode_dev(le64_to_cpu(fe->id1.dev1.i_rdev));
fs/ocfs2/inode.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/inode.c:	mutex_lock(&inode_alloc_inode->i_mutex);
fs/ocfs2/inode.c:		mutex_unlock(&inode_alloc_inode->i_mutex);
fs/ocfs2/inode.c:				   ocfs2_quota_trans_credits(inode->i_sb));
fs/ocfs2/inode.c:	mutex_unlock(&inode_alloc_inode->i_mutex);
fs/ocfs2/inode.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/inode.c:		mutex_lock(&orphan_dir_inode->i_mutex);
fs/ocfs2/inode.c:			mutex_unlock(&orphan_dir_inode->i_mutex);
fs/ocfs2/inode.c:	if (S_ISDIR(inode->i_mode)) {
fs/ocfs2/inode.c:	mutex_unlock(&orphan_dir_inode->i_mutex);
fs/ocfs2/inode.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/inode.c:					   inode->i_nlink);
fs/ocfs2/inode.c:	if (inode->i_nlink)
fs/ocfs2/inode.c:		filemap_write_and_wait(inode->i_mapping);
fs/ocfs2/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/ocfs2/inode.c:	trace_ocfs2_delete_inode(inode->i_ino,
fs/ocfs2/inode.c:	status = ocfs2_nfs_sync_lock(OCFS2_SB(inode->i_sb), 0);
fs/ocfs2/inode.c:	ocfs2_nfs_sync_unlock(OCFS2_SB(inode->i_sb), 0);
fs/ocfs2/inode.c:				inode->i_nlink);
fs/ocfs2/inode.c:	mlog_bug_on_msg(OCFS2_SB(inode->i_sb) == NULL,
fs/ocfs2/inode.c:			"Inode=%lu\n", inode->i_ino);
fs/ocfs2/inode.c:	ocfs2_resv_discard(&OCFS2_SB(inode->i_sb)->osb_la_resmap,
fs/ocfs2/inode.c:	jbd2_journal_release_jbd_inode(OCFS2_SB(inode->i_sb)->journal->j_journal,
fs/ocfs2/inode.c:	if (!inode->i_nlink ||
fs/ocfs2/inode.c:		truncate_inode_pages(&inode->i_data, 0);
fs/ocfs2/inode.c:				inode->i_nlink, oi->ip_flags);
fs/ocfs2/inode.c:	ocfs2_set_links_count(fe, inode->i_nlink);
fs/ocfs2/inode.c:	fe->i_uid = cpu_to_le32(inode->i_uid);
fs/ocfs2/inode.c:	fe->i_gid = cpu_to_le32(inode->i_gid);
fs/ocfs2/inode.c:	fe->i_mode = cpu_to_le16(inode->i_mode);
fs/ocfs2/inode.c:	fe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);
fs/ocfs2/inode.c:	fe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);
fs/ocfs2/inode.c:	fe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);
fs/ocfs2/inode.c:	fe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);
fs/ocfs2/inode.c:	fe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);
fs/ocfs2/inode.c:	fe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);
fs/ocfs2/inode.c:	inode->i_uid = le32_to_cpu(fe->i_uid);
fs/ocfs2/inode.c:	inode->i_gid = le32_to_cpu(fe->i_gid);
fs/ocfs2/inode.c:	inode->i_mode = le16_to_cpu(fe->i_mode);
fs/ocfs2/inode.c:	if (S_ISLNK(inode->i_mode) && le32_to_cpu(fe->i_clusters) == 0)
fs/ocfs2/inode.c:		inode->i_blocks = 0;
fs/ocfs2/inode.c:		inode->i_blocks = ocfs2_inode_sector_count(inode);
fs/ocfs2/inode.c:	inode->i_atime.tv_sec = le64_to_cpu(fe->i_atime);
fs/ocfs2/inode.c:	inode->i_atime.tv_nsec = le32_to_cpu(fe->i_atime_nsec);
fs/ocfs2/inode.c:	inode->i_mtime.tv_sec = le64_to_cpu(fe->i_mtime);
fs/ocfs2/inode.c:	inode->i_mtime.tv_nsec = le32_to_cpu(fe->i_mtime_nsec);
fs/ocfs2/inode.c:	inode->i_ctime.tv_sec = le64_to_cpu(fe->i_ctime);
fs/ocfs2/inode.c:	inode->i_ctime.tv_nsec = le32_to_cpu(fe->i_ctime_nsec);
fs/ocfs2/suballoc.c:		mutex_unlock(&inode->i_mutex);
fs/ocfs2/suballoc.c:	rc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);
fs/ocfs2/suballoc.c:	struct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);
fs/ocfs2/suballoc.c:	struct super_block * sb = alloc_inode->i_sb;
fs/ocfs2/suballoc.c:		ocfs2_error(alloc_inode->i_sb, "group block (%llu) != "
fs/ocfs2/suballoc.c:	struct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);
fs/ocfs2/suballoc.c:	struct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);
fs/ocfs2/suballoc.c:	fe->i_size = cpu_to_le64(ocfs2_clusters_to_bytes(alloc_inode->i_sb,
fs/ocfs2/suballoc.c:	alloc_inode->i_blocks = ocfs2_inode_sector_count(alloc_inode);
fs/ocfs2/suballoc.c:	mutex_lock(&alloc_inode->i_mutex);
fs/ocfs2/suballoc.c:		mutex_unlock(&alloc_inode->i_mutex);
fs/ocfs2/suballoc.c:		ocfs2_error(alloc_inode->i_sb, "Invalid chain allocator %llu",
fs/ocfs2/suballoc.c:		ocfs2_error(alloc_inode->i_sb, "Group descriptor # %llu has bit"
fs/ocfs2/suballoc.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/suballoc.c:		gd_cluster_off = ocfs2_blocks_to_clusters(inode->i_sb,
fs/ocfs2/suballoc.c:		ret = ocfs2_block_group_find_clear_bits(OCFS2_SB(inode->i_sb),
fs/ocfs2/suballoc.c:			blkoff = ocfs2_clusters_to_blocks(inode->i_sb,
fs/ocfs2/suballoc.c:		ret = ocfs2_block_group_find_clear_bits(OCFS2_SB(inode->i_sb),
fs/ocfs2/suballoc.c:	if (!ocfs2_supports_discontig_bg(OCFS2_SB(ac->ac_inode->i_sb)) ||
fs/ocfs2/suballoc.c:		ocfs2_error(ac->ac_inode->i_sb,
fs/ocfs2/suballoc.c:	atomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);
fs/ocfs2/suballoc.c:	atomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);
fs/ocfs2/suballoc.c:	atomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);
fs/ocfs2/suballoc.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/suballoc.c:		cluster = ocfs2_blocks_to_clusters(inode->i_sb, bg_blkno);
fs/ocfs2/suballoc.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/suballoc.c:	return ocfs2_clusters_to_blocks(inode->i_sb,
fs/ocfs2/suballoc.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/suballoc.c:	struct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);
fs/ocfs2/suballoc.c:		ocfs2_error(alloc_inode->i_sb, "Group descriptor # %llu has bit"
fs/ocfs2/suballoc.c:	BUG_ON(start_blk != ocfs2_clusters_to_blocks(bitmap_inode->i_sb, ocfs2_blocks_to_clusters(bitmap_inode->i_sb, start_blk)));
fs/ocfs2/suballoc.c:	ocfs2_local_alloc_seen_free_bits(OCFS2_SB(bitmap_inode->i_sb),
fs/ocfs2/suballoc.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/suballoc.c:	mutex_lock(&inode_alloc_inode->i_mutex);
fs/ocfs2/suballoc.c:		mutex_unlock(&inode_alloc_inode->i_mutex);
fs/ocfs2/suballoc.c:	mutex_unlock(&inode_alloc_inode->i_mutex);
fs/ocfs2/alloc.c:	if (!ocfs2_writes_unwritten_extents(OCFS2_SB(inode->i_sb))) {
fs/ocfs2/alloc.c:		ocfs2_error(inode->i_sb, "Inode %llu has unwritten extents "
fs/ocfs2/alloc.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/alloc.c:	u64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);
fs/ocfs2/alloc.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/alloc.c:	mutex_lock(&tl_inode->i_mutex);
fs/ocfs2/alloc.c:				  ocfs2_clusters_to_bytes(inode->i_sb, len));
fs/ocfs2/alloc.c:	mutex_unlock(&tl_inode->i_mutex);
fs/ocfs2/alloc.c:	BUG_ON(mutex_trylock(&tl_inode->i_mutex));
fs/ocfs2/alloc.c:		start_blk = ocfs2_clusters_to_blocks(data_alloc_inode->i_sb,
fs/ocfs2/alloc.c:/* Expects you to already be holding tl_inode->i_mutex */
fs/ocfs2/alloc.c:	BUG_ON(mutex_trylock(&tl_inode->i_mutex));
fs/ocfs2/alloc.c:	mutex_lock(&data_alloc_inode->i_mutex);
fs/ocfs2/alloc.c:	mutex_unlock(&data_alloc_inode->i_mutex);
fs/ocfs2/alloc.c:	mutex_lock(&tl_inode->i_mutex);
fs/ocfs2/alloc.c:	mutex_unlock(&tl_inode->i_mutex);
fs/ocfs2/alloc.c:	mutex_lock(&tl_inode->i_mutex);
fs/ocfs2/alloc.c:	mutex_unlock(&tl_inode->i_mutex);
fs/ocfs2/alloc.c:	mutex_lock(&inode->i_mutex);
fs/ocfs2/alloc.c:	mutex_unlock(&inode->i_mutex);
fs/ocfs2/alloc.c:	mutex_lock(&tl_inode->i_mutex);
fs/ocfs2/alloc.c:	mutex_unlock(&tl_inode->i_mutex);
fs/ocfs2/alloc.c:	struct super_block *sb = inode->i_sb;
fs/ocfs2/alloc.c:	struct address_space *mapping = inode->i_mapping;
fs/ocfs2/alloc.c:	struct super_block *sb = inode->i_sb;
fs/ocfs2/alloc.c:	struct super_block *sb = inode->i_sb;
fs/ocfs2/alloc.c:	ret = filemap_fdatawrite_range(inode->i_mapping, range_start,
fs/ocfs2/alloc.c:	unsigned int blocksize = 1 << inode->i_sb->s_blocksize_bits;
fs/ocfs2/alloc.c:		ocfs2_extent_recs_per_inode_with_xattr(inode->i_sb, di));
fs/ocfs2/alloc.c:			ocfs2_max_inline_data_with_xattr(inode->i_sb, di));
fs/ocfs2/alloc.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/alloc.c:		block = phys = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);
fs/ocfs2/alloc.c:		inode->i_blocks = ocfs2_inode_sector_count(inode);
fs/ocfs2/alloc.c: * inode->i_size and fe->i_size have been adjusted.
fs/ocfs2/alloc.c:		ocfs2_error(inode->i_sb,
fs/ocfs2/alloc.c:			ocfs2_error(inode->i_sb, "Inode %lu has an empty "
fs/ocfs2/alloc.c:				    "extent record, depth %u\n", inode->i_ino,
fs/ocfs2/alloc.c:				ocfs2_clusters_to_blocks(inode->i_sb, coff);
fs/ocfs2/alloc.c:	phys_cpos = ocfs2_blocks_to_clusters(inode->i_sb, blkno);
fs/ocfs2/alloc.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/alloc.c:		ocfs2_error(inode->i_sb,
fs/ocfs2/alloc.c:	inode->i_blocks = ocfs2_inode_sector_count(inode);
fs/ocfs2/alloc.c:	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
fs/ocfs2/alloc.c:	di->i_ctime = di->i_mtime = cpu_to_le64(inode->i_ctime.tv_sec);
fs/ocfs2/alloc.c:	di->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);
fs/ocfs2/alloc.c:	mutex_lock(&main_bm_inode->i_mutex);
fs/ocfs2/alloc.c:	mutex_unlock(&main_bm_inode->i_mutex);
fs/ocfs2/journal.h:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/journal.h:				OCFS2_SB(inode->i_sb)->journal->j_journal,
fs/ocfs2/ocfs2.h:	 * It must be protected by osb_tl_inode->i_mutex.
fs/ocfs2/ocfs2.h:	if (!S_ISREG(inode->i_mode))
fs/ocfs2/ocfs2.h:	if (OCFS2_SB(inode->i_sb)->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)
fs/ocfs2/super.c:	struct ocfs2_super *osb = inode->i_private;
fs/ocfs2/super.c:	call_rcu(&inode->i_rcu, ocfs2_i_callback);
fs/ocfs2/slot_map.c:	blocks = ocfs2_blocks_for_bytes(si->si_inode->i_sb, bytes);
fs/ocfs2/inode.h:	int c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;
fs/ocfs2/dcache.c:	if (inode->i_nlink == 0) {
fs/ocfs2/dcache.c:			S_ISDIR(inode->i_mode));
fs/ocfs2/dcache.c:	spin_lock(&inode->i_lock);
fs/ocfs2/dcache.c:	hlist_for_each_entry(dentry, p, &inode->i_dentry, d_alias) {
fs/ocfs2/dcache.c:			spin_unlock(&inode->i_lock);
fs/ocfs2/dcache.c:	spin_unlock(&inode->i_lock);
fs/ocfs2/aops.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/aops.c:	if ((iblock << inode->i_sb->s_blocksize_bits) > PATH_MAX + 1) {
fs/ocfs2/aops.c:	if ((u64)iblock >= ocfs2_clusters_to_blocks(inode->i_sb,
fs/ocfs2/aops.c:	map_bh(bh_result, inode->i_sb,
fs/ocfs2/aops.c:	u64 max_blocks = bh_result->b_size >> inode->i_blkbits;
fs/ocfs2/aops.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/aops.c:		     inode, inode->i_ino);
fs/ocfs2/aops.c:	if (S_ISLNK(inode->i_mode)) {
fs/ocfs2/aops.c:		map_bh(bh_result, inode->i_sb, p_blkno);
fs/ocfs2/aops.c:	bh_result->b_size = count << inode->i_blkbits;
fs/ocfs2/aops.c:	past_eof = ocfs2_blocks_for_bytes(inode->i_sb, i_size_read(inode));
fs/ocfs2/aops.c:		ocfs2_error(inode->i_sb, "Inode %llu lost inline data flag",
fs/ocfs2/aops.c:	    size > ocfs2_max_inline_data_with_xattr(inode->i_sb, di)) {
fs/ocfs2/aops.c:		ocfs2_error(inode->i_sb,
fs/ocfs2/aops.c:	unsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;
fs/ocfs2/aops.c:	unsigned long max_blocks = bh_result->b_size >> inode->i_blkbits;
fs/ocfs2/aops.c:	inode_blocks = ocfs2_blocks_for_bytes(inode->i_sb, i_size_read(inode));
fs/ocfs2/aops.c:		map_bh(bh_result, inode->i_sb, p_blkno);
fs/ocfs2/aops.c:	struct inode *inode = file->f_path.dentry->d_inode->i_mapping->host;
fs/ocfs2/aops.c:	return __blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev,
fs/ocfs2/aops.c:	if (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))
fs/ocfs2/aops.c:	unsigned int bsize = 1 << inode->i_blkbits;
fs/ocfs2/aops.c:			map_bh(bh, inode->i_sb, *p_blkno);
fs/ocfs2/aops.c:	ocfs2_figure_cluster_boundaries(OCFS2_SB(inode->i_sb), cpos,
fs/ocfs2/aops.c:		ocfs2_clear_page_regions(page, OCFS2_SB(inode->i_sb),
fs/ocfs2/aops.c:		wc->w_num_pages = ocfs2_pages_per_cluster(inode->i_sb);
fs/ocfs2/aops.c:		start = ocfs2_align_clusters_to_page_index(inode->i_sb, cpos);
fs/ocfs2/aops.c:		ret = ocfs2_add_inode_data(OCFS2_SB(inode->i_sb), inode,
fs/ocfs2/aops.c:		v_blkno = ocfs2_clusters_to_blocks(inode->i_sb, cpos);
fs/ocfs2/aops.c:		v_blkno = user_pos >> inode->i_sb->s_blocksize_bits;
fs/ocfs2/aops.c:		ocfs2_error(inode->i_sb, "Corrupting extend for inode %llu, "
fs/ocfs2/aops.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/aops.c:	    end > ocfs2_max_inline_data_with_xattr(inode->i_sb, di))
fs/ocfs2/aops.c:	BUG_ON(ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)));
fs/ocfs2/aops.c:		ocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode));
fs/ocfs2/aops.c:	BUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)));
fs/ocfs2/aops.c:	mutex_lock(&osb->osb_tl_inode->i_mutex);
fs/ocfs2/aops.c:	mutex_unlock(&osb->osb_tl_inode->i_mutex);
fs/ocfs2/aops.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/aops.c:		credits = ocfs2_calc_extend_credits(inode->i_sb,
fs/ocfs2/aops.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/aops.c:	if (pos > inode->i_size) {
fs/ocfs2/aops.c:	inode->i_blocks = ocfs2_inode_sector_count(inode);
fs/ocfs2/aops.c:	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/ocfs2/aops.c:	di->i_mtime = di->i_ctime = cpu_to_le64(inode->i_mtime.tv_sec);
fs/ocfs2/aops.c:	di->i_mtime_nsec = di->i_ctime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);
fs/ocfs2/move_extents.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/move_extents.c:	u64 old_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cpos);
fs/ocfs2/move_extents.c:	replace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(inode->i_sb,
fs/ocfs2/move_extents.c:		ocfs2_error(inode->i_sb,
fs/ocfs2/move_extents.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/move_extents.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/move_extents.c:	u64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);
fs/ocfs2/move_extents.c:	mutex_lock(&tl_inode->i_mutex);
fs/ocfs2/move_extents.c:	ret = ocfs2_cow_sync_writeback(inode->i_sb, context->inode, cpos, *len);
fs/ocfs2/move_extents.c:	mutex_unlock(&tl_inode->i_mutex);
fs/ocfs2/move_extents.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/move_extents.c:	cl = &(ac_dinode->id2.i_chain);
fs/ocfs2/move_extents.c:					inode->i_sb->s_blocksize_bits;
fs/ocfs2/move_extents.c:	    (vict_blkno >= (le32_to_cpu(ac_dinode->id1.bitmap1.i_total) <<
fs/ocfs2/move_extents.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/move_extents.c:					inode->i_sb->s_blocksize_bits);
fs/ocfs2/move_extents.c:	range->me_goal = ocfs2_block_to_cluster_start(inode->i_sb,
fs/ocfs2/move_extents.c:	u32 base_cpos = ocfs2_blocks_to_clusters(inode->i_sb,
fs/ocfs2/move_extents.c:		ocfs2_error(alloc_inode->i_sb, "Group descriptor # %llu has bit"
fs/ocfs2/move_extents.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/move_extents.c:	u32 move_max_hop = ocfs2_blocks_to_clusters(inode->i_sb,
fs/ocfs2/move_extents.c:	phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);
fs/ocfs2/move_extents.c:	mutex_lock(&gb_inode->i_mutex);
fs/ocfs2/move_extents.c:	mutex_lock(&tl_inode->i_mutex);
fs/ocfs2/move_extents.c:	new_phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, *new_phys_cpos);
fs/ocfs2/move_extents.c:	ret = ocfs2_cow_sync_writeback(inode->i_sb, context->inode, cpos, len);
fs/ocfs2/move_extents.c:	mutex_unlock(&tl_inode->i_mutex);
fs/ocfs2/move_extents.c:	mutex_unlock(&gb_inode->i_mutex);
fs/ocfs2/move_extents.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/move_extents.c:	if ((inode->i_size == 0) || (range->me_len == 0))
fs/ocfs2/move_extents.c:		new_phys_cpos = ocfs2_blocks_to_clusters(inode->i_sb,
fs/ocfs2/move_extents.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/move_extents.c:	mutex_lock(&inode->i_mutex);
fs/ocfs2/move_extents.c:	inode->i_ctime = CURRENT_TIME;
fs/ocfs2/move_extents.c:	di->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);
fs/ocfs2/move_extents.c:	di->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);
fs/ocfs2/move_extents.c:	mutex_unlock(&inode->i_mutex);
fs/ocfs2/move_extents.c:	if ((!S_ISREG(inode->i_mode)) || !(filp->f_mode & FMODE_WRITE))
fs/ocfs2/move_extents.c:	if (inode->i_flags & (S_IMMUTABLE|S_APPEND)) {
fs/ocfs2/suballoc.h:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/dlm/dlmdebug.c:	struct dlm_ctxt *dlm = inode->i_private;
fs/ocfs2/dlm/dlmdebug.c:	struct dlm_ctxt *dlm = inode->i_private;
fs/ocfs2/dlm/dlmdebug.c:	struct dlm_ctxt *dlm = inode->i_private;
fs/ocfs2/dlm/dlmdebug.c:	struct dlm_ctxt *dlm = inode->i_private;
fs/ocfs2/extent_map.c:	ins.ei_phys = ocfs2_blocks_to_clusters(inode->i_sb,
fs/ocfs2/extent_map.c:		ocfs2_error(inode->i_sb,
fs/ocfs2/extent_map.c:			    "leaf block %llu\n", inode->i_ino,
fs/ocfs2/extent_map.c:			ocfs2_error(inode->i_sb,
fs/ocfs2/extent_map.c:				    "leaf block %llu\n", inode->i_ino,
fs/ocfs2/extent_map.c:		ocfs2_error(inode->i_sb, "Inode %lu has bad extent "
fs/ocfs2/extent_map.c:			    "record (%u, %u, 0)", inode->i_ino,
fs/ocfs2/extent_map.c:			ocfs2_error(inode->i_sb,
fs/ocfs2/extent_map.c:				    "xattr leaf block %llu\n", inode->i_ino,
fs/ocfs2/extent_map.c:			ocfs2_error(inode->i_sb, "Inode %lu has bad extent "
fs/ocfs2/extent_map.c:				    "record (%u, %u, 0) in xattr", inode->i_ino,
fs/ocfs2/extent_map.c:		*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,
fs/ocfs2/extent_map.c:		ocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,
fs/ocfs2/extent_map.c:	int bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);
fs/ocfs2/extent_map.c:	cpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);
fs/ocfs2/extent_map.c:		boff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);
fs/ocfs2/extent_map.c:		*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);
fs/ocfs2/extent_map.c:		id_count = ocfs2_fast_symlink_chars(inode->i_sb);
fs/ocfs2/extent_map.c:		phys = oi->ip_blkno << inode->i_sb->s_blocksize_bits;
fs/ocfs2/extent_map.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/extent_map.c:	mapping_end = ocfs2_clusters_for_bytes(inode->i_sb,
fs/ocfs2/extent_map.c:	u16 cs_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits;
fs/ocfs2/extent_map.c:	if (*offset >= inode->i_size) {
fs/ocfs2/extent_map.c:			*offset = inode->i_size;
fs/ocfs2/extent_map.c:	cend = ocfs2_clusters_for_bytes(inode->i_sb, inode->i_size);
fs/ocfs2/extent_map.c:		if ((extoff + extlen) > inode->i_size)
fs/ocfs2/extent_map.c:			extlen = inode->i_size - extoff;
fs/ocfs2/extent_map.c:	if (((v_block + nr - 1) << inode->i_sb->s_blocksize_bits) >=
fs/ocfs2/extent_map.c:			     inode->i_sb->s_blocksize_bits);
fs/ocfs2/resize.c:		blkno = ocfs2_backup_super_blkno(inode->i_sb, i);
fs/ocfs2/resize.c:		cluster = ocfs2_blocks_to_clusters(inode->i_sb, blkno);
fs/ocfs2/resize.c:	struct ocfs2_super *osb = OCFS2_SB(bm_inode->i_sb);
fs/ocfs2/resize.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/resize.c:		blkno = ocfs2_backup_super_blkno(inode->i_sb, i);
fs/ocfs2/resize.c:		cluster = ocfs2_blocks_to_clusters(inode->i_sb, blkno);
fs/ocfs2/resize.c:		memcpy(backup->b_data, data, inode->i_sb->s_blocksize);
fs/ocfs2/resize.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/resize.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/resize.c:	mutex_lock(&main_bm_inode->i_mutex);
fs/ocfs2/resize.c:	mutex_unlock(&main_bm_inode->i_mutex);
fs/ocfs2/resize.c:	ret = ocfs2_check_group_descriptor(inode->i_sb, di, group_bh);
fs/ocfs2/resize.c:	u32 cluster = ocfs2_blocks_to_clusters(inode->i_sb, input->group);
fs/ocfs2/resize.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/resize.c:	mutex_lock(&main_bm_inode->i_mutex);
fs/ocfs2/resize.c:	mutex_unlock(&main_bm_inode->i_mutex);
fs/ocfs2/dir.c:	trailer = ocfs2_trailer_from_bh(bh, inode->i_sb);
fs/ocfs2/dir.c:			ocfs2_error(inode->i_sb,
fs/ocfs2/dir.c:				    "btree tree block %llu\n", inode->i_ino,
fs/ocfs2/dir.c:		ocfs2_error(inode->i_sb, "Inode %lu has bad extent "
fs/ocfs2/dir.c:			    "record (%u, %u, 0) in btree", inode->i_ino,
fs/ocfs2/dir.c:		blkno += ocfs2_clusters_to_blocks(inode->i_sb, clen - 1);
fs/ocfs2/dir.c:		blkno += ocfs2_clusters_to_blocks(inode->i_sb,
fs/ocfs2/dir.c:	blkno += ocfs2_dx_dir_hash_idx(OCFS2_SB(inode->i_sb), hinfo);
fs/ocfs2/dir.c:	ocfs2_set_de_type(de, new_entry_inode->i_mode);
fs/ocfs2/dir.c:				ocfs2_set_de_type(de, inode->i_mode);
fs/ocfs2/dir.c:		if (*f_version != inode->i_version) {
fs/ocfs2/dir.c:			*f_version = inode->i_version;
fs/ocfs2/dir.c:	struct super_block * sb = inode->i_sb;
fs/ocfs2/dir.c:		if (*f_version != inode->i_version) {
fs/ocfs2/dir.c:			*f_version = inode->i_version;
fs/ocfs2/dir.c:	u64 version = inode->i_version;
fs/ocfs2/dir.c:	inode->i_blocks = ocfs2_inode_sector_count(inode);
fs/ocfs2/dir.c:	i_size_write(inode, inode->i_sb->s_blocksize);
fs/ocfs2/dir.c:	inode->i_blocks = ocfs2_inode_sector_count(inode);
fs/ocfs2/dir.c:	mutex_lock(&dx_alloc_inode->i_mutex);
fs/ocfs2/dir.c:	mutex_unlock(&dx_alloc_inode->i_mutex);
fs/ocfs2/symlink.h:	return (S_ISLNK(inode->i_mode) &&
fs/ocfs2/symlink.h:		inode->i_blocks == 0);
fs/ocfs2/quota_global.c:	if (gqinode->i_size < off + len) {
fs/ocfs2/quota_global.c:	gqinode->i_version++;
fs/ocfs2/quota_global.c:		mutex_lock(&oinfo->dqi_gqinode->i_mutex);
fs/ocfs2/quota_global.c:		mutex_unlock(&oinfo->dqi_gqinode->i_mutex);
fs/ocfs2/quota_global.c:	struct super_block *sb = oinfo->dqi_gqinode->i_sb;
fs/ocfs2/quota_global.c:			gqinode->i_size + (need_alloc << sb->s_blocksize_bits),
fs/ocfs2/quota_global.c:			gqinode->i_size);
fs/ocfs2/symlink.c:	len = strnlen(link, ocfs2_fast_symlink_chars(inode->i_sb));
fs/ocfs2/dlmfs/dlmfs.c:	if (S_ISDIR(inode->i_mode))
fs/ocfs2/dlmfs/dlmfs.c:	mlog(0, "open called on inode %lu, flags 0x%x\n", inode->i_ino,
fs/ocfs2/dlmfs/dlmfs.c:	if (S_ISDIR(inode->i_mode))
fs/ocfs2/dlmfs/dlmfs.c:	mlog(0, "close called on inode %lu\n", inode->i_ino);
fs/ocfs2/dlmfs/dlmfs.c:		inode->i_ino, count, *ppos);
fs/ocfs2/dlmfs/dlmfs.c:		inode->i_ino, count, *ppos);
fs/ocfs2/dlmfs/dlmfs.c:	call_rcu(&inode->i_rcu, dlmfs_i_callback);
fs/ocfs2/dlmfs/dlmfs.c:	mlog(0, "inode %lu\n", inode->i_ino);
fs/ocfs2/dlmfs/dlmfs.c:	if (S_ISREG(inode->i_mode)) {
fs/ocfs2/dlmfs/dlmfs.c:		inode->i_ino = get_next_ino();
fs/ocfs2/dlmfs/dlmfs.c:		inode->i_mapping->backing_dev_info = &dlmfs_backing_dev_info;
fs/ocfs2/dlmfs/dlmfs.c:		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/ocfs2/dlmfs/dlmfs.c:		inode->i_fop = &simple_dir_operations;
fs/ocfs2/dlmfs/dlmfs.c:		inode->i_op = &dlmfs_root_inode_operations;
fs/ocfs2/dlmfs/dlmfs.c:	inode->i_ino = get_next_ino();
fs/ocfs2/dlmfs/dlmfs.c:	inode->i_mapping->backing_dev_info = &dlmfs_backing_dev_info;
fs/ocfs2/dlmfs/dlmfs.c:	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/ocfs2/dlmfs/dlmfs.c:		inode->i_op = &dlmfs_file_inode_operations;
fs/ocfs2/dlmfs/dlmfs.c:		inode->i_fop = &dlmfs_file_operations;
fs/ocfs2/dlmfs/dlmfs.c:		inode->i_op = &dlmfs_dir_inode_operations;
fs/ocfs2/dlmfs/dlmfs.c:		inode->i_fop = &simple_dir_operations;
fs/ocfs2/dlmfs/dlmfs.c:	mlog(0, "unlink inode %lu\n", inode->i_ino);
fs/ocfs2/quota_local.c:	struct super_block *sb = inode->i_sb;
fs/ocfs2/quota_local.c:	if (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {
fs/ocfs2/quota_local.c:		ocfs2_error(inode->i_sb,
fs/ocfs2/quota_local.c:				ol_quota_chunk_block(inode->i_sb, i),
fs/ocfs2/quota_local.c:	struct super_block *sb = lqinode->i_sb;
fs/ocfs2/quota_local.c:	struct super_block *sb = lqinode->i_sb;
fs/ocfs2/quota_local.c:	trace_ocfs2_recover_local_quota_file((unsigned long)lqinode->i_ino, type);
fs/ocfs2/quota_local.c:				       lqinode->i_size + 2 * sb->s_blocksize,
fs/ocfs2/quota_local.c:				       lqinode->i_size);
fs/ocfs2/quota_local.c:					  lqinode->i_size + 2 * sb->s_blocksize);
fs/ocfs2/quota_local.c:				       lqinode->i_size + sb->s_blocksize,
fs/ocfs2/quota_local.c:				       lqinode->i_size);
fs/ocfs2/quota_local.c:					  lqinode->i_size + sb->s_blocksize);
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:	err = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/ocfs2/file.c:	mutex_lock(&inode->i_mutex);
fs/ocfs2/file.c:	if (datasync && !(inode->i_state & I_DIRTY_DATASYNC)) {
fs/ocfs2/file.c:			blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);
fs/ocfs2/file.c:	mutex_unlock(&inode->i_mutex);
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:	if ((inode->i_flags & S_NOATIME) ||
fs/ocfs2/file.c:	    ((inode->i_sb->s_flags & MS_NODIRATIME) && S_ISDIR(inode->i_mode)))
fs/ocfs2/file.c:	    ((vfsmnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode)))
fs/ocfs2/file.c:		if ((timespec_compare(&inode->i_atime, &inode->i_mtime) <= 0) ||
fs/ocfs2/file.c:		    (timespec_compare(&inode->i_atime, &inode->i_ctime) <= 0))
fs/ocfs2/file.c:	if ((now.tv_sec - inode->i_atime.tv_sec <= osb->s_atime_quantum))
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:	inode->i_atime = CURRENT_TIME;
fs/ocfs2/file.c:	di->i_atime = cpu_to_le64(inode->i_atime.tv_sec);
fs/ocfs2/file.c:	di->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);
fs/ocfs2/file.c:	ocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);
fs/ocfs2/file.c:	inode->i_blocks = ocfs2_inode_sector_count(inode);
fs/ocfs2/file.c:	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:	u32 phys, cpos = offset >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;
fs/ocfs2/file.c:	if ((offset & (OCFS2_SB(inode->i_sb)->s_clustersize - 1)) == 0)
fs/ocfs2/file.c:	cluster_bytes = ocfs2_align_bytes_to_clusters(inode->i_sb, new_i_size);
fs/ocfs2/file.c:	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
fs/ocfs2/file.c:	di->i_ctime = di->i_mtime = cpu_to_le64(inode->i_ctime.tv_sec);
fs/ocfs2/file.c:	di->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:	unmap_mapping_range(inode->i_mapping, new_i_size + PAGE_SIZE - 1, 0, 1);
fs/ocfs2/file.c:	truncate_inode_pages(inode->i_mapping, new_i_size);
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:	struct address_space *mapping = inode->i_mapping;
fs/ocfs2/file.c:	BUG_ON(abs_from & (inode->i_blkbits - 1));
fs/ocfs2/file.c:		block_end = block_start + (1 << inode->i_blkbits);
fs/ocfs2/file.c:		ocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);
fs/ocfs2/file.c:		zero_start >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;
fs/ocfs2/file.c:	u32 last_cpos = ocfs2_clusters_for_bytes(inode->i_sb, zero_end);
fs/ocfs2/file.c:	*range_start = ocfs2_clusters_to_bytes(inode->i_sb, zero_cpos);
fs/ocfs2/file.c:	*range_end = ocfs2_clusters_to_bytes(inode->i_sb,
fs/ocfs2/file.c:	struct super_block *sb = inode->i_sb;
fs/ocfs2/file.c:	clusters_to_add = ocfs2_clusters_for_bytes(inode->i_sb, new_i_size);
fs/ocfs2/file.c:	if (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))
fs/ocfs2/file.c:	struct super_block *sb = inode->i_sb;
fs/ocfs2/file.c:	if (S_ISLNK(inode->i_mode))
fs/ocfs2/file.c:	size_change = S_ISREG(inode->i_mode) && attr->ia_valid & ATTR_SIZE;
fs/ocfs2/file.c:	if ((attr->ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
fs/ocfs2/file.c:	    (attr->ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid)) {
fs/ocfs2/file.c:		if (attr->ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid
fs/ocfs2/file.c:		if (attr->ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid
fs/ocfs2/file.c:	struct super_block *sb = dentry->d_inode->i_sb;
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:			inode->i_mode);
fs/ocfs2/file.c:	inode->i_mode &= ~S_ISUID;
fs/ocfs2/file.c:	if ((inode->i_mode & S_ISGID) && (inode->i_mode & S_IXGRP))
fs/ocfs2/file.c:		inode->i_mode &= ~S_ISGID;
fs/ocfs2/file.c:	di->i_mode = cpu_to_le16(inode->i_mode);
fs/ocfs2/file.c:	struct super_block *sb = inode->i_sb;
fs/ocfs2/file.c:	cpos = start >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;
fs/ocfs2/file.c:	clusters = ocfs2_clusters_for_bytes(inode->i_sb, start + len);
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:	struct address_space *mapping = inode->i_mapping;
fs/ocfs2/file.c:	start = (loff_t)ocfs2_align_bytes_to_clusters(inode->i_sb, byte_start);
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:				ocfs2_clusters_to_blocks(inode->i_sb, coff);
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:	struct address_space *mapping = inode->i_mapping;
fs/ocfs2/file.c:			ret = ocfs2_find_cpos_for_left_leaf(inode->i_sb,
fs/ocfs2/file.c:		phys_cpos = ocfs2_blocks_to_clusters(inode->i_sb, blkno);
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:	unsigned long long max_off = inode->i_sb->s_maxbytes;
fs/ocfs2/file.c:	mutex_lock(&inode->i_mutex);
fs/ocfs2/file.c:	if (inode->i_flags & (S_IMMUTABLE|S_APPEND)) {
fs/ocfs2/file.c:	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
fs/ocfs2/file.c:	mutex_unlock(&inode->i_mutex);
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:	if (!S_ISREG(inode->i_mode))
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:	struct super_block *sb = inode->i_sb;
fs/ocfs2/file.c:	if (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)) ||
fs/ocfs2/file.c:	int blockmask = inode->i_sb->s_blocksize - 1;
fs/ocfs2/file.c:	u32 cpos = pos >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;
fs/ocfs2/file.c:		ocfs2_clusters_for_bytes(inode->i_sb, pos + count) - cpos;
fs/ocfs2/file.c:		 * set inode->i_size at the end of a write. */
fs/ocfs2/file.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/file.c:	sb_start_write(inode->i_sb);
fs/ocfs2/file.c:	mutex_lock(&inode->i_mutex);
fs/ocfs2/file.c:				   S_ISBLK(inode->i_mode));
fs/ocfs2/file.c:	mutex_unlock(&inode->i_mutex);
fs/ocfs2/file.c:	sb_end_write(inode->i_sb);
fs/ocfs2/file.c:		mutex_lock_nested(&pipe->inode->i_mutex, I_MUTEX_PARENT);
fs/ocfs2/file.c:		mutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);
fs/ocfs2/file.c:		mutex_unlock(&inode->i_mutex);
fs/ocfs2/file.c:		mutex_unlock(&pipe->inode->i_mutex);
fs/ocfs2/file.c:	mutex_lock(&inode->i_mutex);
fs/ocfs2/file.c:		offset += inode->i_size;
fs/ocfs2/file.c:	if (!ret && offset > inode->i_sb->s_maxbytes)
fs/ocfs2/file.c:	mutex_unlock(&inode->i_mutex);
fs/ocfs2/refcounttree.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/refcounttree.c:	new_bh = sb_getblk(inode->i_sb, first_blkno);
fs/ocfs2/refcounttree.c:	memset(rb, 0, inode->i_sb->s_blocksize);
fs/ocfs2/refcounttree.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/refcounttree.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/refcounttree.c:		mutex_lock(&alloc_inode->i_mutex);
fs/ocfs2/refcounttree.c:		mutex_unlock(&alloc_inode->i_mutex);
fs/ocfs2/refcounttree.c:	ret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb), ref_blkno, &tree);
fs/ocfs2/refcounttree.c:	if (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {
fs/ocfs2/refcounttree.c:		ocfs2_error(inode->i_sb, "Inode %lu want to use refcount "
fs/ocfs2/refcounttree.c:			    "super block.", inode->i_ino);
fs/ocfs2/refcounttree.c:	u64 start_cpos = ocfs2_blocks_to_clusters(inode->i_sb, phys_blkno);
fs/ocfs2/refcounttree.c:	if (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {
fs/ocfs2/refcounttree.c:		ocfs2_error(inode->i_sb, "Inode %lu want to use refcount "
fs/ocfs2/refcounttree.c:			    "super block.", inode->i_ino);
fs/ocfs2/refcounttree.c:	ret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb),
fs/ocfs2/refcounttree.c:	ret = ocfs2_calc_refcount_meta_credits(inode->i_sb,
fs/ocfs2/refcounttree.c:	int contig_clusters = ocfs2_cow_contig_clusters(inode->i_sb);
fs/ocfs2/refcounttree.c:			ocfs2_error(inode->i_sb,
fs/ocfs2/refcounttree.c:				    "leaf block %llu\n", inode->i_ino,
fs/ocfs2/refcounttree.c:					"index %d\n", inode->i_ino, i);
fs/ocfs2/refcounttree.c:			want_clusters = ocfs2_cow_align_length(inode->i_sb,
fs/ocfs2/refcounttree.c:			*cow_start = ocfs2_cow_align_start(inode->i_sb,
fs/ocfs2/refcounttree.c:			*cow_start = ocfs2_cow_align_start(inode->i_sb,
fs/ocfs2/refcounttree.c:			want_clusters = ocfs2_cow_align_length(inode->i_sb,
fs/ocfs2/refcounttree.c:	struct address_space *mapping = inode->i_mapping;
fs/ocfs2/refcounttree.c:	struct super_block *sb = inode->i_sb;
fs/ocfs2/refcounttree.c:	ret = filemap_fdatawrite_range(inode->i_mapping,
fs/ocfs2/refcounttree.c:		page = find_or_create_page(inode->i_mapping,
fs/ocfs2/refcounttree.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/refcounttree.c:	if (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {
fs/ocfs2/refcounttree.c:		ocfs2_error(inode->i_sb, "Inode %lu want to use refcount "
fs/ocfs2/refcounttree.c:			    "super block.", inode->i_ino);
fs/ocfs2/refcounttree.c:		ret = ocfs2_make_clusters_writable(inode->i_sb, context,
fs/ocfs2/refcounttree.c:	int cs_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits;
fs/ocfs2/refcounttree.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/refcounttree.c:		*credits += ocfs2_calc_extend_credits(inode->i_sb,
fs/ocfs2/refcounttree.c:		ocfs2_clusters_to_blocks(inode->i_sb, 1) * cow_len;
fs/ocfs2/refcounttree.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/refcounttree.c:	ret = ocfs2_calc_refcount_meta_credits(inode->i_sb,
fs/ocfs2/refcounttree.c:		ret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),
fs/ocfs2/refcounttree.c:	handle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),
fs/ocfs2/refcounttree.c:	inode->i_ctime = CURRENT_TIME;
fs/ocfs2/refcounttree.c:	di->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);
fs/ocfs2/refcounttree.c:	di->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);
fs/ocfs2/refcounttree.c:	ocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);
fs/ocfs2/refcounttree.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/refcounttree.c:	clusters = ocfs2_clusters_for_bytes(inode->i_sb, size);
fs/ocfs2/refcounttree.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/refcounttree.c:	ret = ocfs2_lock_refcount_allocators(inode->i_sb,
fs/ocfs2/refcounttree.c:			ocfs2_clusters_to_blocks(inode->i_sb, p_cluster),
fs/ocfs2/refcounttree.c:	struct ocfs2_super *osb = OCFS2_SB(s_inode->i_sb);
fs/ocfs2/refcounttree.c:	clusters = ocfs2_clusters_for_bytes(s_inode->i_sb, size);
fs/ocfs2/refcounttree.c:	handle = ocfs2_start_trans(OCFS2_SB(t_inode->i_sb),
fs/ocfs2/refcounttree.c:	t_inode->i_blocks = s_inode->i_blocks;
fs/ocfs2/refcounttree.c:		t_inode->i_uid = s_inode->i_uid;
fs/ocfs2/refcounttree.c:		t_inode->i_gid = s_inode->i_gid;
fs/ocfs2/refcounttree.c:		t_inode->i_mode = s_inode->i_mode;
fs/ocfs2/refcounttree.c:		t_inode->i_ctime = CURRENT_TIME;
fs/ocfs2/refcounttree.c:		di->i_ctime = cpu_to_le64(t_inode->i_ctime.tv_sec);
fs/ocfs2/refcounttree.c:		di->i_ctime_nsec = cpu_to_le32(t_inode->i_ctime.tv_nsec);
fs/ocfs2/refcounttree.c:		t_inode->i_mtime = s_inode->i_mtime;
fs/ocfs2/refcounttree.c:	ocfs2_commit_trans(OCFS2_SB(t_inode->i_sb), handle);
fs/ocfs2/refcounttree.c:	struct ocfs2_super *osb = OCFS2_SB(s_inode->i_sb);
fs/ocfs2/refcounttree.c:	ret = filemap_fdatawrite(inode->i_mapping);
fs/ocfs2/refcounttree.c:	mutex_lock_nested(&new_inode->i_mutex, I_MUTEX_CHILD);
fs/ocfs2/refcounttree.c:	mutex_unlock(&new_inode->i_mutex);
fs/ocfs2/refcounttree.c:		ret = filemap_fdatawait(inode->i_mapping);
fs/ocfs2/refcounttree.c:	if (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))
fs/ocfs2/refcounttree.c:	error = ocfs2_create_inode_in_orphan(dir, inode->i_mode,
fs/ocfs2/refcounttree.c:	if (dir->i_sb != inode->i_sb)
fs/ocfs2/refcounttree.c:	if (!S_ISREG(inode->i_mode))
fs/ocfs2/refcounttree.c:		if ((current_fsuid() != inode->i_uid) && !capable(CAP_CHOWN))
fs/ocfs2/refcounttree.c:		if (!in_group_p(inode->i_gid) && !capable(CAP_CHOWN))
fs/ocfs2/refcounttree.c:	mutex_lock(&inode->i_mutex);
fs/ocfs2/refcounttree.c:	mutex_unlock(&inode->i_mutex);
fs/ocfs2/refcounttree.c:	if (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))
fs/ocfs2/locks.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/locks.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/journal.c:	if (inode->i_size <  OCFS2_MIN_JOURNAL_SIZE) {
fs/ocfs2/journal.c:		     inode->i_size);
fs/ocfs2/journal.c:	trace_ocfs2_journal_init(inode->i_size,
fs/ocfs2/journal.c:				 (unsigned long long)inode->i_blocks,
fs/ocfs2/journal.c:	num_blocks = ocfs2_blocks_for_bytes(inode->i_sb, inode->i_size);
fs/ocfs2/journal.c:		status = ocfs2_read_blocks_sync(OCFS2_SB(inode->i_sb),
fs/ocfs2/journal.c:			la_dinode ? le64_to_cpu(la_dinode->i_blkno) : 0,
fs/ocfs2/journal.c:			tl_dinode ? le64_to_cpu(tl_dinode->i_blkno) : 0,
fs/ocfs2/journal.c:	mutex_lock(&orphan_dir_inode->i_mutex);
fs/ocfs2/journal.c:	mutex_unlock(&orphan_dir_inode->i_mutex);
fs/ocfs2/ioctl.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/ioctl.c:	mutex_lock(&inode->i_mutex);
fs/ocfs2/ioctl.c:	if (!S_ISDIR(inode->i_mode))
fs/ocfs2/ioctl.c:	oldflags = ocfs2_inode->ip_attr;
fs/ocfs2/ioctl.c:	ocfs2_inode->ip_attr = flags;
fs/ocfs2/ioctl.c:	mutex_unlock(&inode->i_mutex);
fs/ocfs2/ioctl.c:	oib.ib_blocksize = inode->i_sb->s_blocksize;
fs/ocfs2/ioctl.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/ioctl.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/ioctl.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/ioctl.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/ioctl.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/ioctl.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/ioctl.c:	oij.ij_journal_size = osb->journal->j_inode->i_size;
fs/ocfs2/ioctl.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/ioctl.c:		mutex_lock(&gb_inode->i_mutex);
fs/ocfs2/ioctl.c:	cl = &(gb_dinode->id2.i_chain);
fs/ocfs2/ioctl.c:			le32_to_cpu(gb_dinode->id1.bitmap1.i_total);
fs/ocfs2/ioctl.c:			le32_to_cpu(gb_dinode->id1.bitmap1.i_used);
fs/ocfs2/ioctl.c:		mutex_unlock(&gb_inode->i_mutex);
fs/ocfs2/ioctl.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/ioctl.c:		struct super_block *sb = inode->i_sb;
fs/ocfs2/acl.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/acl.c:		handle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),
fs/ocfs2/acl.c:	inode->i_mode = new_mode;
fs/ocfs2/acl.c:	inode->i_ctime = CURRENT_TIME;
fs/ocfs2/acl.c:	di->i_mode = cpu_to_le16(inode->i_mode);
fs/ocfs2/acl.c:	di->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);
fs/ocfs2/acl.c:	di->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);
fs/ocfs2/acl.c:		ocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);
fs/ocfs2/acl.c:	if (S_ISLNK(inode->i_mode))
fs/ocfs2/acl.c:			umode_t mode = inode->i_mode;
fs/ocfs2/acl.c:		if (!S_ISDIR(inode->i_mode))
fs/ocfs2/acl.c:	osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/acl.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/acl.c:	if (S_ISLNK(inode->i_mode))
fs/ocfs2/acl.c:	ret = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
fs/ocfs2/acl.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/acl.c:	if (!S_ISLNK(inode->i_mode)) {
fs/ocfs2/acl.c:			mode = inode->i_mode & ~current_umask();
fs/ocfs2/acl.c:		if (S_ISDIR(inode->i_mode)) {
fs/ocfs2/acl.c:		mode = inode->i_mode;
fs/ocfs2/acl.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/dlmglue.c:	ocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), res, type, ops, inode);
fs/ocfs2/dlmglue.c:	return OCFS2_SB(inode->i_sb);
fs/ocfs2/dlmglue.c:	return OCFS2_SB(dl->dl_inode->i_sb);
fs/ocfs2/dlmglue.c:	ocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,
fs/ocfs2/dlmglue.c:			      inode->i_generation, lockres->l_name);
fs/ocfs2/dlmglue.c:	ocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,
fs/ocfs2/dlmglue.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/dlmglue.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/dlmglue.c:	status = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,
fs/ocfs2/dlmglue.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/dlmglue.c:		ocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);
fs/ocfs2/dlmglue.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/dlmglue.c:	status = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,
fs/ocfs2/dlmglue.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/dlmglue.c:	status = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,
fs/ocfs2/dlmglue.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/dlmglue.c:		ocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,
fs/ocfs2/dlmglue.c:		ocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,
fs/ocfs2/dlmglue.c:	lvb->lvb_iuid      = cpu_to_be32(inode->i_uid);
fs/ocfs2/dlmglue.c:	lvb->lvb_igid      = cpu_to_be32(inode->i_gid);
fs/ocfs2/dlmglue.c:	lvb->lvb_imode     = cpu_to_be16(inode->i_mode);
fs/ocfs2/dlmglue.c:	lvb->lvb_inlink    = cpu_to_be16(inode->i_nlink);
fs/ocfs2/dlmglue.c:		cpu_to_be64(ocfs2_pack_timespec(&inode->i_atime));
fs/ocfs2/dlmglue.c:		cpu_to_be64(ocfs2_pack_timespec(&inode->i_ctime));
fs/ocfs2/dlmglue.c:		cpu_to_be64(ocfs2_pack_timespec(&inode->i_mtime));
fs/ocfs2/dlmglue.c:	lvb->lvb_igeneration = cpu_to_be32(inode->i_generation);
fs/ocfs2/dlmglue.c:	if (S_ISLNK(inode->i_mode) && !oi->ip_clusters)
fs/ocfs2/dlmglue.c:		inode->i_blocks = 0;
fs/ocfs2/dlmglue.c:		inode->i_blocks = ocfs2_inode_sector_count(inode);
fs/ocfs2/dlmglue.c:	inode->i_uid     = be32_to_cpu(lvb->lvb_iuid);
fs/ocfs2/dlmglue.c:	inode->i_gid     = be32_to_cpu(lvb->lvb_igid);
fs/ocfs2/dlmglue.c:	inode->i_mode    = be16_to_cpu(lvb->lvb_imode);
fs/ocfs2/dlmglue.c:	ocfs2_unpack_timespec(&inode->i_atime,
fs/ocfs2/dlmglue.c:	ocfs2_unpack_timespec(&inode->i_mtime,
fs/ocfs2/dlmglue.c:	ocfs2_unpack_timespec(&inode->i_ctime,
fs/ocfs2/dlmglue.c:	    && be32_to_cpu(lvb->lvb_igeneration) == inode->i_generation)
fs/ocfs2/dlmglue.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/dlmglue.c:		mlog_bug_on_msg(inode->i_generation !=
fs/ocfs2/dlmglue.c:				"inode->i_generation: %u\n",
fs/ocfs2/dlmglue.c:				inode->i_generation);
fs/ocfs2/dlmglue.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/dlmglue.c:	if (inode->i_state & I_NEW) {
fs/ocfs2/dlmglue.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/dlmglue.c:	if (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&
fs/ocfs2/dlmglue.c:		ocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);
fs/ocfs2/dlmglue.c:	osb = inode->i_private;
fs/ocfs2/dlmglue.c:	err = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),
fs/ocfs2/dlmglue.c:	err = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),
fs/ocfs2/dlmglue.c:	err = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),
fs/ocfs2/dlmglue.c:	mapping = inode->i_mapping;
fs/ocfs2/dlmglue.c:	if (S_ISDIR(inode->i_mode)) {
fs/ocfs2/dlmglue.c:	if (!S_ISREG(inode->i_mode))
fs/ocfs2/export.c:	if (handle->ih_generation != inode->i_generation) {
fs/ocfs2/export.c:						  inode->i_generation);
fs/ocfs2/export.c:	generation = inode->i_generation;
fs/ocfs2/namei.c:	inode->i_ino = ino_from_blkno(osb->sb, fe_blkno);
fs/ocfs2/namei.c:	inode->i_generation = osb->s_next_generation++;
fs/ocfs2/namei.c:	fe->i_generation = cpu_to_le32(inode->i_generation);
fs/ocfs2/namei.c:	fe->i_uid = cpu_to_le32(inode->i_uid);
fs/ocfs2/namei.c:	fe->i_gid = cpu_to_le32(inode->i_gid);
fs/ocfs2/namei.c:	fe->i_mode = cpu_to_le16(inode->i_mode);
fs/ocfs2/namei.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
fs/ocfs2/namei.c:	ocfs2_set_links_count(fe, inode->i_nlink);
fs/ocfs2/namei.c:	if (S_ISDIR(inode->i_mode) && ocfs2_supports_inline_data(osb)) {
fs/ocfs2/namei.c:	if (S_ISDIR(inode->i_mode))
fs/ocfs2/namei.c:	inode->i_ctime = CURRENT_TIME;
fs/ocfs2/namei.c:	ocfs2_set_links_count(fe, inode->i_nlink);
fs/ocfs2/namei.c:	fe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);
fs/ocfs2/namei.c:	fe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);
fs/ocfs2/namei.c:	if (S_ISDIR(inode->i_mode)) {
fs/ocfs2/namei.c:		if (inode->i_nlink == 2)
fs/ocfs2/namei.c:	if (inode->i_nlink == 1)
fs/ocfs2/namei.c:	if (S_ISDIR(inode->i_mode)) {
fs/ocfs2/namei.c:		if (inode->i_nlink != 2 || !ocfs2_empty_dir(inode)) {
fs/ocfs2/namei.c:	if (S_ISDIR(inode->i_mode))
fs/ocfs2/namei.c:	ocfs2_set_links_count(fe, inode->i_nlink);
fs/ocfs2/namei.c:	if (S_ISDIR(inode->i_mode))
fs/ocfs2/namei.c:		if (S_ISDIR(inode->i_mode))
fs/ocfs2/namei.c:	if (old_dir != new_dir && S_ISDIR(old_inode->i_mode)) {
fs/ocfs2/namei.c:	if (S_ISDIR(old_inode->i_mode)) {
fs/ocfs2/namei.c:		if (S_ISDIR(new_inode->i_mode) || (new_inode->i_nlink == 1)) {
fs/ocfs2/namei.c:		if (S_ISDIR(new_inode->i_mode)) {
fs/ocfs2/namei.c:			if (new_inode->i_nlink != 2 ||
fs/ocfs2/namei.c:		if (S_ISDIR(new_inode->i_mode) ||
fs/ocfs2/namei.c:		if (S_ISDIR(new_inode->i_mode))
fs/ocfs2/namei.c:	old_inode->i_ctime = CURRENT_TIME;
fs/ocfs2/namei.c:		old_di->i_ctime = cpu_to_le64(old_inode->i_ctime.tv_sec);
fs/ocfs2/namei.c:		old_di->i_ctime_nsec = cpu_to_le32(old_inode->i_ctime.tv_nsec);
fs/ocfs2/namei.c:		new_inode->i_ctime = CURRENT_TIME;
fs/ocfs2/namei.c:		sync_mapping_buffers(old_inode->i_mapping);
fs/ocfs2/namei.c:	trace_ocfs2_create_symlink_data((unsigned long long)inode->i_blocks,
fs/ocfs2/namei.c:				   inode->i_mode);
fs/ocfs2/namei.c:	inode->i_rdev = 0;
fs/ocfs2/namei.c:	inode->i_op = &ocfs2_symlink_inode_operations;
fs/ocfs2/namei.c:		inode->i_mapping->a_ops = &ocfs2_aops;
fs/ocfs2/namei.c:		inode->i_blocks = ocfs2_inode_sector_count(inode);
fs/ocfs2/namei.c:		inode->i_mapping->a_ops = &ocfs2_fast_symlink_aops;
fs/ocfs2/namei.c:		inode->i_blocks = 0;
fs/ocfs2/namei.c:	mutex_lock(&orphan_dir_inode->i_mutex);
fs/ocfs2/namei.c:		mutex_unlock(&orphan_dir_inode->i_mutex);
fs/ocfs2/namei.c:	struct ocfs2_super *osb = OCFS2_SB(orphan_dir_inode->i_sb);
fs/ocfs2/namei.c:		mutex_unlock(&orphan_dir_inode->i_mutex);
fs/ocfs2/namei.c:	if (S_ISDIR(inode->i_mode))
fs/ocfs2/namei.c:	if (S_ISDIR(inode->i_mode))
fs/ocfs2/namei.c:	mutex_lock(&orphan_dir_inode->i_mutex);
fs/ocfs2/namei.c:		mutex_unlock(&orphan_dir_inode->i_mutex);
fs/ocfs2/namei.c:	ocfs2_set_links_count(di, inode->i_nlink);
fs/ocfs2/namei.c:	mutex_unlock(&orphan_dir_inode->i_mutex);
fs/ocfs2/cluster/heartbeat.c:	struct o2hb_debug_buf *db = inode->i_private;
fs/ocfs2/cluster/heartbeat.c:	if (!S_ISBLK(inode->i_mode))
fs/ocfs2/localalloc.c:	    (le16_to_cpu(la->la_size) > ocfs2_local_alloc_size(inode->i_sb))) {
fs/ocfs2/localalloc.c:	mutex_lock(&main_bm_inode->i_mutex);
fs/ocfs2/localalloc.c:	mutex_unlock(&main_bm_inode->i_mutex);
fs/ocfs2/localalloc.c:	mutex_lock(&inode->i_mutex);
fs/ocfs2/localalloc.c:		mutex_unlock(&inode->i_mutex);
fs/ocfs2/localalloc.c:	mutex_lock(&main_bm_inode->i_mutex);
fs/ocfs2/localalloc.c:	mutex_unlock(&main_bm_inode->i_mutex);
fs/ocfs2/localalloc.c:	mutex_lock(&local_alloc_inode->i_mutex);
fs/ocfs2/localalloc.c:		mutex_unlock(&local_alloc_inode->i_mutex);
fs/ocfs2/xattr.c:	int blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);
fs/ocfs2/xattr.c:		bucket->bu_bhs[i] = sb_getblk(bucket->bu_inode->i_sb,
fs/ocfs2/xattr.c:		spin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);
fs/ocfs2/xattr.c:		rc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,
fs/ocfs2/xattr.c:		spin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);
fs/ocfs2/xattr.c:	spin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);
fs/ocfs2/xattr.c:	ocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,
fs/ocfs2/xattr.c:	spin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);
fs/ocfs2/xattr.c:	int blocksize = src->bu_inode->i_sb->s_blocksize;
fs/ocfs2/xattr.c:	u32 hash = OCFS2_SB(inode->i_sb)->uuid_hash;
fs/ocfs2/xattr.c:			credits = ocfs2_calc_extend_credits(inode->i_sb,
fs/ocfs2/xattr.c:	u64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);
fs/ocfs2/xattr.c:					ocfs2_blocks_to_clusters(inode->i_sb,
fs/ocfs2/xattr.c:		block = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);
fs/ocfs2/xattr.c:	u32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb, len);
fs/ocfs2/xattr.c:		 ((void *)di + inode->i_sb->s_blocksize -
fs/ocfs2/xattr.c:		 ((void *)di + inode->i_sb->s_blocksize -
fs/ocfs2/xattr.c:	bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);
fs/ocfs2/xattr.c:	blocksize = inode->i_sb->s_blocksize;
fs/ocfs2/xattr.c:		blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);
fs/ocfs2/xattr.c:	xs->end = (void *)di + inode->i_sb->s_blocksize;
fs/ocfs2/xattr.c:			ret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,
fs/ocfs2/xattr.c:	if (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))
fs/ocfs2/xattr.c:	u16 blocksize = inode->i_sb->s_blocksize;
fs/ocfs2/xattr.c:	u32 cpos = 0, bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);
fs/ocfs2/xattr.c:	u32 clusters = ocfs2_clusters_for_bytes(inode->i_sb, value_len);
fs/ocfs2/xattr.c:		blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);
fs/ocfs2/xattr.c:	block = offset >> loc->xl_inode->i_sb->s_blocksize_bits;
fs/ocfs2/xattr.c:	block_offset = offset % loc->xl_inode->i_sb->s_blocksize;
fs/ocfs2/xattr.c:	struct super_block *sb = loc->xl_inode->i_sb;
fs/ocfs2/xattr.c:	struct super_block *sb = loc->xl_inode->i_sb;
fs/ocfs2/xattr.c:	struct super_block *sb = loc->xl_inode->i_sb;
fs/ocfs2/xattr.c:	ret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/xattr.c:		 ((void *)di + inode->i_sb->s_blocksize -
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/xattr.c:	mutex_lock(&xb_alloc_inode->i_mutex);
fs/ocfs2/xattr.c:	mutex_unlock(&xb_alloc_inode->i_mutex);
fs/ocfs2/xattr.c:	if (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))
fs/ocfs2/xattr.c:		ret = ocfs2_lock_refcount_tree(OCFS2_SB(inode->i_sb),
fs/ocfs2/xattr.c:	handle = ocfs2_start_trans((OCFS2_SB(inode->i_sb)),
fs/ocfs2/xattr.c:	ocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);
fs/ocfs2/xattr.c:		ocfs2_unlock_refcount_tree(OCFS2_SB(inode->i_sb), ref_tree, 1);
fs/ocfs2/xattr.c:	unsigned int xattrsize = OCFS2_SB(inode->i_sb)->s_xattr_inline_size;
fs/ocfs2/xattr.c:		free = ocfs2_fast_symlink_chars(inode->i_sb) -
fs/ocfs2/xattr.c:	if (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE)
fs/ocfs2/xattr.c:	xs->end = (void *)di + inode->i_sb->s_blocksize;
fs/ocfs2/xattr.c:			(xs->end - OCFS2_SB(inode->i_sb)->s_xattr_inline_size);
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/xattr.c:	if (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE)
fs/ocfs2/xattr.c:	new_bh = sb_getblk(inode->i_sb, first_blkno);
fs/ocfs2/xattr.c:	memset(xblk, 0, inode->i_sb->s_blocksize);
fs/ocfs2/xattr.c:		cpu_to_le32(OCFS2_SB(inode->i_sb)->fs_generation);
fs/ocfs2/xattr.c:					ocfs2_xattr_recs_per_xb(inode->i_sb));
fs/ocfs2/xattr.c:		xs->end = (void *)xblk + inode->i_sb->s_blocksize;
fs/ocfs2/xattr.c:	u32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb,
fs/ocfs2/xattr.c:			   ocfs2_clusters_to_blocks(inode->i_sb, 1);
fs/ocfs2/xattr.c:		credits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);
fs/ocfs2/xattr.c:			credits += ocfs2_calc_extend_credits(inode->i_sb,
fs/ocfs2/xattr.c:			ret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,
fs/ocfs2/xattr.c:			credits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);
fs/ocfs2/xattr.c:			credits += ocfs2_remove_extent_credits(inode->i_sb);
fs/ocfs2/xattr.c:			credits += ocfs2_remove_extent_credits(inode->i_sb) +
fs/ocfs2/xattr.c:							inode->i_sb,
fs/ocfs2/xattr.c:			old_clusters =	ocfs2_clusters_for_bytes(inode->i_sb,
fs/ocfs2/xattr.c:			credits += ocfs2_remove_extent_credits(inode->i_sb);
fs/ocfs2/xattr.c:			credits += ocfs2_calc_extend_credits(inode->i_sb,
fs/ocfs2/xattr.c:			credits += ocfs2_calc_extend_credits(inode->i_sb,
fs/ocfs2/xattr.c:		credits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);
fs/ocfs2/xattr.c:			OCFS2_SB(inode->i_sb)->s_clustersize) {
fs/ocfs2/xattr.c:			credits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/xattr.c:		inode->i_ctime = CURRENT_TIME;
fs/ocfs2/xattr.c:		di->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);
fs/ocfs2/xattr.c:		di->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);
fs/ocfs2/xattr.c:	if (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))
fs/ocfs2/xattr.c:	if (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE) {
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/xattr.c:	if (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))
fs/ocfs2/xattr.c:	mutex_lock(&tl_inode->i_mutex);
fs/ocfs2/xattr.c:			mutex_unlock(&tl_inode->i_mutex);
fs/ocfs2/xattr.c:	mutex_unlock(&tl_inode->i_mutex);
fs/ocfs2/xattr.c:			ocfs2_error(inode->i_sb,
fs/ocfs2/xattr.c:				    "xattr tree block %llu\n", inode->i_ino,
fs/ocfs2/xattr.c:		ocfs2_error(inode->i_sb, "Inode %lu has bad extent "
fs/ocfs2/xattr.c:			    "record (%u, %u, 0) in xattr", inode->i_ino,
fs/ocfs2/xattr.c:		ret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,
fs/ocfs2/xattr.c:	u16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);
fs/ocfs2/xattr.c:	xs->end = xs->base + inode->i_sb->s_blocksize;
fs/ocfs2/xattr.c:	u32 bpc = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));
fs/ocfs2/xattr.c:			ret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,
fs/ocfs2/xattr.c:	int i, blocksize = inode->i_sb->s_blocksize;
fs/ocfs2/xattr.c:	int blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);
fs/ocfs2/xattr.c:	xs->end = xs->base + inode->i_sb->s_blocksize;
fs/ocfs2/xattr.c:	blkno = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);
fs/ocfs2/xattr.c:	memset(&xb->xb_attrs, 0, inode->i_sb->s_blocksize -
fs/ocfs2/xattr.c:	xr->xt_list.l_count = cpu_to_le16(ocfs2_xattr_recs_per_xb(inode->i_sb));
fs/ocfs2/xattr.c:	size_t blocksize = inode->i_sb->s_blocksize;
fs/ocfs2/xattr.c:	struct super_block *sb = inode->i_sb;
fs/ocfs2/xattr.c:	int blocksize = inode->i_sb->s_blocksize;
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/xattr.c:	int blks_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);
fs/ocfs2/xattr.c:	u16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);
fs/ocfs2/xattr.c:	BUG_ON(OCFS2_XATTR_BUCKET_SIZE < OCFS2_SB(inode->i_sb)->s_clustersize);
fs/ocfs2/xattr.c:	if (ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb)) > 1) {
fs/ocfs2/xattr.c:			 ocfs2_clusters_to_blocks(inode->i_sb, 1));
fs/ocfs2/xattr.c:	u16 bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/xattr.c:	u16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/xattr.c:	int block_off = offs >> inode->i_sb->s_blocksize_bits;
fs/ocfs2/xattr.c:	offs = offs % inode->i_sb->s_blocksize;
fs/ocfs2/xattr.c:	size_t blocksize = inode->i_sb->s_blocksize;
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/xattr.c:	mutex_lock(&tl_inode->i_mutex);
fs/ocfs2/xattr.c:	mutex_unlock(&tl_inode->i_mutex);
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/xattr.c:		ocfs2_blocks_per_xattr_bucket(inode->i_sb);
fs/ocfs2/xattr.c:		ret = ocfs2_get_xattr_tree_value_root(inode->i_sb, bucket,
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/xattr.c:			ret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,
fs/ocfs2/xattr.c:				(fe_bh->b_data + inode->i_sb->s_blocksize -
fs/ocfs2/xattr.c:	if (ocfs2_meta_ecc(OCFS2_SB(inode->i_sb)))
fs/ocfs2/xattr.c:		ret = ocfs2_get_xattr_tree_value_root(inode->i_sb, bucket, i,
fs/ocfs2/xattr.c:	struct super_block *sb = args->old_inode->i_sb;
fs/ocfs2/xattr.c:							args->old_inode->i_sb,
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(args->old_inode->i_sb);
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(args->new_inode->i_sb);
fs/ocfs2/xattr.c:	return ocfs2_value_metas_in_xattr_header(inode->i_sb, bucket->bu_bhs[0],
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(args->reflink->old_inode->i_sb);
fs/ocfs2/xattr.c:	struct super_block *sb = args->reflink->old_inode->i_sb;
fs/ocfs2/xattr.c:		ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));
fs/ocfs2/xattr.c:		new_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);
fs/ocfs2/xattr.c:		blkno += ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);
fs/ocfs2/xattr.c:	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
fs/ocfs2/xattr.c:	ret = ocfs2_lock_refcount_tree(OCFS2_SB(old_inode->i_sb),
fs/ocfs2/xattr.c:	ocfs2_unlock_refcount_tree(OCFS2_SB(old_inode->i_sb),
fs/ocfs2/xattr.c:		ocfs2_schedule_truncate_log_flush(OCFS2_SB(old_inode->i_sb), 1);
fs/ocfs2/xattr.c:		ocfs2_run_deallocs(OCFS2_SB(old_inode->i_sb), &dealloc);
fs/file_table.c:	file->f_mapping = path->dentry->d_inode->i_mapping;
fs/file_table.c:	if ((mode & FMODE_WRITE) && !special_file(path->dentry->d_inode->i_mode)) {
fs/file_table.c:	if (special_file(inode->i_mode))
fs/file_table.c:	if (unlikely(S_ISCHR(inode->i_mode) && inode->i_cdev != NULL &&
fs/file_table.c:		cdev_put(inode->i_cdev);
fs/file_table.c:		if (!S_ISREG(f->f_path.dentry->d_inode->i_mode))
fs/char_dev.c:	p = inode->i_cdev;
fs/char_dev.c:		kobj = kobj_lookup(cdev_map, inode->i_rdev, &idx);
fs/char_dev.c:		p = inode->i_cdev;
fs/char_dev.c:			inode->i_cdev = p = new;
fs/char_dev.c:			list_add(&inode->i_devices, &p->list);
fs/char_dev.c:	list_del_init(&inode->i_devices);
fs/char_dev.c:	inode->i_cdev = NULL;
fs/char_dev.c:		list_del_init(&inode->i_devices);
fs/char_dev.c:		inode->i_cdev = NULL;
fs/coredump.c:	pipe = file->f_path.dentry->d_inode->i_pipe;
fs/coredump.c:		if (inode->i_nlink > 1)
fs/coredump.c:		if (!S_ISREG(inode->i_mode))
fs/coredump.c:		if (!uid_eq(inode->i_uid, current_fsuid()))
fs/ceph/inode.c:	inode->i_ino = ceph_vino_to_ino(*(struct ceph_vino *)data);
fs/ceph/inode.c:	if (inode->i_state & I_NEW) {
fs/ceph/inode.c:		     inode, ceph_vinop(inode), (u64)inode->i_ino);
fs/ceph/inode.c:	dout("get_inode on %lu=%llx.%llx got %p\n", inode->i_ino, vino.ino,
fs/ceph/inode.c:	inode->i_mode = parent->i_mode;
fs/ceph/inode.c:	inode->i_uid = parent->i_uid;
fs/ceph/inode.c:	inode->i_gid = parent->i_gid;
fs/ceph/inode.c:	inode->i_op = &ceph_dir_iops;
fs/ceph/inode.c:	inode->i_fop = &ceph_dir_fops;
fs/ceph/inode.c:	call_rcu(&inode->i_rcu, ceph_i_callback);
fs/ceph/inode.c:	    (truncate_seq == ci->i_truncate_seq && size > inode->i_size)) {
fs/ceph/inode.c:		dout("size %lld -> %llu\n", inode->i_size, size);
fs/ceph/inode.c:		inode->i_size = size;
fs/ceph/inode.c:		inode->i_blocks = (size + (1<<9) - 1) >> 9;
fs/ceph/inode.c:			    mapping_mapped(inode->i_mapping) ||
fs/ceph/inode.c:		if (timespec_compare(ctime, &inode->i_ctime) > 0) {
fs/ceph/inode.c:			     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,
fs/ceph/inode.c:			inode->i_ctime = *ctime;
fs/ceph/inode.c:			     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,
fs/ceph/inode.c:			inode->i_mtime = *mtime;
fs/ceph/inode.c:			inode->i_atime = *atime;
fs/ceph/inode.c:			if (timespec_compare(mtime, &inode->i_mtime) > 0) {
fs/ceph/inode.c:				     inode->i_mtime.tv_sec,
fs/ceph/inode.c:				     inode->i_mtime.tv_nsec,
fs/ceph/inode.c:				inode->i_mtime = *mtime;
fs/ceph/inode.c:			if (timespec_compare(atime, &inode->i_atime) > 0) {
fs/ceph/inode.c:				     inode->i_atime.tv_sec,
fs/ceph/inode.c:				     inode->i_atime.tv_nsec,
fs/ceph/inode.c:				inode->i_atime = *atime;
fs/ceph/inode.c:			inode->i_ctime = *ctime;
fs/ceph/inode.c:			inode->i_mtime = *mtime;
fs/ceph/inode.c:			inode->i_atime = *atime;
fs/ceph/inode.c:	inode->i_version++;
fs/ceph/inode.c:	inode->i_rdev = le32_to_cpu(info->rdev);
fs/ceph/inode.c:		inode->i_mode = le32_to_cpu(info->mode);
fs/ceph/inode.c:		inode->i_uid = le32_to_cpu(info->uid);
fs/ceph/inode.c:		inode->i_gid = le32_to_cpu(info->gid);
fs/ceph/inode.c:		dout("%p mode 0%o uid.gid %d.%d\n", inode, inode->i_mode,
fs/ceph/inode.c:		     inode->i_uid, inode->i_gid);
fs/ceph/inode.c:	inode->i_blkbits = fls(le32_to_cpu(info->layout.fl_stripe_unit)) - 1;
fs/ceph/inode.c:	inode->i_mapping->a_ops = &ceph_aops;
fs/ceph/inode.c:	inode->i_mapping->backing_dev_info =
fs/ceph/inode.c:		&ceph_sb_to_client(inode->i_sb)->backing_dev_info;
fs/ceph/inode.c:	switch (inode->i_mode & S_IFMT) {
fs/ceph/inode.c:		init_special_inode(inode, inode->i_mode, inode->i_rdev);
fs/ceph/inode.c:		inode->i_op = &ceph_file_iops;
fs/ceph/inode.c:		inode->i_op = &ceph_file_iops;
fs/ceph/inode.c:		inode->i_fop = &ceph_file_fops;
fs/ceph/inode.c:		inode->i_op = &ceph_symlink_iops;
fs/ceph/inode.c:			if (WARN_ON(symlen != inode->i_size))
fs/ceph/inode.c:		inode->i_op = &ceph_dir_iops;
fs/ceph/inode.c:		inode->i_fop = &ceph_dir_fops;
fs/ceph/inode.c:		       ceph_vinop(inode), inode->i_mode);
fs/ceph/inode.c:	if (S_ISDIR(inode->i_mode) &&
fs/ceph/inode.c:	dout("set_size %p %llu -> %llu\n", inode, inode->i_size, size);
fs/ceph/inode.c:	inode->i_size = size;
fs/ceph/inode.c:	inode->i_blocks = (size + (1 << 9) - 1) >> 9;
fs/ceph/inode.c:	filemap_fdatawrite(&inode->i_data);
fs/ceph/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/ceph/inode.c:	mutex_lock(&inode->i_mutex);
fs/ceph/inode.c:	mutex_unlock(&inode->i_mutex);
fs/ceph/inode.c:	if (queue_work(ceph_sb_to_client(inode->i_sb)->trunc_wq,
fs/ceph/inode.c:		filemap_write_and_wait_range(&inode->i_data, 0,
fs/ceph/inode.c:					     inode->i_sb->s_maxbytes);
fs/ceph/inode.c:	truncate_inode_pages(inode->i_mapping, to);
fs/ceph/inode.c:		     inode->i_uid, attr->ia_uid);
fs/ceph/inode.c:			inode->i_uid = attr->ia_uid;
fs/ceph/inode.c:			   attr->ia_uid != inode->i_uid) {
fs/ceph/inode.c:		     inode->i_gid, attr->ia_gid);
fs/ceph/inode.c:			inode->i_gid = attr->ia_gid;
fs/ceph/inode.c:			   attr->ia_gid != inode->i_gid) {
fs/ceph/inode.c:		dout("setattr %p mode 0%o -> 0%o\n", inode, inode->i_mode,
fs/ceph/inode.c:			inode->i_mode = attr->ia_mode;
fs/ceph/inode.c:			   attr->ia_mode != inode->i_mode) {
fs/ceph/inode.c:		     inode->i_atime.tv_sec, inode->i_atime.tv_nsec,
fs/ceph/inode.c:			inode->i_atime = attr->ia_atime;
fs/ceph/inode.c:			   timespec_compare(&inode->i_atime,
fs/ceph/inode.c:			inode->i_atime = attr->ia_atime;
fs/ceph/inode.c:			   !timespec_equal(&inode->i_atime, &attr->ia_atime)) {
fs/ceph/inode.c:		     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,
fs/ceph/inode.c:			inode->i_mtime = attr->ia_mtime;
fs/ceph/inode.c:			   timespec_compare(&inode->i_mtime,
fs/ceph/inode.c:			inode->i_mtime = attr->ia_mtime;
fs/ceph/inode.c:			   !timespec_equal(&inode->i_mtime, &attr->ia_mtime)) {
fs/ceph/inode.c:		     inode->i_size, attr->ia_size);
fs/ceph/inode.c:		if (attr->ia_size > inode->i_sb->s_maxbytes) {
fs/ceph/inode.c:		    attr->ia_size > inode->i_size) {
fs/ceph/inode.c:			inode->i_size = attr->ia_size;
fs/ceph/inode.c:			inode->i_blocks =
fs/ceph/inode.c:			inode->i_ctime = attr->ia_ctime;
fs/ceph/inode.c:			   attr->ia_size != inode->i_size) {
fs/ceph/inode.c:				cpu_to_le64(inode->i_size);
fs/ceph/inode.c:		     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,
fs/ceph/inode.c:		inode->i_ctime = attr->ia_ctime;
fs/ceph/inode.c:		inode->i_ctime = CURRENT_TIME;
fs/ceph/inode.c:	struct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);
fs/ceph/inode.c:	dout("do_getattr inode %p mask %s mode 0%o\n", inode, ceph_cap_string(mask), inode->i_mode);
fs/ceph/inode.c:		stat->ino = ceph_translate_ino(inode->i_sb, inode->i_ino);
fs/ceph/inode.c:		if (S_ISDIR(inode->i_mode)) {
fs/ceph/inode.c:			if (ceph_test_mount_opt(ceph_sb_to_client(inode->i_sb),
fs/ceph/super.h:	return (struct ceph_fs_client *)inode->i_sb->s_fs_info;
fs/ceph/dir.c:		      ceph_translate_ino(dentry->d_sb, dentry->d_inode->i_ino),
fs/ceph/dir.c:		      dentry->d_inode->i_mode >> 12);
fs/ceph/dir.c:			    ceph_translate_ino(inode->i_sb, inode->i_ino),
fs/ceph/dir.c:			    inode->i_mode >> 12) < 0)
fs/ceph/dir.c:			    ceph_translate_ino(inode->i_sb, ino),
fs/ceph/dir.c:			    inode->i_mode >> 12) < 0)
fs/ceph/dir.c:			    ceph_translate_ino(inode->i_sb, ino), ftype) < 0) {
fs/ceph/dir.c:	mutex_lock(&inode->i_mutex);
fs/ceph/dir.c:		offset += inode->i_size + 2;   /* FIXME */
fs/ceph/dir.c:	if (offset >= 0 && offset <= inode->i_sb->s_maxbytes) {
fs/ceph/dir.c:	mutex_unlock(&inode->i_mutex);
fs/ceph/dir.c:	if (inode->i_nlink == 1) {
fs/ceph/dir.c:		op = S_ISDIR(dentry->d_inode->i_mode) ?
fs/ceph/dir.c:	if (!ceph_test_mount_opt(ceph_sb_to_client(inode->i_sb), DIRSTAT))
fs/ceph/dir.c:	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/ceph/dir.c:	mutex_lock(&inode->i_mutex);
fs/ceph/dir.c:	mutex_unlock(&inode->i_mutex);
fs/ceph/mds_client.c:	if (is_hash && S_ISDIR(inode->i_mode)) {
fs/ceph/mds_client.c:			ceph_sb_to_client(inode->i_sb)->mdsc;
fs/ceph/mds_client.c:		     inode, cap, atomic_read(&inode->i_count));
fs/ceph/mds_client.c:		rec.v1.size = cpu_to_le64(inode->i_size);
fs/ceph/mds_client.c:		ceph_encode_timespec(&rec.v1.mtime, &inode->i_mtime);
fs/ceph/mds_client.c:		ceph_encode_timespec(&rec.v1.atime, &inode->i_atime);
fs/ceph/file.c:	switch (inode->i_mode & S_IFMT) {
fs/ceph/file.c:		     inode->i_mode);
fs/ceph/file.c:		BUG_ON(inode->i_fop->release != ceph_release);
fs/ceph/file.c:		     inode->i_mode);
fs/ceph/file.c:		     inode->i_mode);
fs/ceph/file.c:		BUG_ON(inode->i_fop->release == ceph_release);
fs/ceph/file.c:		ret = inode->i_fop->open(inode, file);
fs/ceph/file.c:	struct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);
fs/ceph/file.c:	if (S_ISDIR(inode->i_mode))
fs/ceph/file.c:	req = prepare_open_request(inode->i_sb, flags, 0);
fs/ceph/file.c:	if (dn || dentry->d_inode == NULL || S_ISLNK(dentry->d_inode->i_mode)) {
fs/ceph/file.c:		if (pos + left > inode->i_size)
fs/ceph/file.c:		if (left > 0 && pos < inode->i_size) {
fs/ceph/file.c:			if (pos + left > inode->i_size)
fs/ceph/file.c:				left = inode->i_size - pos;
fs/ceph/file.c:	ret = filemap_write_and_wait(inode->i_mapping);
fs/ceph/file.c:	ret = filemap_write_and_wait_range(inode->i_mapping, pos, pos + left);
fs/ceph/file.c:	ret = invalidate_inode_pages2_range(inode->i_mapping,
fs/ceph/file.c:		truncate_inode_pages_range(inode->i_mapping, pos,
fs/ceph/file.c:	    (inode->i_sb->s_flags & MS_SYNCHRONOUS) ||
fs/ceph/file.c:		if (statret == 0 && *ppos < inode->i_size) {
fs/ceph/file.c:			dout("aio_read sync_read hit hole, ppos %lld < size %lld, reading more\n", *ppos, inode->i_size);
fs/ceph/file.c:		&ceph_sb_to_client(inode->i_sb)->client->osdc;
fs/ceph/file.c:	    !(inode->i_sb->s_flags & MS_SYNCHRONOUS) &&
fs/ceph/file.c:	     (unsigned)iov->iov_len - written, inode->i_size);
fs/ceph/file.c:	mutex_lock(&inode->i_mutex);
fs/ceph/file.c:		offset += inode->i_size;
fs/ceph/file.c:		if (offset >= inode->i_size) {
fs/ceph/file.c:		if (offset >= inode->i_size) {
fs/ceph/file.c:		offset = inode->i_size;
fs/ceph/file.c:	if (offset < 0 || offset > inode->i_sb->s_maxbytes) {
fs/ceph/file.c:	mutex_unlock(&inode->i_mutex);
fs/ceph/locks.c:		ceph_sb_to_client(inode->i_sb)->mdsc;
fs/ceph/locks.c:	for (lock = inode->i_flock; lock != NULL; lock = lock->fl_next) {
fs/ceph/locks.c:	for (lock = inode->i_flock; lock != NULL; lock = lock->fl_next) {
fs/ceph/locks.c:	for (lock = inode->i_flock; lock != NULL; lock = lock->fl_next) {
fs/ceph/ioctl.c:	struct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;
fs/ceph/ioctl.c:	struct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;
fs/ceph/ioctl.c:		&ceph_sb_to_client(inode->i_sb)->client->osdc;
fs/ceph/caps.c:	size = inode->i_size;
fs/ceph/caps.c:	mtime = inode->i_mtime;
fs/ceph/caps.c:	atime = inode->i_atime;
fs/ceph/caps.c:	uid = inode->i_uid;
fs/ceph/caps.c:	gid = inode->i_gid;
fs/ceph/caps.c:	mode = inode->i_mode;
fs/ceph/caps.c:	struct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;
fs/ceph/caps.c:	invalidate_mapping_pages(&inode->i_data, 0, -1);
fs/ceph/caps.c:	if (inode->i_data.nrpages == 0 &&
fs/ceph/caps.c:	if (!mdsc->stopping && inode->i_nlink > 0) {
fs/ceph/caps.c:	    inode->i_data.nrpages &&                 /* have cached pages */
fs/ceph/caps.c:			if ((inode->i_size << 1) >= ci->i_max_size &&
fs/ceph/caps.c:	struct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;
fs/ceph/caps.c:	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/ceph/caps.c:	mutex_lock(&inode->i_mutex);
fs/ceph/caps.c:	mutex_unlock(&inode->i_mutex);
fs/ceph/caps.c:			ceph_sb_to_client(inode->i_sb)->mdsc;
fs/ceph/caps.c:	     endoff > (inode->i_size << 1)) &&
fs/ceph/caps.c:		inode->i_size);
fs/ceph/caps.c:		inode->i_mode = le32_to_cpu(grant->mode);
fs/ceph/caps.c:		inode->i_uid = le32_to_cpu(grant->uid);
fs/ceph/caps.c:		inode->i_gid = le32_to_cpu(grant->gid);
fs/ceph/caps.c:		dout("%p mode 0%o uid.gid %d.%d\n", inode, inode->i_mode,
fs/ceph/caps.c:		     inode->i_uid, inode->i_gid);
fs/ceph/caps.c:	struct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;
fs/ceph/snap.c:		capsnap->mode = inode->i_mode;
fs/ceph/snap.c:		capsnap->uid = inode->i_uid;
fs/ceph/snap.c:		capsnap->gid = inode->i_gid;
fs/ceph/snap.c:	struct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;
fs/ceph/snap.c:	capsnap->size = inode->i_size;
fs/ceph/snap.c:	capsnap->mtime = inode->i_mtime;
fs/ceph/snap.c:	capsnap->atime = inode->i_atime;
fs/ceph/snap.c:	capsnap->ctime = inode->i_ctime;
fs/ceph/addr.c:		if (add_to_page_cache_lru(page, &inode->i_data, page->index,
fs/ceph/addr.c:				   &inode->i_mtime,
fs/ceph/addr.c:		mapping_set_error(&inode->i_data, err);
fs/ceph/addr.c:	struct address_space *mapping = inode->i_mapping;
fs/ceph/addr.c:			generic_error_remove_page(inode->i_mapping, page);
fs/ceph/addr.c:			     ceph_sb_to_client(inode->i_sb)->wb_pagevec_pool);
fs/ceph/addr.c:	unsigned wsize = 1 << inode->i_blkbits;
fs/ceph/addr.c:					    &inode->i_mtime, true, 1, 0);
fs/ceph/addr.c:	i_size = inode->i_size;   /* caller holds i_mutex */
fs/ceph/addr.c:	if (i_size + len > inode->i_sb->s_maxbytes) {
fs/ceph/addr.c:	     inode, ceph_vinop(inode), pos, len, inode->i_size);
fs/ceph/addr.c:	if (pos+copied > inode->i_size)
fs/ceph/addr.c:	    (page->mapping != inode->i_mapping))
fs/ceph/xattr.c:	if (S_ISDIR(inode->i_mode))
fs/ceph/xattr.c:	else if (S_ISREG(inode->i_mode))
fs/ceph/xattr.c:	inode->i_ctime = CURRENT_TIME;
fs/ceph/xattr.c:	inode->i_ctime = CURRENT_TIME;
fs/fs-writeback.c:	struct super_block *sb = inode->i_sb;
fs/fs-writeback.c:		return inode->i_mapping->backing_dev_info;
fs/fs-writeback.c:	list_del_init(&inode->i_wb_list);
fs/fs-writeback.c:		if (time_before(inode->dirtied_when, tail->dirtied_when))
fs/fs-writeback.c:			inode->dirtied_when = jiffies;
fs/fs-writeback.c:	list_move(&inode->i_wb_list, &wb->b_dirty);
fs/fs-writeback.c:	list_move(&inode->i_wb_list, &wb->b_more_io);
fs/fs-writeback.c:	inode->i_state &= ~I_SYNC;
fs/fs-writeback.c:	wake_up_bit(&inode->i_state, __I_SYNC);
fs/fs-writeback.c:	bool ret = time_after(inode->dirtied_when, t);
fs/fs-writeback.c:	ret = ret && time_before_eq(inode->dirtied_when, jiffies);
fs/fs-writeback.c:		if (sb && sb != inode->i_sb)
fs/fs-writeback.c:		sb = inode->i_sb;
fs/fs-writeback.c:		list_move(&inode->i_wb_list, &tmp);
fs/fs-writeback.c:			if (inode->i_sb == sb)
fs/fs-writeback.c:				list_move(&inode->i_wb_list, dispatch_queue);
fs/fs-writeback.c:	if (inode->i_sb->s_op->write_inode && !is_bad_inode(inode))
fs/fs-writeback.c:		return inode->i_sb->s_op->write_inode(inode, wbc);
fs/fs-writeback.c:	__releases(inode->i_lock)
fs/fs-writeback.c:	__acquires(inode->i_lock)
fs/fs-writeback.c:	DEFINE_WAIT_BIT(wq, &inode->i_state, __I_SYNC);
fs/fs-writeback.c:	wqh = bit_waitqueue(&inode->i_state, __I_SYNC);
fs/fs-writeback.c:	while (inode->i_state & I_SYNC) {
fs/fs-writeback.c:		spin_unlock(&inode->i_lock);
fs/fs-writeback.c:		spin_lock(&inode->i_lock);
fs/fs-writeback.c:	spin_lock(&inode->i_lock);
fs/fs-writeback.c:	spin_unlock(&inode->i_lock);
fs/fs-writeback.c:	__releases(inode->i_lock)
fs/fs-writeback.c:	wait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);
fs/fs-writeback.c:	sleep = inode->i_state & I_SYNC;
fs/fs-writeback.c:	spin_unlock(&inode->i_lock);
fs/fs-writeback.c:	if (inode->i_state & I_FREEING)
fs/fs-writeback.c:	if ((inode->i_state & I_DIRTY) &&
fs/fs-writeback.c:		inode->dirtied_when = jiffies;
fs/fs-writeback.c:	if (mapping_tagged(inode->i_mapping, PAGECACHE_TAG_DIRTY)) {
fs/fs-writeback.c:	} else if (inode->i_state & I_DIRTY) {
fs/fs-writeback.c:		list_del_init(&inode->i_wb_list);
fs/fs-writeback.c:	struct address_space *mapping = inode->i_mapping;
fs/fs-writeback.c:	WARN_ON(!(inode->i_state & I_SYNC));
fs/fs-writeback.c:	spin_lock(&inode->i_lock);
fs/fs-writeback.c:		inode->i_state &= ~I_DIRTY_PAGES;
fs/fs-writeback.c:	dirty = inode->i_state & I_DIRTY;
fs/fs-writeback.c:	inode->i_state &= ~(I_DIRTY_SYNC | I_DIRTY_DATASYNC);
fs/fs-writeback.c:	spin_unlock(&inode->i_lock);
fs/fs-writeback.c:	spin_lock(&inode->i_lock);
fs/fs-writeback.c:	if (!atomic_read(&inode->i_count))
fs/fs-writeback.c:		WARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));
fs/fs-writeback.c:		WARN_ON(inode->i_state & I_WILL_FREE);
fs/fs-writeback.c:	if (inode->i_state & I_SYNC) {
fs/fs-writeback.c:	WARN_ON(inode->i_state & I_SYNC);
fs/fs-writeback.c:	if (!(inode->i_state & I_DIRTY))
fs/fs-writeback.c:	inode->i_state |= I_SYNC;
fs/fs-writeback.c:	spin_unlock(&inode->i_lock);
fs/fs-writeback.c:	spin_lock(&inode->i_lock);
fs/fs-writeback.c:	if (!(inode->i_state & I_DIRTY))
fs/fs-writeback.c:		list_del_init(&inode->i_wb_list);
fs/fs-writeback.c:	spin_unlock(&inode->i_lock);
fs/fs-writeback.c:		if (inode->i_sb != sb) {
fs/fs-writeback.c:		spin_lock(&inode->i_lock);
fs/fs-writeback.c:		if (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {
fs/fs-writeback.c:			spin_unlock(&inode->i_lock);
fs/fs-writeback.c:		if ((inode->i_state & I_SYNC) && wbc.sync_mode != WB_SYNC_ALL) {
fs/fs-writeback.c:			spin_unlock(&inode->i_lock);
fs/fs-writeback.c:		if (inode->i_state & I_SYNC) {
fs/fs-writeback.c:		inode->i_state |= I_SYNC;
fs/fs-writeback.c:		spin_unlock(&inode->i_lock);
fs/fs-writeback.c:		spin_lock(&inode->i_lock);
fs/fs-writeback.c:		if (!(inode->i_state & I_DIRTY))
fs/fs-writeback.c:		spin_unlock(&inode->i_lock);
fs/fs-writeback.c:		struct super_block *sb = inode->i_sb;
fs/fs-writeback.c:			spin_lock(&inode->i_lock);
fs/fs-writeback.c:	if (inode->i_ino || strcmp(inode->i_sb->s_id, "bdev")) {
fs/fs-writeback.c:		       current->comm, task_pid_nr(current), inode->i_ino,
fs/fs-writeback.c:		       name, inode->i_sb->s_id);
fs/fs-writeback.c: * Note that for blockdevs, inode->dirtied_when represents the dirtying time of
fs/fs-writeback.c:	struct super_block *sb = inode->i_sb;
fs/fs-writeback.c:	if ((inode->i_state & flags) == flags)
fs/fs-writeback.c:	spin_lock(&inode->i_lock);
fs/fs-writeback.c:	if ((inode->i_state & flags) != flags) {
fs/fs-writeback.c:		const int was_dirty = inode->i_state & I_DIRTY;
fs/fs-writeback.c:		inode->i_state |= flags;
fs/fs-writeback.c:		if (inode->i_state & I_SYNC)
fs/fs-writeback.c:		if (!S_ISBLK(inode->i_mode)) {
fs/fs-writeback.c:		if (inode->i_state & I_FREEING)
fs/fs-writeback.c:			spin_unlock(&inode->i_lock);
fs/fs-writeback.c:			inode->dirtied_when = jiffies;
fs/fs-writeback.c:			list_move(&inode->i_wb_list, &bdi->wb.b_dirty);
fs/fs-writeback.c:	spin_unlock(&inode->i_lock);
fs/fs-writeback.c:		struct address_space *mapping = inode->i_mapping;
fs/fs-writeback.c:		spin_lock(&inode->i_lock);
fs/fs-writeback.c:		if ((inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) ||
fs/fs-writeback.c:			spin_unlock(&inode->i_lock);
fs/fs-writeback.c:		spin_unlock(&inode->i_lock);
fs/fs-writeback.c:	if (!mapping_cap_writeback_dirty(inode->i_mapping))
fs/fs-writeback.c: * update inode->i_state.
fs/libfs.c:	stat->blocks = inode->i_mapping->nrpages << (PAGE_CACHE_SHIFT - 9);
fs/libfs.c:	mutex_lock(&dentry->d_inode->i_mutex);
fs/libfs.c:			mutex_unlock(&dentry->d_inode->i_mutex);
fs/libfs.c:	mutex_unlock(&dentry->d_inode->i_mutex);
fs/libfs.c:	return (inode->i_mode >> 12) & 15;
fs/libfs.c:			ino = dentry->d_inode->i_ino;
fs/libfs.c:					    next->d_inode->i_ino, 
fs/libfs.c:	if (inode->i_private)
fs/libfs.c:		file->private_data = inode->i_private;
fs/libfs.c:	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
fs/libfs.c:	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
fs/libfs.c:	int they_are_dirs = S_ISDIR(old_dentry->d_inode->i_mode);
fs/libfs.c:		new_dir->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/libfs.c:	if (last_pos > inode->i_size)
fs/libfs.c:	inode->i_ino = 1;
fs/libfs.c:	inode->i_mode = S_IFDIR | 0755;
fs/libfs.c:	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/libfs.c:	inode->i_op = &simple_dir_inode_operations;
fs/libfs.c:	inode->i_fop = &simple_dir_operations;
fs/libfs.c:		inode->i_mode = S_IFREG | files->mode;
fs/libfs.c:		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/libfs.c:		inode->i_fop = files->ops;
fs/libfs.c:		inode->i_ino = i;
fs/libfs.c:	attr->data = inode->i_private;
fs/libfs.c:	err = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/libfs.c:	mutex_lock(&inode->i_mutex);
fs/libfs.c:	ret = sync_mapping_buffers(inode->i_mapping);
fs/libfs.c:	if (!(inode->i_state & I_DIRTY))
fs/libfs.c:	if (datasync && !(inode->i_state & I_DIRTY_DATASYNC))
fs/libfs.c:	mutex_unlock(&inode->i_mutex);
fs/reiserfs/inode.c:	    2 * REISERFS_QUOTA_INIT_BLOCKS(inode->i_sb);
fs/reiserfs/inode.c:	if (!inode->i_nlink && !is_bad_inode(inode))
fs/reiserfs/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/reiserfs/inode.c:	if (inode->i_nlink)
fs/reiserfs/inode.c:	depth = reiserfs_write_lock_once(inode->i_sb);
fs/reiserfs/inode.c:	if (!(inode->i_state & I_NEW) && INODE_PKEY(inode)->k_objectid != 0) {	/* also handles bad_inode case */
fs/reiserfs/inode.c:		if (journal_begin(&th, inode->i_sb, jbegin_count))
fs/reiserfs/inode.c:		if (journal_end(&th, inode->i_sb, jbegin_count))
fs/reiserfs/inode.c:	reiserfs_write_unlock_once(inode->i_sb, depth);
fs/reiserfs/inode.c:	inode->i_blocks = 0;
fs/reiserfs/inode.c:	map_bh(bh, inode->i_sb, block);
fs/reiserfs/inode.c:	    block < (1 << (31 - inode->i_sb->s_blocksize_bits)))	// old file, but 'block' is inside of 2gb
fs/reiserfs/inode.c:		     (loff_t) block * inode->i_sb->s_blocksize + 1, TYPE_ANY,
fs/reiserfs/inode.c:	result = search_for_position_by_key(inode->i_sb, &key, &path);
fs/reiserfs/inode.c:			map_bh(bh_result, inode->i_sb, blocknr);
fs/reiserfs/inode.c:	memset(p, 0, inode->i_sb->s_blocksize);
fs/reiserfs/inode.c:		if ((le_ih_k_offset(ih) + path.pos_in_item) > inode->i_size)
fs/reiserfs/inode.c:		if ((le_ih_k_offset(ih) - 1 + ih_item_len(ih)) > inode->i_size) {
fs/reiserfs/inode.c:			    inode->i_size - (le_ih_k_offset(ih) - 1) -
fs/reiserfs/inode.c:		result = search_for_position_by_key(inode->i_sb, &key, &path);
fs/reiserfs/inode.c:	map_bh(bh_result, inode->i_sb, 0);
fs/reiserfs/inode.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/inode.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/inode.c:	bh_result->b_size = (1 << inode->i_blkbits);
fs/reiserfs/inode.c:		reiserfs_write_lock(inode->i_sb);
fs/reiserfs/inode.c:		reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/inode.c:		tail_page = grab_cache_page(inode->i_mapping, index);
fs/reiserfs/inode.c:	    2 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);
fs/reiserfs/inode.c:	    (((loff_t) block) << inode->i_sb->s_blocksize_bits) + 1;
fs/reiserfs/inode.c:	lock_depth = reiserfs_write_lock_once(inode->i_sb);
fs/reiserfs/inode.c:		reiserfs_write_unlock_once(inode->i_sb, lock_depth);
fs/reiserfs/inode.c:		reiserfs_write_unlock_once(inode->i_sb, lock_depth);
fs/reiserfs/inode.c:	    reiserfs_transaction_running(inode->i_sb))
fs/reiserfs/inode.c:	if ((have_large_tails(inode->i_sb)
fs/reiserfs/inode.c:	     && inode->i_size < i_block_size(inode) * 4)
fs/reiserfs/inode.c:	    || (have_small_tails(inode->i_sb)
fs/reiserfs/inode.c:		&& inode->i_size < i_block_size(inode)))
fs/reiserfs/inode.c:	if ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {
fs/reiserfs/inode.c:		th = reiserfs_persistent_transaction(inode->i_sb, jbegin_count);
fs/reiserfs/inode.c:	retval = search_for_position_by_key(inode->i_sb, &key, &path);
fs/reiserfs/inode.c:	fs_gen = get_generation(inode->i_sb);
fs/reiserfs/inode.c:			SB_JOURNAL(inode->i_sb)->j_next_async_flush = 1;
fs/reiserfs/inode.c:		if (fs_changed(fs_gen, inode->i_sb)
fs/reiserfs/inode.c:			reiserfs_prepare_for_journal(inode->i_sb, bh, 1);
fs/reiserfs/inode.c:			if (fs_changed(fs_gen, inode->i_sb)
fs/reiserfs/inode.c:				reiserfs_restore_prepared_buffer(inode->i_sb,
fs/reiserfs/inode.c:			    && reiserfs_data_ordered(inode->i_sb))
fs/reiserfs/inode.c:			journal_mark_dirty(th, inode->i_sb, bh);
fs/reiserfs/inode.c:		reiserfs_write_unlock_once(inode->i_sb, lock_depth);
fs/reiserfs/inode.c:			      1) & ~(inode->i_sb->s_blocksize - 1)) + 1;
fs/reiserfs/inode.c:						reiserfs_error(inode->i_sb,
fs/reiserfs/inode.c:							inode->i_ino,
fs/reiserfs/inode.c:							th = reiserfs_persistent_transaction(inode->i_sb, 3);
fs/reiserfs/inode.c:			    MAX_ITEM_LEN(inode->i_sb->s_blocksize) /
fs/reiserfs/inode.c:						     inode->i_sb->s_blocksize),
fs/reiserfs/inode.c:				     //pos_in_item * inode->i_sb->s_blocksize,
fs/reiserfs/inode.c:			      cpu_key_k_offset(&tmp_key)) >> inode->i_sb->
fs/reiserfs/inode.c:				inode->i_size +=
fs/reiserfs/inode.c:				    inode->i_sb->s_blocksize * blocks_needed;
fs/reiserfs/inode.c:			reiserfs_write_unlock_once(inode->i_sb, lock_depth);
fs/reiserfs/inode.c:			lock_depth = reiserfs_write_lock_once(inode->i_sb);
fs/reiserfs/inode.c:		retval = search_for_position_by_key(inode->i_sb, &key, &path);
fs/reiserfs/inode.c:			reiserfs_warning(inode->i_sb, "vs-825",
fs/reiserfs/inode.c:	reiserfs_write_unlock_once(inode->i_sb, lock_depth);
fs/reiserfs/inode.c:	loff_t blocksize = inode->i_sb->s_blocksize;
fs/reiserfs/inode.c:	if (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode))
fs/reiserfs/inode.c:	    ((inode->i_size +
fs/reiserfs/inode.c:	      (blocksize - 1)) >> inode->i_sb->s_blocksize_bits) * UNFM_P_SIZE +
fs/reiserfs/inode.c:	if (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {
fs/reiserfs/inode.c:		return inode->i_size +
fs/reiserfs/inode.c:	if (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {
fs/reiserfs/inode.c:		inode->i_mode = sd_v1_mode(sd);
fs/reiserfs/inode.c:		inode->i_size = sd_v1_size(sd);
fs/reiserfs/inode.c:		inode->i_atime.tv_sec = sd_v1_atime(sd);
fs/reiserfs/inode.c:		inode->i_mtime.tv_sec = sd_v1_mtime(sd);
fs/reiserfs/inode.c:		inode->i_ctime.tv_sec = sd_v1_ctime(sd);
fs/reiserfs/inode.c:		inode->i_atime.tv_nsec = 0;
fs/reiserfs/inode.c:		inode->i_ctime.tv_nsec = 0;
fs/reiserfs/inode.c:		inode->i_mtime.tv_nsec = 0;
fs/reiserfs/inode.c:		inode->i_blocks = sd_v1_blocks(sd);
fs/reiserfs/inode.c:		inode->i_generation = le32_to_cpu(INODE_PKEY(inode)->k_dir_id);
fs/reiserfs/inode.c:		blocks = (inode->i_size + 511) >> 9;
fs/reiserfs/inode.c:		blocks = _ROUND_UP(blocks, inode->i_sb->s_blocksize >> 9);
fs/reiserfs/inode.c:		if (inode->i_blocks > blocks) {
fs/reiserfs/inode.c:			inode->i_blocks = blocks;
fs/reiserfs/inode.c:		if (inode->i_blocks & 1) {
fs/reiserfs/inode.c:			inode->i_blocks++;
fs/reiserfs/inode.c:				to_real_used_space(inode, inode->i_blocks,
fs/reiserfs/inode.c:		inode->i_mode = sd_v2_mode(sd);
fs/reiserfs/inode.c:		inode->i_size = sd_v2_size(sd);
fs/reiserfs/inode.c:		inode->i_mtime.tv_sec = sd_v2_mtime(sd);
fs/reiserfs/inode.c:		inode->i_atime.tv_sec = sd_v2_atime(sd);
fs/reiserfs/inode.c:		inode->i_ctime.tv_sec = sd_v2_ctime(sd);
fs/reiserfs/inode.c:		inode->i_ctime.tv_nsec = 0;
fs/reiserfs/inode.c:		inode->i_mtime.tv_nsec = 0;
fs/reiserfs/inode.c:		inode->i_atime.tv_nsec = 0;
fs/reiserfs/inode.c:		inode->i_blocks = sd_v2_blocks(sd);
fs/reiserfs/inode.c:		if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
fs/reiserfs/inode.c:			inode->i_generation =
fs/reiserfs/inode.c:			inode->i_generation = sd_v2_generation(sd);
fs/reiserfs/inode.c:		if (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))
fs/reiserfs/inode.c:				to_real_used_space(inode, inode->i_blocks,
fs/reiserfs/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/reiserfs/inode.c:		inode->i_op = &reiserfs_file_inode_operations;
fs/reiserfs/inode.c:		inode->i_fop = &reiserfs_file_operations;
fs/reiserfs/inode.c:		inode->i_mapping->a_ops = &reiserfs_address_space_operations;
fs/reiserfs/inode.c:	} else if (S_ISDIR(inode->i_mode)) {
fs/reiserfs/inode.c:		inode->i_op = &reiserfs_dir_inode_operations;
fs/reiserfs/inode.c:		inode->i_fop = &reiserfs_dir_operations;
fs/reiserfs/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/reiserfs/inode.c:		inode->i_op = &reiserfs_symlink_inode_operations;
fs/reiserfs/inode.c:		inode->i_mapping->a_ops = &reiserfs_address_space_operations;
fs/reiserfs/inode.c:		inode->i_blocks = 0;
fs/reiserfs/inode.c:		inode->i_op = &reiserfs_special_inode_operations;
fs/reiserfs/inode.c:		init_special_inode(inode, inode->i_mode, new_decode_dev(rdev));
fs/reiserfs/inode.c:	set_sd_v2_mode(sd_v2, inode->i_mode);
fs/reiserfs/inode.c:	set_sd_v2_nlink(sd_v2, inode->i_nlink);
fs/reiserfs/inode.c:	set_sd_v2_mtime(sd_v2, inode->i_mtime.tv_sec);
fs/reiserfs/inode.c:	set_sd_v2_atime(sd_v2, inode->i_atime.tv_sec);
fs/reiserfs/inode.c:	set_sd_v2_ctime(sd_v2, inode->i_ctime.tv_sec);
fs/reiserfs/inode.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
fs/reiserfs/inode.c:		set_sd_v2_rdev(sd_v2, new_encode_dev(inode->i_rdev));
fs/reiserfs/inode.c:		set_sd_v2_generation(sd_v2, inode->i_generation);
fs/reiserfs/inode.c:	set_sd_v1_mode(sd_v1, inode->i_mode);
fs/reiserfs/inode.c:	set_sd_v1_nlink(sd_v1, inode->i_nlink);
fs/reiserfs/inode.c:	set_sd_v1_atime(sd_v1, inode->i_atime.tv_sec);
fs/reiserfs/inode.c:	set_sd_v1_ctime(sd_v1, inode->i_ctime.tv_sec);
fs/reiserfs/inode.c:	set_sd_v1_mtime(sd_v1, inode->i_mtime.tv_sec);
fs/reiserfs/inode.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
fs/reiserfs/inode.c:		set_sd_v1_rdev(sd_v1, new_encode_dev(inode->i_rdev));
fs/reiserfs/inode.c:		reiserfs_panic(inode->i_sb, "vs-13065", "key %k, found item %h",
fs/reiserfs/inode.c:		retval = search_item(inode->i_sb, &key, &path);
fs/reiserfs/inode.c:			reiserfs_error(inode->i_sb, "vs-13050",
fs/reiserfs/inode.c:			if (inode->i_nlink == 0) {
fs/reiserfs/inode.c:				/*reiserfs_warning (inode->i_sb, "vs-13050: reiserfs_update_sd: i_nlink == 0, stat data not found"); */
fs/reiserfs/inode.c:			reiserfs_warning(inode->i_sb, "vs-13060",
fs/reiserfs/inode.c:					 INODE_PKEY(inode), inode->i_nlink,
fs/reiserfs/inode.c:		fs_gen = get_generation(inode->i_sb);
fs/reiserfs/inode.c:		reiserfs_prepare_for_journal(inode->i_sb, bh, 1);
fs/reiserfs/inode.c:		if (fs_changed(fs_gen, inode->i_sb)
fs/reiserfs/inode.c:			reiserfs_restore_prepared_buffer(inode->i_sb, bh);
fs/reiserfs/inode.c:	inode->i_ino = args->objectid;
fs/reiserfs/inode.c:	key.on_disk_key.k_objectid = inode->i_ino;
fs/reiserfs/inode.c:	retval = search_item(inode->i_sb, &key, &path_to_sd);
fs/reiserfs/inode.c:		reiserfs_error(inode->i_sb, "vs-13070",
fs/reiserfs/inode.c:	if ((inode->i_nlink == 0) &&
fs/reiserfs/inode.c:	    !REISERFS_SB(inode->i_sb)->s_is_unlinked_ok) {
fs/reiserfs/inode.c:		reiserfs_warning(inode->i_sb, "vs-13075",
fs/reiserfs/inode.c:	return (inode->i_ino == args->objectid) &&
fs/reiserfs/inode.c:	if (inode->i_state & I_NEW) {
fs/reiserfs/inode.c:	    generation != inode->i_generation) {
fs/reiserfs/inode.c:	data[0] = inode->i_ino;
fs/reiserfs/inode.c:	data[2] = inode->i_generation;
fs/reiserfs/inode.c:	if (inode->i_sb->s_flags & MS_RDONLY)
fs/reiserfs/inode.c:		reiserfs_write_lock(inode->i_sb);
fs/reiserfs/inode.c:		if (!journal_begin(&th, inode->i_sb, jbegin_count)) {
fs/reiserfs/inode.c:			journal_end_sync(&th, inode->i_sb, jbegin_count);
fs/reiserfs/inode.c:		reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/inode.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/inode.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/inode.c:	args.objectid = inode->i_ino = le32_to_cpu(ih.ih_key.k_objectid);
fs/reiserfs/inode.c:		inode->i_generation = le32_to_cpu(INODE_PKEY(dir)->k_objectid);
fs/reiserfs/inode.c:		inode->i_generation =
fs/reiserfs/inode.c:		inode->i_generation = ++event;
fs/reiserfs/inode.c:	if (S_ISLNK(inode->i_mode))
fs/reiserfs/inode.c:		inode->i_flags &= ~(S_IMMUTABLE | S_APPEND);
fs/reiserfs/inode.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
fs/reiserfs/inode.c:	inode->i_size = i_size;
fs/reiserfs/inode.c:	inode->i_blocks = 0;
fs/reiserfs/inode.c:	inode->i_bytes = 0;
fs/reiserfs/inode.c:		inode2sd_v1(&sd, inode, inode->i_size);
fs/reiserfs/inode.c:		inode2sd(&sd, inode, inode->i_size);
fs/reiserfs/inode.c:	if (reiserfs_posixacl(inode->i_sb)) {
fs/reiserfs/inode.c:	} else if (inode->i_sb->s_flags & MS_POSIXACL) {
fs/reiserfs/inode.c:		reiserfs_warning(inode->i_sb, "jdm-13090",
fs/reiserfs/inode.c:		inode->i_flags |= S_PRIVATE;
fs/reiserfs/inode.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/inode.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/inode.c:	inode->i_flags |= S_NOQUOTA;
fs/reiserfs/inode.c:	unsigned long index = (inode->i_size - 1) >> PAGE_CACHE_SHIFT;
fs/reiserfs/inode.c:	unsigned long blocksize = inode->i_sb->s_blocksize;
fs/reiserfs/inode.c:	unsigned long offset = (inode->i_size) & (PAGE_CACHE_SIZE - 1);
fs/reiserfs/inode.c:	/* we know that we are only called with inode->i_size > 0.
fs/reiserfs/inode.c:	page = grab_cache_page(inode->i_mapping, index);
fs/reiserfs/inode.c:		reiserfs_error(inode->i_sb, "clm-6000",
fs/reiserfs/inode.c:	unsigned long offset = inode->i_size & (PAGE_CACHE_SIZE - 1);
fs/reiserfs/inode.c:	unsigned blocksize = inode->i_sb->s_blocksize;
fs/reiserfs/inode.c:	lock_depth = reiserfs_write_lock_once(inode->i_sb);
fs/reiserfs/inode.c:	if (inode->i_size > 0) {
fs/reiserfs/inode.c:				reiserfs_error(inode->i_sb, "clm-6001",
fs/reiserfs/inode.c:	error = journal_begin(&th, inode->i_sb,
fs/reiserfs/inode.c:	    journal_end(&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT * 2 + 1);
fs/reiserfs/inode.c:	reiserfs_write_unlock_once(inode->i_sb, lock_depth);
fs/reiserfs/inode.c:	reiserfs_write_unlock_once(inode->i_sb, lock_depth);
fs/reiserfs/inode.c:	loff_t byte_offset = ((loff_t)block << inode->i_sb->s_blocksize_bits)+1;
fs/reiserfs/inode.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/inode.c:	retval = search_for_position_by_key(inode->i_sb, &key, &path);
fs/reiserfs/inode.c:			reiserfs_warning(inode->i_sb, "clm-6002",
fs/reiserfs/inode.c:		fs_gen = get_generation(inode->i_sb);
fs/reiserfs/inode.c:			retval = journal_begin(&th, inode->i_sb, jbegin_count);
fs/reiserfs/inode.c:			if (fs_changed(fs_gen, inode->i_sb)
fs/reiserfs/inode.c:				reiserfs_restore_prepared_buffer(inode->i_sb,
fs/reiserfs/inode.c:		reiserfs_prepare_for_journal(inode->i_sb, bh, 1);
fs/reiserfs/inode.c:		if (fs_changed(fs_gen, inode->i_sb)
fs/reiserfs/inode.c:			reiserfs_restore_prepared_buffer(inode->i_sb, bh);
fs/reiserfs/inode.c:		journal_mark_dirty(&th, inode->i_sb, bh);
fs/reiserfs/inode.c:		    (byte_offset + bytes_copied) < inode->i_size) {
fs/reiserfs/inode.c:		reiserfs_warning(inode->i_sb, "clm-6003",
fs/reiserfs/inode.c:				 "bad item inode %lu", inode->i_ino);
fs/reiserfs/inode.c:		int err = journal_end(&th, inode->i_sb, jbegin_count);
fs/reiserfs/inode.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/inode.c:	unsigned long end_index = inode->i_size >> PAGE_CACHE_SHIFT;
fs/reiserfs/inode.c:	struct super_block *s = inode->i_sb;
fs/reiserfs/inode.c:		last_offset = inode->i_size & (PAGE_CACHE_SIZE - 1);
fs/reiserfs/inode.c:	last_block = (i_size_read(inode) - 1) >> inode->i_blkbits;
fs/reiserfs/inode.c:	reiserfs_wait_on_write_block(inode->i_sb);
fs/reiserfs/inode.c:	truncate_inode_pages(inode->i_mapping, inode->i_size);
fs/reiserfs/inode.c: 	    (pos & (inode->i_sb->s_blocksize - 1)) == 0) {
fs/reiserfs/inode.c:	reiserfs_wait_on_write_block(inode->i_sb);
fs/reiserfs/inode.c:	if (reiserfs_transaction_running(inode->i_sb)) {
fs/reiserfs/inode.c:	if (ret && reiserfs_transaction_running(inode->i_sb)) {
fs/reiserfs/inode.c:				reiserfs_write_lock(inode->i_sb);
fs/reiserfs/inode.c:				reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/inode.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/inode.c:	reiserfs_wait_on_write_block(inode->i_sb);
fs/reiserfs/inode.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/inode.c:	if (reiserfs_transaction_running(inode->i_sb)) {
fs/reiserfs/inode.c:	if (ret && reiserfs_transaction_running(inode->i_sb)) {
fs/reiserfs/inode.c:				reiserfs_write_lock(inode->i_sb);
fs/reiserfs/inode.c:				reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/inode.c:	reiserfs_wait_on_write_block(inode->i_sb);
fs/reiserfs/inode.c:	if (reiserfs_transaction_running(inode->i_sb))
fs/reiserfs/inode.c:	if (pos + copied > inode->i_size) {
fs/reiserfs/inode.c:		lock_depth = reiserfs_write_lock_once(inode->i_sb);
fs/reiserfs/inode.c:		if ((have_large_tails(inode->i_sb)
fs/reiserfs/inode.c:		     && inode->i_size > i_block_size(inode) * 4)
fs/reiserfs/inode.c:		    || (have_small_tails(inode->i_sb)
fs/reiserfs/inode.c:			&& inode->i_size > i_block_size(inode)))
fs/reiserfs/inode.c:		ret = journal_begin(&myth, inode->i_sb, 1);
fs/reiserfs/inode.c:		inode->i_size = pos + copied;
fs/reiserfs/inode.c:		ret = journal_end(&myth, inode->i_sb, 1);
fs/reiserfs/inode.c:			lock_depth = reiserfs_write_lock_once(inode->i_sb);
fs/reiserfs/inode.c:		reiserfs_write_unlock_once(inode->i_sb, lock_depth);
fs/reiserfs/inode.c:	if (pos + len > inode->i_size)
fs/reiserfs/inode.c:	reiserfs_write_unlock_once(inode->i_sb, lock_depth);
fs/reiserfs/inode.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/inode.c:	reiserfs_wait_on_write_block(inode->i_sb);
fs/reiserfs/inode.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/inode.c:	if (reiserfs_transaction_running(inode->i_sb)) {
fs/reiserfs/inode.c:	if (pos > inode->i_size) {
fs/reiserfs/inode.c:		if ((have_large_tails(inode->i_sb)
fs/reiserfs/inode.c:		     && inode->i_size > i_block_size(inode) * 4)
fs/reiserfs/inode.c:		    || (have_small_tails(inode->i_sb)
fs/reiserfs/inode.c:			&& inode->i_size > i_block_size(inode)))
fs/reiserfs/inode.c:		ret = journal_begin(&myth, inode->i_sb, 1);
fs/reiserfs/inode.c:		inode->i_size = pos;
fs/reiserfs/inode.c:		ret = journal_end(&myth, inode->i_sb, 1);
fs/reiserfs/inode.c:	if (reiserfs_attrs(inode->i_sb)) {
fs/reiserfs/inode.c:			inode->i_flags |= S_SYNC;
fs/reiserfs/inode.c:			inode->i_flags &= ~S_SYNC;
fs/reiserfs/inode.c:			inode->i_flags |= S_IMMUTABLE;
fs/reiserfs/inode.c:			inode->i_flags &= ~S_IMMUTABLE;
fs/reiserfs/inode.c:			inode->i_flags |= S_APPEND;
fs/reiserfs/inode.c:			inode->i_flags &= ~S_APPEND;
fs/reiserfs/inode.c:			inode->i_flags |= S_NOATIME;
fs/reiserfs/inode.c:			inode->i_flags &= ~S_NOATIME;
fs/reiserfs/inode.c:	if (reiserfs_attrs(inode->i_sb)) {
fs/reiserfs/inode.c:		if (inode->i_flags & S_IMMUTABLE)
fs/reiserfs/inode.c:		if (inode->i_flags & S_SYNC)
fs/reiserfs/inode.c:		if (inode->i_flags & S_NOATIME)
fs/reiserfs/inode.c:	struct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);
fs/reiserfs/inode.c:		    && jl != SB_JOURNAL(inode->i_sb)->j_current_jl)
fs/reiserfs/inode.c:	struct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);
fs/reiserfs/inode.c:	depth = reiserfs_write_lock_once(inode->i_sb);
fs/reiserfs/inode.c:		if (attr->ia_size > inode->i_size) {
fs/reiserfs/inode.c:				err = journal_begin(&th, inode->i_sb, 4);
fs/reiserfs/inode.c:					err = journal_end(&th, inode->i_sb, 4);
fs/reiserfs/inode.c:	if ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||
fs/reiserfs/inode.c:	    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {
fs/reiserfs/inode.c:		    (REISERFS_QUOTA_INIT_BLOCKS(inode->i_sb) +
fs/reiserfs/inode.c:		     REISERFS_QUOTA_DEL_BLOCKS(inode->i_sb)) +
fs/reiserfs/inode.c:		error = journal_begin(&th, inode->i_sb, jbegin_count);
fs/reiserfs/inode.c:		reiserfs_write_unlock_once(inode->i_sb, depth);
fs/reiserfs/inode.c:		depth = reiserfs_write_lock_once(inode->i_sb);
fs/reiserfs/inode.c:			journal_end(&th, inode->i_sb, jbegin_count);
fs/reiserfs/inode.c:			inode->i_uid = attr->ia_uid;
fs/reiserfs/inode.c:			inode->i_gid = attr->ia_gid;
fs/reiserfs/inode.c:		error = journal_end(&th, inode->i_sb, jbegin_count);
fs/reiserfs/inode.c:	reiserfs_write_unlock_once(inode->i_sb, depth);
fs/reiserfs/inode.c:	depth = reiserfs_write_lock_once(inode->i_sb);
fs/reiserfs/inode.c:	if (!error && reiserfs_posixacl(inode->i_sb)) {
fs/reiserfs/inode.c:	reiserfs_write_unlock_once(inode->i_sb, depth);
fs/reiserfs/xattr_security.c:	if (sec->length && reiserfs_xattrs_initialized(inode->i_sb)) {
fs/reiserfs/procfs.c:		loff_t size = sb_info->oidmap.mapf->f_path.dentry->d_inode->i_size;
fs/reiserfs/super.c:		if (!truncate && inode->i_nlink) {
fs/reiserfs/super.c:		if (truncate && S_ISDIR(inode->i_mode)) {
fs/reiserfs/super.c:				      INODE_PKEY(inode), inode->i_size);
fs/reiserfs/super.c:	       (long)inode->i_ino);
fs/reiserfs/super.c:	       (long)inode->i_ino);
fs/reiserfs/super.c:	key.on_disk_key.k_objectid = inode->i_ino;
fs/reiserfs/super.c:		set_cpu_key_k_offset(&key, 1 + inode->i_sb->s_blocksize);
fs/reiserfs/super.c:				  1 + inode->i_sb->s_blocksize, TYPE_DIRECT,
fs/reiserfs/super.c:		if (S_ISDIR(inode->i_mode))
fs/reiserfs/super.c:			reiserfs_warning(inode->i_sb, "green-2102",
fs/reiserfs/super.c:	retval = search_item(inode->i_sb, &key, &path);
fs/reiserfs/super.c:			reiserfs_error(inode->i_sb, "vs-2100",
fs/reiserfs/super.c:			reiserfs_error(inode->i_sb, "vs-2120",
fs/reiserfs/super.c:	err = journal_begin(&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);
fs/reiserfs/super.c:				    1 + inode->i_sb->s_blocksize);
fs/reiserfs/super.c:		reiserfs_release_objectid(&th, inode->i_ino);
fs/reiserfs/super.c:	return journal_end(&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);
fs/reiserfs/super.c:	call_rcu(&inode->i_rcu, reiserfs_i_callback);
fs/reiserfs/super.c:	if (inode->i_sb->s_flags & MS_RDONLY) {
fs/reiserfs/super.c:		reiserfs_warning(inode->i_sb, "clm-6006",
fs/reiserfs/super.c:				 inode->i_ino);
fs/reiserfs/super.c:	lock_depth = reiserfs_write_lock_once(inode->i_sb);
fs/reiserfs/super.c:	err = journal_begin(&th, inode->i_sb, 1);
fs/reiserfs/super.c:	journal_end(&th, inode->i_sb, 1);
fs/reiserfs/super.c:	reiserfs_write_unlock_once(inode->i_sb, lock_depth);
fs/reiserfs/super.c:				    s->s_bdev->bd_inode->i_size >> s->
fs/reiserfs/super.c:	if (root_inode->i_state & I_NEW) {
fs/reiserfs/super.c:	if (inode->i_size < off + len - towrite)
fs/reiserfs/super.c:	inode->i_version++;
fs/reiserfs/super.c:	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/reiserfs/xattr.h:		ret = _ROUND_UP(xattr_size(size), inode->i_sb->s_blocksize);
fs/reiserfs/xattr.h:		ret >>= inode->i_sb->s_blocksize_bits;
fs/reiserfs/xattr.h:	size_t nblocks = JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);
fs/reiserfs/xattr.h:		nblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);
fs/reiserfs/xattr.h:		if (!REISERFS_SB(inode->i_sb)->xattr_root->d_inode)
fs/reiserfs/xattr.h:			nblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);
fs/reiserfs/dir.c:	err = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/reiserfs/dir.c:	mutex_lock(&inode->i_mutex);
fs/reiserfs/dir.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/dir.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/dir.c:	mutex_unlock(&inode->i_mutex);
fs/reiserfs/dir.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/dir.c:	reiserfs_check_lock_depth(inode->i_sb, "readdir");
fs/reiserfs/dir.c:		    search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry,
fs/reiserfs/dir.c:				    REISERFS_MAX_NAME(inode->i_sb->
fs/reiserfs/dir.c:				reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/dir.c:					reiserfs_write_lock(inode->i_sb);
fs/reiserfs/dir.c:				reiserfs_write_lock(inode->i_sb);
fs/reiserfs/dir.c:		rkey = get_rkey(&path_to_entry, inode->i_sb);
fs/reiserfs/dir.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/stree.c:	struct super_block *sb = inode->i_sb;
fs/reiserfs/stree.c:	struct super_block *sb = inode->i_sb;
fs/reiserfs/stree.c:	if (!S_ISLNK(inode->i_mode) && is_direct_le_ih(q_ih)) {
fs/reiserfs/stree.c:		       quota_cut_bytes, inode->i_uid, head2type(&s_ih));
fs/reiserfs/stree.c:					       quota_cut_bytes, inode->i_uid,
fs/reiserfs/stree.c:	inode->i_size = 0;
fs/reiserfs/stree.c:	struct super_block *sb = inode->i_sb;
fs/reiserfs/stree.c:	BUG_ON(new_file_size != inode->i_size);
fs/reiserfs/stree.c:	if (atomic_read(&inode->i_count) > 1 ||
fs/reiserfs/stree.c:	make_cpu_key(&tail_key, inode, inode->i_size + 1, TYPE_DIRECT, 4);	// !!!!
fs/reiserfs/stree.c:	    (cpu_key_k_offset(&tail_key) & (inode->i_sb->s_blocksize - 1)) - 1;
fs/reiserfs/stree.c:		if (search_for_position_by_key(inode->i_sb, &tail_key, path) ==
fs/reiserfs/stree.c:			reiserfs_panic(inode->i_sb, "vs-5615",
fs/reiserfs/stree.c:	reiserfs_warning(inode->i_sb, "reiserfs-5091", "indirect_to_direct "
fs/reiserfs/stree.c:	struct super_block *sb = inode->i_sb;
fs/reiserfs/stree.c:	init_tb_struct(th, &s_cut_balance, inode->i_sb, path,
fs/reiserfs/stree.c:	if (!S_ISLNK(inode->i_mode) && is_direct_le_ih(p_le_ih)) {
fs/reiserfs/stree.c:	reiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,
fs/reiserfs/stree.c:		       quota_cut_bytes, inode->i_uid, '?');
fs/reiserfs/stree.c:	if (inode->i_nlink)
fs/reiserfs/stree.c:		reiserfs_error(inode->i_sb, "vs-5655", "link count != 0");
fs/reiserfs/stree.c:	    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)
fs/reiserfs/stree.c:	     || S_ISLNK(inode->i_mode)))
fs/reiserfs/stree.c:	if (S_ISDIR(inode->i_mode)) {
fs/reiserfs/stree.c:	new_file_size = inode->i_size;
fs/reiserfs/stree.c:	    search_for_position_by_key(inode->i_sb, &s_item_key,
fs/reiserfs/stree.c:		reiserfs_error(inode->i_sb, "vs-5657",
fs/reiserfs/stree.c:		reiserfs_error(inode->i_sb, "PAP-5660",
fs/reiserfs/stree.c:		    op_bytes_number(p_le_ih, inode->i_sb->s_blocksize);
fs/reiserfs/stree.c:			reiserfs_warning(inode->i_sb, "vs-5665",
fs/reiserfs/stree.c:				inode->i_mtime = CURRENT_TIME_SEC;
fs/reiserfs/stree.c:				inode->i_ctime = CURRENT_TIME_SEC;
fs/reiserfs/stree.c:			err = journal_end(th, inode->i_sb, orig_len_alloc);
fs/reiserfs/stree.c:			err = journal_begin(th, inode->i_sb,
fs/reiserfs/stree.c:		 search_for_position_by_key(inode->i_sb, &s_item_key,
fs/reiserfs/stree.c:		inode->i_mtime = CURRENT_TIME_SEC;
fs/reiserfs/stree.c:		inode->i_ctime = CURRENT_TIME_SEC;
fs/reiserfs/stree.c:	fs_gen = get_generation(inode->i_sb);
fs/reiserfs/stree.c:	reiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,
fs/reiserfs/stree.c:		       pasted_size, inode->i_uid,
fs/reiserfs/stree.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/stree.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/stree.c:	if (fs_changed(fs_gen, inode->i_sb)) {
fs/reiserfs/stree.c:			reiserfs_warning(inode->i_sb, "PAP-5710",
fs/reiserfs/stree.c:	reiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,
fs/reiserfs/stree.c:		       pasted_size, inode->i_uid,
fs/reiserfs/stree.c:		fs_gen = get_generation(inode->i_sb);
fs/reiserfs/stree.c:		if (!S_ISLNK(inode->i_mode) && is_direct_le_ih(ih))
fs/reiserfs/stree.c:			quota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE;
fs/reiserfs/stree.c:		reiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,
fs/reiserfs/stree.c:			       quota_bytes, inode->i_uid, head2type(ih));
fs/reiserfs/stree.c:		reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/stree.c:		reiserfs_write_lock(inode->i_sb);
fs/reiserfs/stree.c:	if (inode && fs_changed(fs_gen, inode->i_sb)) {
fs/reiserfs/stree.c:		       quota_bytes, inode->i_uid, head2type(ih));
fs/reiserfs/xattr_acl.c:	if (!reiserfs_posixacl(inode->i_sb))
fs/reiserfs/xattr_acl.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/xattr_acl.c:	error = journal_begin(&th, inode->i_sb, jcreate_blocks);
fs/reiserfs/xattr_acl.c:		error2 = journal_end(&th, inode->i_sb, jcreate_blocks);
fs/reiserfs/xattr_acl.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/xattr_acl.c: * inode->i_mutex: down
fs/reiserfs/xattr_acl.c: * inode->i_mutex: down
fs/reiserfs/xattr_acl.c:	if (S_ISLNK(inode->i_mode))
fs/reiserfs/xattr_acl.c:			error = posix_acl_equiv_mode(acl, &inode->i_mode);
fs/reiserfs/xattr_acl.c:		if (!S_ISDIR(inode->i_mode))
fs/reiserfs/xattr_acl.c:			inode->i_ctime = CURRENT_TIME_SEC;
fs/reiserfs/xattr_acl.c:	if (S_ISLNK(inode->i_mode))
fs/reiserfs/xattr_acl.c:		inode->i_flags |= S_PRIVATE;
fs/reiserfs/xattr_acl.c:		if (S_ISDIR(inode->i_mode)) {
fs/reiserfs/xattr_acl.c:		err = posix_acl_create(&acl, GFP_NOFS, &inode->i_mode);
fs/reiserfs/xattr_acl.c:		inode->i_mode &= ~current_umask();
fs/reiserfs/xattr_acl.c:		nblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);
fs/reiserfs/xattr_acl.c:	if (S_ISLNK(inode->i_mode))
fs/reiserfs/xattr_acl.c:	    !reiserfs_posixacl(inode->i_sb)) {
fs/reiserfs/xattr_acl.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/xattr_acl.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/xattr_acl.c:	error = posix_acl_chmod(&acl, GFP_NOFS, inode->i_mode);
fs/reiserfs/xattr_acl.c:	depth = reiserfs_write_lock_once(inode->i_sb);
fs/reiserfs/xattr_acl.c:	error = journal_begin(&th, inode->i_sb, size * 2);
fs/reiserfs/xattr_acl.c:		error2 = journal_end(&th, inode->i_sb, size * 2);
fs/reiserfs/xattr_acl.c:	reiserfs_write_unlock_once(inode->i_sb, depth);
fs/reiserfs/file.c:	BUG_ON(!S_ISREG(inode->i_mode));
fs/reiserfs/file.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/file.c:	err = journal_begin(&th, inode->i_sb, 1);
fs/reiserfs/file.c:		err = journal_join_abort(&th, inode->i_sb, 1);
fs/reiserfs/file.c:			reiserfs_warning(inode->i_sb, "clm-9001",
fs/reiserfs/file.c:					 inode->i_ino);
fs/reiserfs/file.c:	err = journal_end(&th, inode->i_sb, 1);
fs/reiserfs/file.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/file.c:	err = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/reiserfs/file.c:	mutex_lock(&inode->i_mutex);
fs/reiserfs/file.c:	BUG_ON(!S_ISREG(inode->i_mode));
fs/reiserfs/file.c:	err = sync_mapping_buffers(inode->i_mapping);
fs/reiserfs/file.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/file.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/file.c:	if (barrier_done != 1 && reiserfs_barrier_flush(inode->i_sb))
fs/reiserfs/file.c:		blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);
fs/reiserfs/file.c:	mutex_unlock(&inode->i_mutex);
fs/reiserfs/file.c:	unsigned long i_size_index = inode->i_size >> PAGE_CACHE_SHIFT;
fs/reiserfs/file.c:	struct super_block *s = inode->i_sb;
fs/reiserfs/file.c:	blocksize = 1 << inode->i_blkbits;
fs/reiserfs/file.c:				if (reiserfs_data_ordered(inode->i_sb) &&
fs/reiserfs/journal.c:	return __add_jh(SB_JOURNAL(inode->i_sb), bh, 1);
fs/reiserfs/journal.c:	return __add_jh(SB_JOURNAL(inode->i_sb), bh, 0);
fs/reiserfs/journal.c:	struct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);
fs/reiserfs/journal.c:	struct super_block *sb = inode->i_sb;
fs/reiserfs/journal.c:		if (journal_list_still_alive(inode->i_sb, id)) {
fs/reiserfs/bitmap.c:			hash = (hint->inode->i_sb->s_blocksize << 3);
fs/reiserfs/bitmap.c:			bm = bmap_hash_id(hint->inode->i_sb, oid);
fs/reiserfs/bitmap.c:			hash = bm * (hint->inode->i_sb->s_blocksize << 3);
fs/reiserfs/bitmap.c:		if (S_ISREG(hint->inode->i_mode)
fs/reiserfs/bitmap.c:		    && hint->inode->i_size >=
fs/reiserfs/bitmap.c:		    preallocmin * hint->inode->i_sb->s_blocksize)
fs/reiserfs/bitmap.c:			       amount_needed, hint->inode->i_uid);
fs/reiserfs/bitmap.c:				       hint->prealloc_size, hint->inode->i_uid);
fs/reiserfs/bitmap.c:					       hint->inode->i_uid);
fs/reiserfs/bitmap.c:			       hint->inode->i_uid);
fs/reiserfs/reiserfs.h:	__le32 s_flags;		/* Right now used only by inode-attributes, if enabled */
fs/reiserfs/reiserfs.h:	if (reiserfs_data_log(inode->i_sb) ||
fs/reiserfs/reiserfs.h:!STORE_TAIL_IN_UNFM_S1(file_size (inode), tail_size(inode), inode->i_sb->s_blocksize):have_small_tails ((inode)->i_sb)?!STORE_TAIL_IN_UNFM_S2(file_size (inode), tail_size(inode), inode->i_sb->s_blocksize):0 )
fs/reiserfs/reiserfs.h:	reiserfs_update_sd_size(th, inode, inode->i_size);
fs/reiserfs/ioctl.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/ioctl.c:		if (S_ISREG(inode->i_mode)) {
fs/reiserfs/ioctl.c:		if (!reiserfs_attrs(inode->i_sb)) {
fs/reiserfs/ioctl.c:			if (!reiserfs_attrs(inode->i_sb)) {
fs/reiserfs/ioctl.c:			    S_ISREG(inode->i_mode)) {
fs/reiserfs/ioctl.c:			inode->i_ctime = CURRENT_TIME_SEC;
fs/reiserfs/ioctl.c:		err = put_user(inode->i_generation, (int __user *)arg);
fs/reiserfs/ioctl.c:		if (get_user(inode->i_generation, (int __user *)arg)) {
fs/reiserfs/ioctl.c:		inode->i_ctime = CURRENT_TIME_SEC;
fs/reiserfs/ioctl.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/ioctl.c:	unsigned long blocksize = inode->i_sb->s_blocksize;
fs/reiserfs/ioctl.c:	if (inode->i_size == 0) {
fs/reiserfs/ioctl.c:	depth = reiserfs_write_lock_once(inode->i_sb);
fs/reiserfs/ioctl.c:	reiserfs_mutex_lock_safe(&inode->i_mutex, inode->i_sb);
fs/reiserfs/ioctl.c:	write_from = inode->i_size & (blocksize - 1);
fs/reiserfs/ioctl.c:	index = inode->i_size >> PAGE_CACHE_SHIFT;
fs/reiserfs/ioctl.c:	mapping = inode->i_mapping;
fs/reiserfs/ioctl.c:	mutex_unlock(&inode->i_mutex);
fs/reiserfs/ioctl.c:	reiserfs_write_unlock_once(inode->i_sb, depth);
fs/reiserfs/tail_conversion.c:	struct super_block *sb = inode->i_sb;
fs/reiserfs/tail_conversion.c:		struct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);
fs/reiserfs/tail_conversion.c:	struct super_block *sb = inode->i_sb;
fs/reiserfs/namei.c:			inode->i_flags |= S_PRIVATE;
fs/reiserfs/namei.c:	if (!S_ISDIR(inode->i_mode) && visible)
fs/reiserfs/namei.c:	inode->i_flags |= S_NOQUOTA;
fs/reiserfs/namei.c:	inode->i_op = &reiserfs_file_inode_operations;
fs/reiserfs/namei.c:	inode->i_fop = &reiserfs_file_operations;
fs/reiserfs/namei.c:	inode->i_mapping->a_ops = &reiserfs_address_space_operations;
fs/reiserfs/namei.c:	inode->i_op = &reiserfs_special_inode_operations;
fs/reiserfs/namei.c:	init_special_inode(inode, inode->i_mode, rdev);
fs/reiserfs/namei.c:	inode->i_op = &reiserfs_dir_inode_operations;
fs/reiserfs/namei.c:	inode->i_fop = &reiserfs_dir_operations;
fs/reiserfs/namei.c:	if (inode->i_size != EMPTY_DIR_SIZE &&
fs/reiserfs/namei.c:	    inode->i_size != EMPTY_DIR_SIZE_V1) {
fs/reiserfs/namei.c:	if (de.de_objectid != inode->i_ino) {
fs/reiserfs/namei.c:	if (inode->i_nlink != 2 && inode->i_nlink != 1)
fs/reiserfs/namei.c:		reiserfs_error(inode->i_sb, "reiserfs-7040",
fs/reiserfs/namei.c:			       inode->i_nlink);
fs/reiserfs/namei.c:	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;
fs/reiserfs/namei.c:	if (de.de_objectid != inode->i_ino) {
fs/reiserfs/namei.c:	if (!inode->i_nlink) {
fs/reiserfs/namei.c:		reiserfs_warning(inode->i_sb, "reiserfs-7042",
fs/reiserfs/namei.c:				 inode->i_ino, inode->i_nlink);
fs/reiserfs/namei.c:	savelink = inode->i_nlink;
fs/reiserfs/namei.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/reiserfs/namei.c:	inode->i_op = &reiserfs_symlink_inode_operations;
fs/reiserfs/namei.c:	inode->i_mapping->a_ops = &reiserfs_address_space_operations;
fs/reiserfs/namei.c:	if (inode->i_nlink >= REISERFS_LINK_MAX) {
fs/reiserfs/namei.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/reiserfs/namei.c:			reiserfs_panic(inode->i_sb, "vs-7042",
fs/reiserfs/namei.c:		return (de->de_objectid == inode->i_ino) ? 1 : 0;
fs/reiserfs/namei.c:	if (retval != NAME_FOUND || old_de.de_objectid != old_inode->i_ino) {
fs/reiserfs/namei.c:	old_inode_mode = old_inode->i_mode;
fs/reiserfs/namei.c:		reiserfs_prepare_for_journal(old_inode->i_sb, old_de.de_bh, 1);
fs/reiserfs/namei.c:		reiserfs_prepare_for_journal(old_inode->i_sb, new_de.de_bh, 1);
fs/reiserfs/namei.c:		if (S_ISDIR(old_inode->i_mode)) {
fs/reiserfs/namei.c:			reiserfs_prepare_for_journal(old_inode->i_sb,
fs/reiserfs/namei.c:			reiserfs_restore_prepared_buffer(old_inode->i_sb,
fs/reiserfs/namei.c:			reiserfs_restore_prepared_buffer(old_inode->i_sb,
fs/reiserfs/namei.c:				reiserfs_restore_prepared_buffer(old_inode->
fs/reiserfs/namei.c:				reiserfs_restore_prepared_buffer(old_inode->
fs/reiserfs/namei.c:				reiserfs_restore_prepared_buffer(old_inode->
fs/reiserfs/namei.c:				reiserfs_restore_prepared_buffer(old_inode->
fs/reiserfs/namei.c:	old_inode->i_ctime = ctime;
fs/reiserfs/namei.c:		if (S_ISDIR(new_dentry_inode->i_mode)) {
fs/reiserfs/namei.c:		new_dentry_inode->i_ctime = ctime;
fs/reiserfs/namei.c:		savelink = new_dentry_inode->i_nlink;
fs/reiserfs/xattr.c:	reiserfs_mutex_lock_nested_safe(&dentry->d_inode->i_mutex,
fs/reiserfs/xattr.c:	mutex_unlock(&dentry->d_inode->i_mutex);
fs/reiserfs/xattr.c:	reiserfs_mutex_lock_nested_safe(&dentry->d_inode->i_mutex,
fs/reiserfs/xattr.c:		dentry->d_inode->i_flags |= S_DEAD;
fs/reiserfs/xattr.c:	mutex_unlock(&dentry->d_inode->i_mutex);
fs/reiserfs/xattr.c:	mutex_lock_nested(&privroot->d_inode->i_mutex, I_MUTEX_XATTR);
fs/reiserfs/xattr.c:	mutex_unlock(&privroot->d_inode->i_mutex);
fs/reiserfs/xattr.c:	xaroot = open_xa_root(inode->i_sb, flags);
fs/reiserfs/xattr.c:		 inode->i_generation);
fs/reiserfs/xattr.c:	mutex_lock_nested(&xaroot->d_inode->i_mutex, I_MUTEX_XATTR);
fs/reiserfs/xattr.c:	mutex_unlock(&xaroot->d_inode->i_mutex);
fs/reiserfs/xattr.c:	WARN_ON_ONCE(!mutex_is_locked(&dbuf->xadir->d_inode->i_mutex));
fs/reiserfs/xattr.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/xattr.c:		reiserfs_write_lock(inode->i_sb);
fs/reiserfs/xattr.c:		reiserfs_write_lock(inode->i_sb);
fs/reiserfs/xattr.c:	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
fs/reiserfs/xattr.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/xattr.c:			if (err == 0 && !S_ISDIR(dentry->d_inode->i_mode))
fs/reiserfs/xattr.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/reiserfs/xattr.c:			     4 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);
fs/reiserfs/xattr.c:		err = journal_begin(&th, inode->i_sb, blocks);
fs/reiserfs/xattr.c:					  &dir->d_parent->d_inode->i_mutex,
fs/reiserfs/xattr.c:					  I_MUTEX_XATTR, inode->i_sb);
fs/reiserfs/xattr.c:			jerror = journal_end(&th, inode->i_sb, blocks);
fs/reiserfs/xattr.c:			mutex_unlock(&dir->d_parent->d_inode->i_mutex);
fs/reiserfs/xattr.c:	if (S_ISDIR(dentry->d_inode->i_mode))
fs/reiserfs/xattr.c:		reiserfs_warning(inode->i_sb, "jdm-20004",
fs/reiserfs/xattr.c:/* inode->i_mutex: down */
fs/reiserfs/xattr.c:		reiserfs_warning(inode->i_sb, "jdm-20007",
fs/reiserfs/xattr.c:	mutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);
fs/reiserfs/xattr.c:	mutex_unlock(&xadir->d_inode->i_mutex);
fs/reiserfs/xattr.c:	struct timespec now = current_fs_time(inode->i_sb);
fs/reiserfs/xattr.c:	if (inode_unhashed(inode) || !inode->i_nlink ||
fs/reiserfs/xattr.c:	    timespec_equal(&inode->i_ctime, &now))
fs/reiserfs/xattr.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/reiserfs/xattr.c:	mutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);
fs/reiserfs/xattr.c:		reiserfs_write_lock(inode->i_sb);
fs/reiserfs/xattr.c:		reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/xattr.c:	mutex_unlock(&xadir->d_inode->i_mutex);
fs/reiserfs/xattr.c: * inode->i_mutex: down
fs/reiserfs/xattr.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/xattr.c:		reiserfs_write_lock(inode->i_sb);
fs/reiserfs/xattr.c:		reiserfs_write_lock(inode->i_sb);
fs/reiserfs/xattr.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/xattr.c:			.ia_ctime = current_fs_time(inode->i_sb),
fs/reiserfs/xattr.c:		reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/xattr.c:		mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);
fs/reiserfs/xattr.c:		reiserfs_write_lock(inode->i_sb);
fs/reiserfs/xattr.c:		mutex_unlock(&dentry->d_inode->i_mutex);
fs/reiserfs/xattr.c:	reiserfs_write_lock(inode->i_sb);
fs/reiserfs/xattr.c:	error = journal_begin(&th, inode->i_sb, jbegin_count);
fs/reiserfs/xattr.c:		reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/xattr.c:	error2 = journal_end(&th, inode->i_sb, jbegin_count);
fs/reiserfs/xattr.c:	reiserfs_write_unlock(inode->i_sb);
fs/reiserfs/xattr.c: * inode->i_mutex: down
fs/reiserfs/xattr.c:				reiserfs_warning(inode->i_sb, "jdm-20001",
fs/reiserfs/xattr.c:		reiserfs_warning(inode->i_sb, "jdm-20002",
fs/reiserfs/xattr.c: * dentry->d_inode->i_mutex down
fs/reiserfs/xattr.c: * dentry->d_inode->i_mutex down
fs/reiserfs/xattr.c:	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
fs/reiserfs/xattr.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/reiserfs/xattr.c:	WARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));
fs/reiserfs/xattr.c:	dentry->d_inode->i_flags |= S_PRIVATE;
fs/reiserfs/xattr.c:	reiserfs_mutex_lock_safe(&s->s_root->d_inode->i_mutex, s);
fs/reiserfs/xattr.c:			dentry->d_inode->i_flags |= S_PRIVATE;
fs/reiserfs/xattr.c:	mutex_unlock(&s->s_root->d_inode->i_mutex);
fs/reiserfs/xattr.c:		reiserfs_mutex_lock_safe(&s->s_root->d_inode->i_mutex, s);
fs/reiserfs/xattr.c:		mutex_unlock(&s->s_root->d_inode->i_mutex);
fs/reiserfs/xattr.c:		reiserfs_mutex_lock_safe(&privroot->d_inode->i_mutex, s);
fs/reiserfs/xattr.c:		mutex_unlock(&privroot->d_inode->i_mutex);
fs/sync.c:	filemap_fdatawrite(bdev->bd_inode->i_mapping);
fs/sync.c:	filemap_fdatawait(bdev->bd_inode->i_mapping);
fs/sync.c:	i_mode = f.file->f_path.dentry->d_inode->i_mode;
fs/fscache/page.c:	struct address_space *mapping = inode->i_mapping;
fs/cifs/inode.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/inode.c:	switch (inode->i_mode & S_IFMT) {
fs/cifs/inode.c:		inode->i_op = &cifs_file_inode_ops;
fs/cifs/inode.c:				inode->i_fop = &cifs_file_direct_nobrl_ops;
fs/cifs/inode.c:				inode->i_fop = &cifs_file_direct_ops;
fs/cifs/inode.c:				inode->i_fop = &cifs_file_strict_nobrl_ops;
fs/cifs/inode.c:				inode->i_fop = &cifs_file_strict_ops;
fs/cifs/inode.c:			inode->i_fop = &cifs_file_nobrl_ops;
fs/cifs/inode.c:			inode->i_fop = &cifs_file_ops;
fs/cifs/inode.c:			inode->i_data.a_ops = &cifs_addr_ops_smallbuf;
fs/cifs/inode.c:			inode->i_data.a_ops = &cifs_addr_ops;
fs/cifs/inode.c:			inode->i_op = &cifs_dfs_referral_inode_operations;
fs/cifs/inode.c:			inode->i_op = &cifs_dir_inode_ops;
fs/cifs/inode.c:			inode->i_fop = &cifs_dir_ops;
fs/cifs/inode.c:		inode->i_op = &cifs_symlink_inode_ops;
fs/cifs/inode.c:		init_special_inode(inode, inode->i_mode, inode->i_rdev);
fs/cifs/inode.c:	if (inode->i_state & I_NEW) {
fs/cifs/inode.c:	if (timespec_equal(&inode->i_mtime, &fattr->cf_mtime) &&
fs/cifs/inode.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/inode.c:	spin_lock(&inode->i_lock);
fs/cifs/inode.c:	inode->i_atime = fattr->cf_atime;
fs/cifs/inode.c:	inode->i_mtime = fattr->cf_mtime;
fs/cifs/inode.c:	inode->i_ctime = fattr->cf_ctime;
fs/cifs/inode.c:	inode->i_rdev = fattr->cf_rdev;
fs/cifs/inode.c:	inode->i_uid = fattr->cf_uid;
fs/cifs/inode.c:	inode->i_gid = fattr->cf_gid;
fs/cifs/inode.c:	if (inode->i_state & I_NEW ||
fs/cifs/inode.c:		inode->i_mode = fattr->cf_mode;
fs/cifs/inode.c:		inode->i_blocks = (512 - 1 + fattr->cf_bytes) >> 9;
fs/cifs/inode.c:	spin_unlock(&inode->i_lock);
fs/cifs/inode.c:		inode->i_flags |= S_AUTOMOUNT;
fs/cifs/inode.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/inode.c:		cifs_create_dfs_fattr(&fattr, inode->i_sb);
fs/cifs/inode.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/inode.c:		cifs_create_dfs_fattr(&fattr, inode->i_sb);
fs/cifs/inode.c:	if ((inode->i_mode & S_IFMT) != (fattr->cf_mode & S_IFMT))
fs/cifs/inode.c:	if (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry))
fs/cifs/inode.c:	spin_lock(&inode->i_lock);
fs/cifs/inode.c:	hlist_for_each_entry(dentry, p, &inode->i_dentry, d_alias) {
fs/cifs/inode.c:			spin_unlock(&inode->i_lock);
fs/cifs/inode.c:	spin_unlock(&inode->i_lock);
fs/cifs/inode.c:			inode->i_flags |= S_NOATIME | S_NOCMTIME;
fs/cifs/inode.c:		if (inode->i_state & I_NEW) {
fs/cifs/inode.c:			inode->i_ino = hash;
fs/cifs/inode.c:			if (S_ISREG(inode->i_mode))
fs/cifs/inode.c:				inode->i_data.backing_dev_info = sb->s_bdi;
fs/cifs/inode.c:		spin_lock(&inode->i_lock);
fs/cifs/inode.c:		inode->i_mode |= S_IFDIR;
fs/cifs/inode.c:		inode->i_op = &cifs_ipc_inode_ops;
fs/cifs/inode.c:		inode->i_fop = &simple_dir_operations;
fs/cifs/inode.c:		inode->i_uid = cifs_sb->mnt_uid;
fs/cifs/inode.c:		inode->i_gid = cifs_sb->mnt_gid;
fs/cifs/inode.c:		spin_unlock(&inode->i_lock);
fs/cifs/inode.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/inode.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/inode.c:	spin_lock(&inode->i_lock);
fs/cifs/inode.c:	if (inode->i_nlink > 0)
fs/cifs/inode.c:	spin_unlock(&inode->i_lock);
fs/cifs/inode.c:		origattr = cifs_inode->cifsAttrs;
fs/cifs/inode.c:		cifs_inode->time = 0;	/* will force revalidate to get info
fs/cifs/inode.c:		inode->i_ctime = current_fs_time(sb);
fs/cifs/inode.c:	if (inode->i_nlink < 2)
fs/cifs/inode.c:			inode->i_mode = (mode | S_IFDIR);
fs/cifs/inode.c:			inode->i_uid = current_fsuid();
fs/cifs/inode.c:			if (inode->i_mode & S_ISGID)
fs/cifs/inode.c:				inode->i_gid = parent->i_gid;
fs/cifs/inode.c:				inode->i_gid = current_fsgid();
fs/cifs/inode.c:	cifs_fill_uniqueid(inode->i_sb, &fattr);
fs/cifs/inode.c:	newinode = cifs_iget(inode->i_sb, &fattr);
fs/cifs/inode.c:	if (newinode->i_nlink != 2)
fs/cifs/inode.c:		cFYI(1, "unexpected number of links %d", newinode->i_nlink);
fs/cifs/inode.c:	cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/inode.c:	cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/inode.c:		spin_lock(&direntry->d_inode->i_lock);
fs/cifs/inode.c:		spin_unlock(&direntry->d_inode->i_lock);
fs/cifs/inode.c:	direntry->d_inode->i_ctime = inode->i_ctime = inode->i_mtime =
fs/cifs/inode.c:		current_fs_time(inode->i_sb);
fs/cifs/inode.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/inode.c:	    S_ISREG(inode->i_mode) && inode->i_nlink != 1)
fs/cifs/inode.c:	if (inode->i_mapping && inode->i_mapping->nrpages != 0) {
fs/cifs/inode.c:		rc = invalidate_inode_pages2(inode->i_mapping);
fs/cifs/inode.c:		 "%ld jiffies %ld", full_path, inode, inode->i_count.counter,
fs/cifs/inode.c:	if (!CIFS_I(inode)->clientCanCacheRead && inode->i_mapping &&
fs/cifs/inode.c:	    inode->i_mapping->nrpages != 0) {
fs/cifs/inode.c:		rc = filemap_fdatawait(inode->i_mapping);
fs/cifs/inode.c:			mapping_set_error(inode->i_mapping, rc);
fs/cifs/inode.c:	spin_lock(&inode->i_lock);
fs/cifs/inode.c:	oldsize = inode->i_size;
fs/cifs/inode.c:	spin_unlock(&inode->i_lock);
fs/cifs/inode.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/inode.c:		cifs_truncate_page(inode->i_mapping, inode->i_size);
fs/cifs/inode.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/inode.c:	rc = filemap_write_and_wait(inode->i_mapping);
fs/cifs/inode.c:	mapping_set_error(inode->i_mapping, rc);
fs/cifs/inode.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/inode.c:	rc = filemap_write_and_wait(inode->i_mapping);
fs/cifs/inode.c:	mapping_set_error(inode->i_mapping, rc);
fs/cifs/inode.c:				attrs->ia_mode = inode->i_mode & ~S_IWUGO;
fs/cifs/inode.c:				if (S_ISDIR(inode->i_mode))
fs/cifs/inode.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/smb2misc.c:	if (cinode->clientCanCacheAll)
fs/cifs/smb2misc.c:	else if (cinode->clientCanCacheRead)
fs/cifs/smb2misc.c:				if (memcmp(cinode->lease_key, rsp->LeaseKey,
fs/cifs/smb2misc.c:				if (!cinode->clientCanCacheAll &&
fs/cifs/misc.c:		cinode->clientCanCacheAll = true;
fs/cifs/misc.c:		cinode->clientCanCacheRead = true;
fs/cifs/misc.c:		     &cinode->vfs_inode);
fs/cifs/misc.c:		cinode->clientCanCacheAll = false;
fs/cifs/misc.c:		cinode->clientCanCacheRead = true;
fs/cifs/misc.c:		    &cinode->vfs_inode);
fs/cifs/misc.c:		cinode->clientCanCacheAll = false;
fs/cifs/misc.c:		cinode->clientCanCacheRead = false;
fs/cifs/smb2file.c:		cinode->clientCanCacheAll = true;
fs/cifs/smb2file.c:		cinode->clientCanCacheRead = true;
fs/cifs/smb2file.c:		     &cinode->vfs_inode);
fs/cifs/smb2file.c:		cinode->clientCanCacheAll = false;
fs/cifs/smb2file.c:		cinode->clientCanCacheRead = true;
fs/cifs/smb2file.c:		    &cinode->vfs_inode);
fs/cifs/smb2file.c:		cinode->clientCanCacheAll = false;
fs/cifs/smb2file.c:		cinode->clientCanCacheRead = false;
fs/cifs/smb2file.c:	down_write(&cinode->lock_sem);
fs/cifs/smb2file.c:		if (cinode->can_cache_brlcks) {
fs/cifs/smb2file.c:	up_write(&cinode->lock_sem);
fs/cifs/smb2file.c:	list_for_each_entry(fdlocks, &cinode->llist, llist) {
fs/cifs/readdir.c:	struct super_block *sb = parent->d_inode->i_sb;
fs/cifs/readdir.c:		     file->f_path.dentry->d_inode->i_ino, DT_DIR) < 0) {
fs/cifs/fscache.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/fscache.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/link.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/link.c:			spin_lock(&old_file->d_inode->i_lock);
fs/cifs/link.c:			spin_unlock(&old_file->d_inode->i_lock);
fs/cifs/link.c:			/* old_file->d_inode->i_ctime = CURRENT_TIME; */
fs/cifs/link.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/link.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/link.c:						      inode->i_sb, xid);
fs/cifs/link.c:						 inode->i_sb, xid, NULL);
fs/cifs/dir.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/dir.c:		rc = cifs_posix_open(full_path, &newinode, inode->i_sb, mode,
fs/cifs/dir.c:			if (!S_ISREG(newinode->i_mode)) {
fs/cifs/dir.c:			if (inode->i_mode & S_ISGID)
fs/cifs/dir.c:				args.gid = (__u64) inode->i_gid;
fs/cifs/dir.c:		rc = cifs_get_inode_info_unix(&newinode, full_path, inode->i_sb,
fs/cifs/dir.c:		rc = cifs_get_inode_info(&newinode, full_path, buf, inode->i_sb,
fs/cifs/dir.c:				newinode->i_mode = mode;
fs/cifs/dir.c:				newinode->i_uid = current_fsuid();
fs/cifs/dir.c:				if (inode->i_mode & S_ISGID)
fs/cifs/dir.c:					newinode->i_gid = inode->i_gid;
fs/cifs/dir.c:					newinode->i_gid = current_fsgid();
fs/cifs/dir.c:	tlink = cifs_sb_tlink(CIFS_SB(inode->i_sb));
fs/cifs/dir.c:	tlink = cifs_sb_tlink(CIFS_SB(inode->i_sb));
fs/cifs/dir.c:	cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/dir.c:						inode->i_sb, xid);
fs/cifs/dir.c:	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
fs/cifs/dir.c:					      parent_dir_inode->i_sb, xid);
fs/cifs/dir.c:				parent_dir_inode->i_sb, xid, NULL);
fs/cifs/dir.c:	struct nls_table *codepage = CIFS_SB(pinode->i_sb)->local_nls;
fs/cifs/cifsfs.c:	cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/cifsfs.c:	cifs_inode->cifsAttrs = 0x20;	/* default */
fs/cifs/cifsfs.c:	cifs_inode->time = 0;
fs/cifs/cifsfs.c:	cifs_inode->delete_pending = false;
fs/cifs/cifsfs.c:	cifs_inode->invalid_mapping = false;
fs/cifs/cifsfs.c:	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
fs/cifs/cifsfs.c:	cifs_inode->server_eof = 0;
fs/cifs/cifsfs.c:	cifs_inode->uniqueid = 0;
fs/cifs/cifsfs.c:	cifs_inode->createtime = 0;
fs/cifs/cifsfs.c:	get_random_bytes(cifs_inode->lease_key, SMB2_LEASE_KEY_SIZE);
fs/cifs/cifsfs.c:	/* cifs_inode->vfs_inode.i_flags = S_NOATIME | S_NOCMTIME; */
fs/cifs/cifsfs.c:	INIT_LIST_HEAD(&cifs_inode->openFileList);
fs/cifs/cifsfs.c:	INIT_LIST_HEAD(&cifs_inode->llist);
fs/cifs/cifsfs.c:	return &cifs_inode->vfs_inode;
fs/cifs/cifsfs.c:	call_rcu(&inode->i_rcu, cifs_i_callback);
fs/cifs/cifsfs.c:	truncate_inode_pages(&inode->i_data, 0);
fs/cifs/cifsfs.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/cifsfs.c:	rc = filemap_fdatawrite(inode->i_mapping);
fs/cifs/cifsfs.c:		if (!CIFS_I(inode)->clientCanCacheRead && inode->i_mapping &&
fs/cifs/cifsfs.c:		    inode->i_mapping->nrpages != 0) {
fs/cifs/cifsfs.c:			rc = filemap_fdatawait(inode->i_mapping);
fs/cifs/cifsfs.c:				mapping_set_error(inode->i_mapping, rc);
fs/cifs/cifsfs.c:	if (!(S_ISREG(inode->i_mode)))
fs/cifs/smb2inode.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/smb2ops.c:	cinode->can_cache_brlcks = cinode->clientCanCacheAll;
fs/cifs/smb2ops.c:		return SMB2_lease_break(0, tcon, cinode->lease_key,
fs/cifs/smb2ops.c:				 cinode->clientCanCacheRead ? 1 : 0);
fs/cifs/cifs_dfs_ref.c:	cifs_sb = CIFS_SB(mntpt->d_inode->i_sb);
fs/cifs/file.c:		rc = cifs_get_inode_info_unix(&inode, full_path, inode->i_sb,
fs/cifs/file.c:		rc = cifs_get_inode_info(&inode, full_path, buf, inode->i_sb,
fs/cifs/file.c:	down_read(&cinode->lock_sem);
fs/cifs/file.c:	list_for_each_entry(cur, &cinode->llist, llist) {
fs/cifs/file.c:	up_read(&cinode->lock_sem);
fs/cifs/file.c:	down_write(&cinode->lock_sem);
fs/cifs/file.c:	list_add(&fdlocks->llist, &cinode->llist);
fs/cifs/file.c:	up_write(&cinode->lock_sem);
fs/cifs/file.c:	cifs_sb_active(inode->i_sb);
fs/cifs/file.c:		list_add(&cfile->flist, &cinode->openFileList);
fs/cifs/file.c:		list_add_tail(&cfile->flist, &cinode->openFileList);
fs/cifs/file.c:	struct super_block *sb = inode->i_sb;
fs/cifs/file.c:	cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/file.c:		rc = cifs_posix_open(full_path, &inode, inode->i_sb,
fs/cifs/file.c:			.mode	= inode->i_mode,
fs/cifs/file.c:	down_write(&cinode->lock_sem);
fs/cifs/file.c:	if (cinode->can_cache_brlcks) {
fs/cifs/file.c:		up_write(&cinode->lock_sem);
fs/cifs/file.c:	up_write(&cinode->lock_sem);
fs/cifs/file.c:	cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/file.c:		rc = cifs_posix_open(full_path, NULL, inode->i_sb,
fs/cifs/file.c:		rc = filemap_write_and_wait(inode->i_mapping);
fs/cifs/file.c:		mapping_set_error(inode->i_mapping, rc);
fs/cifs/file.c:						      inode->i_sb, xid);
fs/cifs/file.c:						 inode->i_sb, xid, NULL);
fs/cifs/file.c:	list_for_each_entry(cur, &cinode->llist, llist) {
fs/cifs/file.c:	down_read(&cinode->lock_sem);
fs/cifs/file.c:	} else if (!cinode->can_cache_brlcks)
fs/cifs/file.c:	up_read(&cinode->lock_sem);
fs/cifs/file.c:	down_write(&cinode->lock_sem);
fs/cifs/file.c:	up_write(&cinode->lock_sem);
fs/cifs/file.c:	down_write(&cinode->lock_sem);
fs/cifs/file.c:	if (!exist && cinode->can_cache_brlcks) {
fs/cifs/file.c:		up_write(&cinode->lock_sem);
fs/cifs/file.c:		up_write(&cinode->lock_sem);
fs/cifs/file.c:		down_write(&cinode->lock_sem);
fs/cifs/file.c:	up_write(&cinode->lock_sem);
fs/cifs/file.c:	down_read(&cinode->lock_sem);
fs/cifs/file.c:	if (flock->fl_type == F_UNLCK && !cinode->can_cache_brlcks) {
fs/cifs/file.c:	up_read(&cinode->lock_sem);
fs/cifs/file.c:	down_write(&cinode->lock_sem);
fs/cifs/file.c:	if (!cinode->can_cache_brlcks) {
fs/cifs/file.c:		up_write(&cinode->lock_sem);
fs/cifs/file.c:	up_write(&cinode->lock_sem);
fs/cifs/file.c:	for (lockp = &inode->i_flock; *lockp != NULL; \
fs/cifs/file.c:	 * added to the list while we are holding cinode->lock_sem that
fs/cifs/file.c:	down_write(&cinode->lock_sem);
fs/cifs/file.c:	if (!cinode->can_cache_brlcks) {
fs/cifs/file.c:		up_write(&cinode->lock_sem);
fs/cifs/file.c:	cinode->can_cache_brlcks = false;
fs/cifs/file.c:	up_write(&cinode->lock_sem);
fs/cifs/file.c:	down_write(&cinode->lock_sem);
fs/cifs/file.c:			if (cinode->can_cache_brlcks) {
fs/cifs/file.c:	up_write(&cinode->lock_sem);
fs/cifs/file.c: * the inode->i_lock held
fs/cifs/file.c:			spin_lock(&dentry->d_inode->i_lock);
fs/cifs/file.c:			spin_unlock(&dentry->d_inode->i_lock);
fs/cifs/file.c:		spin_lock(&dentry->d_inode->i_lock);
fs/cifs/file.c:		if (*offset > dentry->d_inode->i_size)
fs/cifs/file.c:		spin_unlock(&dentry->d_inode->i_lock);
fs/cifs/file.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);
fs/cifs/file.c:	list_for_each_entry(open_file, &cifs_inode->openFileList, flist) {
fs/cifs/file.c:	cifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);
fs/cifs/file.c:	list_for_each_entry(open_file, &cifs_inode->openFileList, flist) {
fs/cifs/file.c:					&cifs_inode->openFileList);
fs/cifs/file.c:		inode->i_atime = inode->i_mtime = current_fs_time(inode->i_sb);
fs/cifs/file.c:		spin_lock(&inode->i_lock);
fs/cifs/file.c:		if (pos > inode->i_size)
fs/cifs/file.c:		spin_unlock(&inode->i_lock);
fs/cifs/file.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/file.c:	rc = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/cifs/file.c:	mutex_lock(&inode->i_mutex);
fs/cifs/file.c:	mutex_unlock(&inode->i_mutex);
fs/cifs/file.c:	rc = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/cifs/file.c:	mutex_lock(&inode->i_mutex);
fs/cifs/file.c:	mutex_unlock(&inode->i_mutex);
fs/cifs/file.c:		rc = filemap_write_and_wait(inode->i_mapping);
fs/cifs/file.c:	spin_lock(&inode->i_lock);
fs/cifs/file.c:	if (cifsi->server_eof > inode->i_size)
fs/cifs/file.c:	spin_unlock(&inode->i_lock);
fs/cifs/file.c:	sb_start_write(inode->i_sb);
fs/cifs/file.c:	down_read(&cinode->lock_sem);
fs/cifs/file.c:		mutex_lock(&inode->i_mutex);
fs/cifs/file.c:		mutex_unlock(&inode->i_mutex);
fs/cifs/file.c:	up_read(&cinode->lock_sem);
fs/cifs/file.c:	sb_end_write(inode->i_sb);
fs/cifs/file.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/file.c:	if (cinode->clientCanCacheAll) {
fs/cifs/file.c:	if (written > 0 && cinode->clientCanCacheRead) {
fs/cifs/file.c:		cinode->clientCanCacheRead = false;
fs/cifs/file.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/file.c:	if (!cinode->clientCanCacheRead)
fs/cifs/file.c:	down_read(&cinode->lock_sem);
fs/cifs/file.c:	up_read(&cinode->lock_sem);
fs/cifs/file.c:	file->f_path.dentry->d_inode->i_atime =
fs/cifs/file.c:		current_fs_time(file->f_path.dentry->d_inode->i_sb);
fs/cifs/file.c:	list_for_each_entry(open_file, &cifs_inode->openFileList, flist) {
fs/cifs/file.c:	if (!cinode->clientCanCacheAll && cinode->clientCanCacheRead &&
fs/cifs/file.c:		cinode->clientCanCacheRead = false;
fs/cifs/file.c:	if (inode && S_ISREG(inode->i_mode)) {
fs/cifs/file.c:		if (cinode->clientCanCacheRead)
fs/cifs/file.c:		rc = filemap_fdatawrite(inode->i_mapping);
fs/cifs/file.c:		if (cinode->clientCanCacheRead == 0) {
fs/cifs/file.c:			rc = filemap_fdatawait(inode->i_mapping);
fs/cifs/file.c:			mapping_set_error(inode->i_mapping, rc);
fs/cifs/ioctl.c:	cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/cifssmb.c:	mapping_set_error(inode->i_mapping, rc);
fs/cifs/cifssmb.c:		spin_lock(&inode->i_lock);
fs/cifs/cifssmb.c:		spin_unlock(&inode->i_lock);
fs/cifs/cifssmb.c:		mapping_set_error(inode->i_mapping, wdata->result);
fs/cifs/cifsacl.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/cifsacl.c:	pntsd = get_cifs_acl(CIFS_SB(inode->i_sb), inode, path, &secdesclen);
fs/cifs/smb1ops.c:	cinode->can_cache_brlcks = cinode->clientCanCacheAll;
fs/cifs/smb1ops.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
fs/cifs/smb1ops.c:			cinode->cifsAttrs = le32_to_cpu(buf->Attributes);
fs/cifs/smb1ops.c:		cinode->cifsAttrs = le32_to_cpu(buf->Attributes);
fs/cifs/smb1ops.c:			   cinode->clientCanCacheRead ? 1 : 0);
fs/cifs/xattr.c:	sb = direntry->d_inode->i_sb;
fs/cifs/xattr.c:	sb = direntry->d_inode->i_sb;
fs/cifs/xattr.c:	sb = direntry->d_inode->i_sb;
fs/cifs/xattr.c:	sb = direntry->d_inode->i_sb;
fs/readdir.c:	res = mutex_lock_killable(&inode->i_mutex);
fs/readdir.c:	mutex_unlock(&inode->i_mutex);
fs/befs/inode.c:	u32 magic1 = fs32_to_cpu(sb, raw_inode->magic1);
fs/befs/inode.c:	befs_inode_addr ino_num = fsrun_to_cpu(sb, raw_inode->inode_num);
fs/befs/inode.c:	u32 flags = fs32_to_cpu(sb, raw_inode->flags);
fs/befs/debug.c:	befs_debug(sb, "  magic1 %08x", fs32_to_cpu(sb, inode->magic1));
fs/befs/debug.c:	tmp_run = fsrun_to_cpu(sb, inode->inode_num);
fs/befs/debug.c:	befs_debug(sb, "  uid %u", fs32_to_cpu(sb, inode->uid));
fs/befs/debug.c:	befs_debug(sb, "  gid %u", fs32_to_cpu(sb, inode->gid));
fs/befs/debug.c:	befs_debug(sb, "  mode %08x", fs32_to_cpu(sb, inode->mode));
fs/befs/debug.c:	befs_debug(sb, "  flags %08x", fs32_to_cpu(sb, inode->flags));
fs/befs/debug.c:		   fs64_to_cpu(sb, inode->create_time));
fs/befs/debug.c:		   fs64_to_cpu(sb, inode->last_modified_time));
fs/befs/debug.c:	tmp_run = fsrun_to_cpu(sb, inode->parent);
fs/befs/debug.c:	tmp_run = fsrun_to_cpu(sb, inode->attributes);
fs/befs/debug.c:	befs_debug(sb, "  type %08x", fs32_to_cpu(sb, inode->type));
fs/befs/debug.c:	befs_debug(sb, "  inode_size %u", fs32_to_cpu(sb, inode->inode_size));
fs/befs/debug.c:	if (S_ISLNK(fs32_to_cpu(sb, inode->mode))) {
fs/befs/debug.c:		befs_debug(sb, "  Symbolic link [%s]", inode->data.symlink);
fs/befs/debug.c:			    fsrun_to_cpu(sb, inode->data.datastream.direct[i]);
fs/befs/debug.c:				       inode->data.datastream.
fs/befs/debug.c:		tmp_run = fsrun_to_cpu(sb, inode->data.datastream.indirect);
fs/befs/debug.c:				       inode->data.datastream.
fs/befs/debug.c:		    fsrun_to_cpu(sb, inode->data.datastream.double_indirect);
fs/befs/debug.c:				       inode->data.datastream.
fs/befs/debug.c:			   fs64_to_cpu(sb, inode->data.datastream.size));
fs/befs/linuxvfs.c:/* The units the vfs expects inode->i_blocks to be in */
fs/befs/linuxvfs.c:	struct super_block *sb = inode->i_sb;
fs/befs/linuxvfs.c:		   inode->i_ino, block);
fs/befs/linuxvfs.c:			   block, inode->i_ino);
fs/befs/linuxvfs.c:			   "block %ld in inode %lu", block, inode->i_ino);
fs/befs/linuxvfs.c:			   "%ld ERROR", inode->i_ino, block);
fs/befs/linuxvfs.c:	map_bh(bh_result, inode->i_sb, disk_off);
fs/befs/linuxvfs.c:		   "disk address %lu", inode->i_ino, block, disk_off);
fs/befs/linuxvfs.c:	struct super_block *sb = inode->i_sb;
fs/befs/linuxvfs.c:		   dirname, inode->i_ino, filp->f_pos);
fs/befs/linuxvfs.c:			   dirname, inode->i_ino);
fs/befs/linuxvfs.c:	call_rcu(&inode->i_rcu, befs_i_callback);
fs/befs/linuxvfs.c:	if (!(inode->i_state & I_NEW))
fs/befs/linuxvfs.c:	befs_ino->i_inode_num = blockno2iaddr(sb, inode->i_ino);
fs/befs/linuxvfs.c:	bh = befs_bread(sb, inode->i_ino);
fs/befs/linuxvfs.c:			   "inode = %lu", inode->i_ino);
fs/befs/linuxvfs.c:	if (befs_check_inode(sb, raw_inode, inode->i_ino) != BEFS_OK) {
fs/befs/linuxvfs.c:		befs_error(sb, "Bad inode: %lu", inode->i_ino);
fs/befs/linuxvfs.c:	inode->i_mode = (umode_t) fs32_to_cpu(sb, raw_inode->mode);
fs/befs/linuxvfs.c:	inode->i_uid = befs_sb->mount_opts.use_uid ?
fs/befs/linuxvfs.c:		make_kuid(&init_user_ns, fs32_to_cpu(sb, raw_inode->uid));
fs/befs/linuxvfs.c:	inode->i_gid = befs_sb->mount_opts.use_gid ?
fs/befs/linuxvfs.c:		make_kgid(&init_user_ns, fs32_to_cpu(sb, raw_inode->gid));
fs/befs/linuxvfs.c:	inode->i_mtime.tv_sec =
fs/befs/linuxvfs.c:	    fs64_to_cpu(sb, raw_inode->last_modified_time) >> 16;
fs/befs/linuxvfs.c:	inode->i_mtime.tv_nsec = 0;   /* lower 16 bits are not a time */	
fs/befs/linuxvfs.c:	inode->i_ctime = inode->i_mtime;
fs/befs/linuxvfs.c:	inode->i_atime = inode->i_mtime;
fs/befs/linuxvfs.c:	befs_ino->i_inode_num = fsrun_to_cpu(sb, raw_inode->inode_num);
fs/befs/linuxvfs.c:	befs_ino->i_parent = fsrun_to_cpu(sb, raw_inode->parent);
fs/befs/linuxvfs.c:	befs_ino->i_attribute = fsrun_to_cpu(sb, raw_inode->attributes);
fs/befs/linuxvfs.c:	befs_ino->i_flags = fs32_to_cpu(sb, raw_inode->flags);
fs/befs/linuxvfs.c:	if (S_ISLNK(inode->i_mode) && !(befs_ino->i_flags & BEFS_LONG_SYMLINK)){
fs/befs/linuxvfs.c:		inode->i_size = 0;
fs/befs/linuxvfs.c:		inode->i_blocks = befs_sb->block_size / VFS_BLOCK_SIZE;
fs/befs/linuxvfs.c:		strncpy(befs_ino->i_data.symlink, raw_inode->data.symlink,
fs/befs/linuxvfs.c:		    fsds_to_cpu(sb, &raw_inode->data.datastream);
fs/befs/linuxvfs.c:		inode->i_blocks =
fs/befs/linuxvfs.c:		inode->i_size = befs_ino->i_data.ds.size;
fs/befs/linuxvfs.c:	inode->i_mapping->a_ops = &befs_aops;
fs/befs/linuxvfs.c:	if (S_ISREG(inode->i_mode)) {
fs/befs/linuxvfs.c:		inode->i_fop = &generic_ro_fops;
fs/befs/linuxvfs.c:	} else if (S_ISDIR(inode->i_mode)) {
fs/befs/linuxvfs.c:		inode->i_op = &befs_dir_inode_operations;
fs/befs/linuxvfs.c:		inode->i_fop = &befs_dir_operations;
fs/befs/linuxvfs.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/befs/linuxvfs.c:		inode->i_op = &befs_symlink_inode_operations;
fs/befs/linuxvfs.c:			   "on disk special files", inode->i_ino);
fs/ntfs/inode.c: * NOTE: This function runs with the inode->i_lock spin lock held so it is not
fs/ntfs/inode.c: * NOTE: This function runs with the inode->i_lock spin lock held so it is not
fs/ntfs/inode.c:	call_rcu(&inode->i_rcu, ntfs_i_callback);
fs/ntfs/file.c: * As a side-effect, the file size (vfs inode->i_size) may be incremented as,
fs/ntfs/file.c:	 * size (vfs inode->i_size), we need to extend the file size to the
fs/ntfs/file.c:	if (to > inode->i_size) {
fs/ntfs/file.c:		truncate_pagecache(inode, to, inode->i_size);
fs/ntfs/file.c:	 * increments the vfs inode->i_size to keep it above or equal to the
fs/ntfs/file.c:	err = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));
fs/ntfs/file.c:	sb_start_write(inode->i_sb);
fs/ntfs/file.c:	mutex_lock(&inode->i_mutex);
fs/ntfs/file.c:	mutex_unlock(&inode->i_mutex);
fs/ntfs/file.c:	sb_end_write(inode->i_sb);
fs/ntfs/namei.c: * Note: ntfs_get_parent() is called with @child_dent->d_inode->i_mutex down.
fs/ntfs/namei.c:		if (is_bad_inode(inode) || inode->i_generation != generation) {
fs/hfs/mdb.c:	*size = sb->s_bdev->bd_inode->i_size >> 9;
fs/hfs/inode.c: * This file contains inode-related functions which do not depend on
fs/hfs/inode.c:	if (to > inode->i_size) {
fs/hfs/inode.c:		truncate_pagecache(inode, to, inode->i_size);
fs/hfs/inode.c:	struct super_block *sb = inode->i_sb;
fs/hfs/inode.c:	switch (inode->i_ino) {
fs/hfs/inode.c:	struct inode *inode = file->f_path.dentry->d_inode->i_mapping->host;
fs/hfs/inode.c:	inode->i_ino = HFS_SB(sb)->next_id++;
fs/hfs/inode.c:	inode->i_mode = mode;
fs/hfs/inode.c:	inode->i_uid = current_fsuid();
fs/hfs/inode.c:	inode->i_gid = current_fsgid();
fs/hfs/inode.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
fs/hfs/inode.c:		inode->i_size = 2;
fs/hfs/inode.c:		inode->i_op = &hfs_dir_inode_operations;
fs/hfs/inode.c:		inode->i_fop = &hfs_dir_operations;
fs/hfs/inode.c:		inode->i_mode |= S_IRWXUGO;
fs/hfs/inode.c:		inode->i_mode &= ~HFS_SB(inode->i_sb)->s_dir_umask;
fs/hfs/inode.c:		inode->i_op = &hfs_file_inode_operations;
fs/hfs/inode.c:		inode->i_fop = &hfs_file_operations;
fs/hfs/inode.c:		inode->i_mapping->a_ops = &hfs_aops;
fs/hfs/inode.c:		inode->i_mode |= S_IRUGO|S_IXUGO;
fs/hfs/inode.c:			inode->i_mode |= S_IWUGO;
fs/hfs/inode.c:		inode->i_mode &= ~HFS_SB(inode->i_sb)->s_file_umask;
fs/hfs/inode.c:	struct super_block *sb = inode->i_sb;
fs/hfs/inode.c:	dprint(DBG_INODE, "delete_inode: %lu\n", inode->i_ino);
fs/hfs/inode.c:	if (S_ISDIR(inode->i_mode)) {
fs/hfs/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/hfs/inode.c:		if (!inode->i_nlink) {
fs/hfs/inode.c:			inode->i_size = 0;
fs/hfs/inode.c:	struct super_block *sb = inode->i_sb;
fs/hfs/inode.c:	inode->i_size = HFS_I(inode)->phys_size = log_size;
fs/hfs/inode.c:		return inode->i_ino == be32_to_cpu(rec->dir.DirID);
fs/hfs/inode.c:		return inode->i_ino == be32_to_cpu(rec->file.FlNum);
fs/hfs/inode.c:	struct hfs_sb_info *hsb = HFS_SB(inode->i_sb);
fs/hfs/inode.c:	inode->i_uid = hsb->s_uid;
fs/hfs/inode.c:	inode->i_gid = hsb->s_gid;
fs/hfs/inode.c:		inode->i_ino = be32_to_cpu(rec->file.FlNum);
fs/hfs/inode.c:		inode->i_mode = S_IRUGO | S_IXUGO;
fs/hfs/inode.c:			inode->i_mode |= S_IWUGO;
fs/hfs/inode.c:		inode->i_mode &= ~hsb->s_file_umask;
fs/hfs/inode.c:		inode->i_mode |= S_IFREG;
fs/hfs/inode.c:		inode->i_ctime = inode->i_atime = inode->i_mtime =
fs/hfs/inode.c:		inode->i_op = &hfs_file_inode_operations;
fs/hfs/inode.c:		inode->i_fop = &hfs_file_operations;
fs/hfs/inode.c:		inode->i_mapping->a_ops = &hfs_aops;
fs/hfs/inode.c:		inode->i_ino = be32_to_cpu(rec->dir.DirID);
fs/hfs/inode.c:		inode->i_size = be16_to_cpu(rec->dir.Val) + 2;
fs/hfs/inode.c:		inode->i_mode = S_IFDIR | (S_IRWXUGO & ~hsb->s_dir_umask);
fs/hfs/inode.c:		inode->i_ctime = inode->i_atime = inode->i_mtime =
fs/hfs/inode.c:		inode->i_op = &hfs_dir_inode_operations;
fs/hfs/inode.c:		inode->i_fop = &hfs_dir_operations;
fs/hfs/inode.c:	if (inode && (inode->i_state & I_NEW))
fs/hfs/inode.c:		*log_size = cpu_to_be32(inode->i_size);
fs/hfs/inode.c:					 HFS_SB(inode->i_sb)->alloc_blksz);
fs/hfs/inode.c:	dprint(DBG_INODE, "hfs_write_inode: %lu\n", inode->i_ino);
fs/hfs/inode.c:	if (inode->i_ino < HFS_FIRSTUSER_CNID) {
fs/hfs/inode.c:		switch (inode->i_ino) {
fs/hfs/inode.c:			hfs_btree_write(HFS_SB(inode->i_sb)->ext_tree);
fs/hfs/inode.c:			hfs_btree_write(HFS_SB(inode->i_sb)->cat_tree);
fs/hfs/inode.c:	if (!main_inode->i_nlink)
fs/hfs/inode.c:	if (hfs_find_init(HFS_SB(main_inode->i_sb)->cat_tree, &fd))
fs/hfs/inode.c:	if (S_ISDIR(main_inode->i_mode)) {
fs/hfs/inode.c:		    be32_to_cpu(rec.dir.DirID) != inode->i_ino) {
fs/hfs/inode.c:		rec.dir.MdDat = hfs_u_to_mtime(inode->i_mtime);
fs/hfs/inode.c:		rec.dir.Val = cpu_to_be16(inode->i_size - 2);
fs/hfs/inode.c:		    be32_to_cpu(rec.file.FlNum) != inode->i_ino) {
fs/hfs/inode.c:		if (inode->i_mode & S_IWUSR)
fs/hfs/inode.c:		rec.file.MdDat = hfs_u_to_mtime(inode->i_mtime);
fs/hfs/inode.c:	hlist_add_fake(&inode->i_hash);
fs/hfs/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/hfs/inode.c:	//struct super_block *sb = inode->i_sb;
fs/hfs/inode.c:		mutex_lock(&inode->i_mutex);
fs/hfs/inode.c:		//if (inode->i_flags & S_DEAD) {
fs/hfs/inode.c:		//	hfs_delete_cat(inode->i_ino, HFSPLUS_SB(sb).hidden_dir, NULL);
fs/hfs/inode.c:		mutex_unlock(&inode->i_mutex);
fs/hfs/inode.c:	struct hfs_sb_info *hsb = HFS_SB(inode->i_sb);
fs/hfs/inode.c:	     ((S_ISDIR(inode->i_mode) &&
fs/hfs/inode.c:	       (attr->ia_mode != inode->i_mode)) ||
fs/hfs/inode.c:			attr->ia_mode = inode->i_mode | S_IWUGO;
fs/hfs/inode.c:			attr->ia_mode = inode->i_mode & ~S_IWUGO;
fs/hfs/inode.c:		attr->ia_mode &= S_ISDIR(inode->i_mode) ? ~hsb->s_dir_umask: ~hsb->s_file_umask;
fs/hfs/inode.c:	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/hfs/inode.c:	mutex_lock(&inode->i_mutex);
fs/hfs/inode.c:	sb = inode->i_sb;
fs/hfs/inode.c:	mutex_unlock(&inode->i_mutex);
fs/hfs/super.c:	call_rcu(&inode->i_rcu, hfs_i_callback);
fs/hfs/bnode.c:	sb = tree->inode->i_sb;
fs/hfs/bnode.c:	mapping = tree->inode->i_mapping;
fs/hfs/dir.c:	struct super_block *sb = inode->i_sb;
fs/hfs/dir.c:	if (filp->f_pos >= inode->i_size)
fs/hfs/dir.c:	hfs_cat_build_key(sb, fd.search_key, inode->i_ino, NULL);
fs/hfs/dir.c:		if (filldir(dirent, ".", 1, 0, inode->i_ino, DT_DIR))
fs/hfs/dir.c:		if (filp->f_pos >= inode->i_size)
fs/hfs/dir.c:		if (be32_to_cpu(fd.key->cat.ParID) != inode->i_ino) {
fs/hfs/dir.c:		if (filp->f_pos >= inode->i_size)
fs/hfs/dir.c:	res = hfs_cat_create(inode->i_ino, dir, &dentry->d_name, inode);
fs/hfs/dir.c:	res = hfs_cat_create(inode->i_ino, dir, &dentry->d_name, inode);
fs/hfs/dir.c:	if (S_ISDIR(inode->i_mode) && inode->i_size != 2)
fs/hfs/dir.c:	res = hfs_cat_delete(inode->i_ino, dir, &dentry->d_name);
fs/hfs/dir.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/hfs/dir.c:	res = hfs_cat_move(old_dentry->d_inode->i_ino,
fs/hfs/btree.c:	BUG_ON(!(tree->inode->i_state & I_NEW));
fs/hfs/btree.c:		tree->inode->i_mapping->a_ops = &hfs_btree_aops;
fs/hfs/btree.c:		tree->inode->i_mapping->a_ops = &hfs_btree_aops;
fs/hfs/btree.c:	mapping = tree->inode->i_mapping;
fs/hfs/btree.c:	tree->inode->i_mapping->a_ops = &hfs_aops;
fs/hfs/btree.c:		HFS_I(inode)->phys_size = inode->i_size =
fs/hfs/btree.c:		HFS_I(inode)->fs_blocks = inode->i_size >>
fs/hfs/btree.c:		inode_set_bytes(inode, inode->i_size);
fs/hfs/btree.c:		count = inode->i_size >> tree->node_size_shift;
fs/hfs/attr.c:	if (!S_ISREG(inode->i_mode) || HFS_IS_RSRC(inode))
fs/hfs/attr.c:	res = hfs_find_init(HFS_SB(inode->i_sb)->cat_tree, &fd);
fs/hfs/attr.c:	if (!S_ISREG(inode->i_mode) || HFS_IS_RSRC(inode))
fs/hfs/attr.c:		res = hfs_find_init(HFS_SB(inode->i_sb)->cat_tree, &fd);
fs/hfs/attr.c:	if (!S_ISREG(inode->i_mode) || HFS_IS_RSRC(inode))
fs/hfs/sysdep.c:		inode->i_ctime.tv_sec += diff;
fs/hfs/sysdep.c:		inode->i_atime.tv_sec += diff;
fs/hfs/sysdep.c:		inode->i_mtime.tv_sec += diff;
fs/hfs/catalog.c:	if (S_ISDIR(inode->i_mode)) {
fs/hfs/catalog.c:		if (!(inode->i_mode & S_IWUSR))
fs/hfs/catalog.c:		rec->file.UsrWds.fdType = HFS_SB(inode->i_sb)->s_type;
fs/hfs/catalog.c:		rec->file.UsrWds.fdCreator = HFS_SB(inode->i_sb)->s_creator;
fs/hfs/catalog.c:	dprint(DBG_CAT_MOD, "create_cat: %s,%u(%d)\n", str->name, cnid, inode->i_nlink);
fs/hfs/catalog.c:	entry_size = hfs_cat_build_thread(sb, &entry, S_ISDIR(inode->i_mode) ?
fs/hfs/extent.c:	hfs_ext_build_key(fd->search_key, inode->i_ino, HFS_I(inode)->cached_start,
fs/hfs/extent.c:		hfs_find_init(HFS_SB(inode->i_sb)->ext_tree, &fd);
fs/hfs/extent.c:	res = __hfs_ext_read_extent(fd, HFS_I(inode)->cached_extents, inode->i_ino,
fs/hfs/extent.c:	hfs_find_init(HFS_SB(inode->i_sb)->ext_tree, &fd);
fs/hfs/extent.c:	sb = inode->i_sb;
fs/hfs/extent.c:	struct super_block *sb = inode->i_sb;
fs/hfs/extent.c:	dprint(DBG_EXTENT, "extend %lu: %u,%u\n", inode->i_ino, start, len);
fs/hfs/extent.c:		if (inode->i_ino < HFS_FIRSTUSER_CNID)
fs/hfs/extent.c:	struct super_block *sb = inode->i_sb;
fs/hfs/extent.c:	dprint(DBG_INODE, "truncate: %lu, %Lu -> %Lu\n", inode->i_ino,
fs/hfs/extent.c:	       (long long)HFS_I(inode)->phys_size, inode->i_size);
fs/hfs/extent.c:	if (inode->i_size > HFS_I(inode)->phys_size) {
fs/hfs/extent.c:		struct address_space *mapping = inode->i_mapping;
fs/hfs/extent.c:		size = inode->i_size - 1;
fs/hfs/extent.c:			inode->i_size = HFS_I(inode)->phys_size;
fs/hfs/extent.c:	} else if (inode->i_size == HFS_I(inode)->phys_size)
fs/hfs/extent.c:	size = inode->i_size + HFS_SB(sb)->alloc_blksz - 1;
fs/hfs/extent.c:	HFS_I(inode)->phys_size = inode->i_size;
fs/hfs/extent.c:	HFS_I(inode)->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;
fs/xfs/xfs_export.c:	if (!(XFS_M(inode->i_sb)->m_flags & XFS_MOUNT_SMALL_INUMS) ||
fs/xfs/xfs_export.c:	    (XFS_M(inode->i_sb)->m_flags & XFS_MOUNT_32BITINODES))
fs/xfs/xfs_export.c:		fid->i32.gen = inode->i_generation;
fs/xfs/xfs_export.c:		fid64->gen = inode->i_generation;
fs/xfs/xfs_acl.c: *  - all ACL updates are protected by inode->i_mutex, which is taken before
fs/xfs/xfs_acl.c:	if (S_ISLNK(inode->i_mode))
fs/xfs/xfs_acl.c:		if (!S_ISDIR(inode->i_mode))
fs/xfs/xfs_acl.c:	if (mode != inode->i_mode) {
fs/xfs/xfs_acl.c:		iattr.ia_ctime = current_fs_time(inode->i_sb);
fs/xfs/xfs_acl.c:	if (!S_ISDIR(inode->i_mode))
fs/xfs/xfs_acl.c:	umode_t mode = inode->i_mode;
fs/xfs/xfs_acl.c:	if (S_ISDIR(inode->i_mode)) {
fs/xfs/xfs_acl.c:	if (S_ISLNK(inode->i_mode))
fs/xfs/xfs_acl.c:	error = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
fs/xfs/xfs_acl.c:	if (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))
fs/xfs/xfs_acl.c:	if ((current_fsuid() != inode->i_uid) && !capable(CAP_FOWNER))
fs/xfs/xfs_acl.c:		umode_t mode = inode->i_mode;
fs/xfs/xfs_ioctl.c:	if (inode->i_sb->s_magic != XFS_SB_MAGIC)
fs/xfs/xfs_ioctl.c:	if (!S_ISREG(inode->i_mode) &&
fs/xfs/xfs_ioctl.c:	    !S_ISDIR(inode->i_mode) &&
fs/xfs/xfs_ioctl.c:	    !S_ISLNK(inode->i_mode))
fs/xfs/xfs_ioctl.c:	if (!S_ISDIR(parfilp->f_path.dentry->d_inode->i_mode))
fs/xfs/xfs_ioctl.c:	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))) {
fs/xfs/xfs_ioctl.c:	if (S_ISDIR(inode->i_mode) && (fmode & FMODE_WRITE)) {
fs/xfs/xfs_ioctl.c:	if (S_ISREG(inode->i_mode)) {
fs/xfs/xfs_ioctl.c:	if (!S_ISLNK(dentry->d_inode->i_mode)) {
fs/xfs/xfs_ioctl.c:	if (inode->i_flags & (S_IMMUTABLE|S_APPEND))
fs/xfs/xfs_ioctl.c:	if (!S_ISREG(inode->i_mode))
fs/xfs/xfs_ioctl.c:		inode->i_flags |= S_IMMUTABLE;
fs/xfs/xfs_ioctl.c:		inode->i_flags &= ~S_IMMUTABLE;
fs/xfs/xfs_ioctl.c:		inode->i_flags |= S_APPEND;
fs/xfs/xfs_ioctl.c:		inode->i_flags &= ~S_APPEND;
fs/xfs/xfs_ioctl.c:		inode->i_flags |= S_SYNC;
fs/xfs/xfs_ioctl.c:		inode->i_flags &= ~S_SYNC;
fs/xfs/xfs_ioctl.c:		inode->i_flags |= S_NOATIME;
fs/xfs/xfs_ioctl.c:		inode->i_flags &= ~S_NOATIME;
fs/xfs/xfs_ioctl.c:		return put_user(inode->i_generation, (int __user *)arg);
fs/xfs/xfs_aops.c:	rwsem_release(&ioend->io_inode->i_sb->s_writers.lock_map[SB_FREEZE_FS-1],
fs/xfs/xfs_aops.c:	ssize_t			count = 1 << inode->i_blkbits;
fs/xfs/xfs_aops.c:	offset >>= inode->i_blkbits;
fs/xfs/xfs_aops.c:	bn = (iomap_bn >> (inode->i_blkbits - BBSHIFT)) +
fs/xfs/xfs_aops.c:	      ((offset - iomap_offset) >> inode->i_blkbits);
fs/xfs/xfs_aops.c:	if (page->mapping != inode->i_mapping)
fs/xfs/xfs_aops.c:	len = 1 << inode->i_blkbits;
fs/xfs/xfs_aops.c:		if (!pagevec_lookup(&pvec, inode->i_mapping, tindex, len))
fs/xfs/xfs_aops.c:		offset += 1 << inode->i_blkbits;
fs/xfs/xfs_aops.c:	len = 1 << inode->i_blkbits;
fs/xfs/xfs_aops.c:		end_index <<= inode->i_blkbits;
fs/xfs/xfs_aops.c:	offset = (xfs_off_t)iblock << inode->i_blkbits;
fs/xfs/xfs_aops.c:	ASSERT(bh_result->b_size >= (1 << inode->i_blkbits));
fs/xfs/xfs_aops.c:	if (direct || size > (1 << inode->i_blkbits)) {
fs/xfs/xfs_aops.c:		mapping_size <<= inode->i_blkbits;
fs/xfs/xfs_icache.c:		inode->i_state = I_NEW;
fs/xfs/xfs_iops.c:	stat->dev = inode->i_sb->s_dev;
fs/xfs/xfs_iops.c:	stat->atime = inode->i_atime;
fs/xfs/xfs_iops.c:	stat->mtime = inode->i_mtime;
fs/xfs/xfs_iops.c:	stat->ctime = inode->i_ctime;
fs/xfs/xfs_iops.c:	switch (inode->i_mode & S_IFMT) {
fs/xfs/xfs_iops.c:			inode->i_uid = uid;
fs/xfs/xfs_iops.c:			inode->i_gid = gid;
fs/xfs/xfs_iops.c:		if (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))
fs/xfs/xfs_iops.c:		inode->i_mode &= S_IFMT;
fs/xfs/xfs_iops.c:		inode->i_mode |= mode & ~S_IFMT;
fs/xfs/xfs_iops.c:		inode->i_atime = iattr->ia_atime;
fs/xfs/xfs_iops.c:		inode->i_ctime = iattr->ia_ctime;
fs/xfs/xfs_iops.c:		inode->i_mtime = iattr->ia_mtime;
fs/xfs/xfs_iops.c:	oldsize = inode->i_size;
fs/xfs/xfs_iops.c:	error = -block_truncate_page(inode->i_mapping, newsize, xfs_get_blocks);
fs/xfs/xfs_iops.c:			current_fs_time(inode->i_sb);
fs/xfs/xfs_iops.c:		inode->i_ctime = iattr->ia_ctime;
fs/xfs/xfs_iops.c:		inode->i_mtime = iattr->ia_mtime;
fs/xfs/xfs_iops.c:		inode->i_ctime = *now;
fs/xfs/xfs_iops.c:		inode->i_mtime = *now;
fs/xfs/xfs_iops.c:		inode->i_atime = *now;
fs/xfs/xfs_iops.c:		inode->i_flags |= S_IMMUTABLE;
fs/xfs/xfs_iops.c:		inode->i_flags &= ~S_IMMUTABLE;
fs/xfs/xfs_iops.c:		inode->i_flags |= S_APPEND;
fs/xfs/xfs_iops.c:		inode->i_flags &= ~S_APPEND;
fs/xfs/xfs_iops.c:		inode->i_flags |= S_SYNC;
fs/xfs/xfs_iops.c:		inode->i_flags &= ~S_SYNC;
fs/xfs/xfs_iops.c:		inode->i_flags |= S_NOATIME;
fs/xfs/xfs_iops.c:		inode->i_flags &= ~S_NOATIME;
fs/xfs/xfs_iops.c:	inode->i_ino = ip->i_ino;
fs/xfs/xfs_iops.c:	inode->i_state = I_NEW;
fs/xfs/xfs_iops.c:	hlist_add_fake(&inode->i_hash);
fs/xfs/xfs_iops.c:	inode->i_mode	= ip->i_d.di_mode;
fs/xfs/xfs_iops.c:	inode->i_uid	= ip->i_d.di_uid;
fs/xfs/xfs_iops.c:	inode->i_gid	= ip->i_d.di_gid;
fs/xfs/xfs_iops.c:	switch (inode->i_mode & S_IFMT) {
fs/xfs/xfs_iops.c:		inode->i_rdev =
fs/xfs/xfs_iops.c:		inode->i_rdev = 0;
fs/xfs/xfs_iops.c:	inode->i_generation = ip->i_d.di_gen;
fs/xfs/xfs_iops.c:	inode->i_atime.tv_sec	= ip->i_d.di_atime.t_sec;
fs/xfs/xfs_iops.c:	inode->i_atime.tv_nsec	= ip->i_d.di_atime.t_nsec;
fs/xfs/xfs_iops.c:	inode->i_mtime.tv_sec	= ip->i_d.di_mtime.t_sec;
fs/xfs/xfs_iops.c:	inode->i_mtime.tv_nsec	= ip->i_d.di_mtime.t_nsec;
fs/xfs/xfs_iops.c:	inode->i_ctime.tv_sec	= ip->i_d.di_ctime.t_sec;
fs/xfs/xfs_iops.c:	inode->i_ctime.tv_nsec	= ip->i_d.di_ctime.t_nsec;
fs/xfs/xfs_iops.c:	switch (inode->i_mode & S_IFMT) {
fs/xfs/xfs_iops.c:		inode->i_op = &xfs_inode_operations;
fs/xfs/xfs_iops.c:		inode->i_fop = &xfs_file_operations;
fs/xfs/xfs_iops.c:		inode->i_mapping->a_ops = &xfs_address_space_operations;
fs/xfs/xfs_iops.c:		if (xfs_sb_version_hasasciici(&XFS_M(inode->i_sb)->m_sb))
fs/xfs/xfs_iops.c:			inode->i_op = &xfs_dir_ci_inode_operations;
fs/xfs/xfs_iops.c:			inode->i_op = &xfs_dir_inode_operations;
fs/xfs/xfs_iops.c:		inode->i_fop = &xfs_dir_file_operations;
fs/xfs/xfs_iops.c:		inode->i_op = &xfs_symlink_inode_operations;
fs/xfs/xfs_iops.c:			inode->i_mapping->a_ops = &xfs_address_space_operations;
fs/xfs/xfs_iops.c:		inode->i_op = &xfs_inode_operations;
fs/xfs/xfs_iops.c:		init_special_inode(inode, inode->i_mode, inode->i_rdev);
fs/xfs/xfs_export.h: *	inode-num
fs/xfs/xfs_export.h: *	inode-num
fs/xfs/xfs_export.h: *	parent-inode-num
fs/xfs/xfs_export.h: *	inode-num-lo32
fs/xfs/xfs_export.h: *	inode-num-hi32
fs/xfs/xfs_export.h: *	inode-num-lo32
fs/xfs/xfs_export.h: *	inode-num-hi32
fs/xfs/xfs_export.h: *	parent-inode-num-lo32
fs/xfs/xfs_export.h: *	parent-inode-num-hi32
fs/xfs/xfs_file.c: * and order the inode->i_mutex, ip->i_lock and ip->i_iolock.
fs/xfs/xfs_file.c:	error = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/xfs/xfs_file.c:	if ((ioflags & IO_ISDIRECT) && inode->i_mapping->nrpages) {
fs/xfs/xfs_file.c:		if (inode->i_mapping->nrpages) {
fs/xfs/xfs_file.c:	error = generic_write_checks(file, pos, count, S_ISBLK(inode->i_mode));
fs/xfs/xfs_file.c:	sb_start_write(inode->i_sb);
fs/xfs/xfs_file.c:	sb_end_write(inode->i_sb);
fs/xfs/xfs_file.c:	if (XFS_FORCED_SHUTDOWN(XFS_M(inode->i_sb)))
fs/xfs/xfs_file.c:		nr_pages = pagevec_lookup(&pvec, inode->i_mapping, index,
fs/xfs/xfs_file.c:			if (unlikely(page->mapping != inode->i_mapping)) {
fs/xfs/xfs_trace.h:		__entry->dev = inode->i_sb->s_dev;
fs/xfs/xfs_super.c:	truncate_inode_pages(&inode->i_data, 0);
fs/xfs/xfs_super.c: * serialised against cache hits here via the inode->i_lock and igrab() in
fs/xfs/xfs_trans_inode.c:	tv = current_fs_time(inode->i_sb);
fs/xfs/xfs_trans_inode.c:	    !timespec_equal(&inode->i_mtime, &tv)) {
fs/xfs/xfs_trans_inode.c:		inode->i_mtime = tv;
fs/xfs/xfs_trans_inode.c:	    !timespec_equal(&inode->i_ctime, &tv)) {
fs/xfs/xfs_trans_inode.c:		inode->i_ctime = tv;
fs/dcache.c: * dcache->d_inode->i_lock protects:
fs/dcache.c: * dentry->d_inode->i_lock
fs/dcache.c:	__releases(dentry->d_inode->i_lock)
fs/dcache.c:		spin_unlock(&inode->i_lock);
fs/dcache.c:		if (!inode->i_nlink)
fs/dcache.c:	__releases(dentry->d_inode->i_lock)
fs/dcache.c:	spin_unlock(&inode->i_lock);
fs/dcache.c:	if (!inode->i_nlink)
fs/dcache.c:	__releases(dentry->d_inode->i_lock)
fs/dcache.c:	if (inode && !spin_trylock(&inode->i_lock)) {
fs/dcache.c:			spin_unlock(&inode->i_lock);
fs/dcache.c:		if (S_ISDIR(dentry->d_inode->i_mode) || d_mountpoint(dentry)) {
fs/dcache.c:	hlist_for_each_entry(alias, p, &inode->i_dentry, d_alias) {
fs/dcache.c: 		if (S_ISDIR(inode->i_mode) || !d_unhashed(alias)) {
fs/dcache.c:		if (S_ISDIR(inode->i_mode) || !d_unhashed(alias)) {
fs/dcache.c:	if (!hlist_empty(&inode->i_dentry)) {
fs/dcache.c:		spin_lock(&inode->i_lock);
fs/dcache.c:		spin_unlock(&inode->i_lock);
fs/dcache.c:	spin_lock(&inode->i_lock);
fs/dcache.c:	hlist_for_each_entry(dentry, p, &inode->i_dentry, d_alias) {
fs/dcache.c:			spin_unlock(&inode->i_lock);
fs/dcache.c:	spin_unlock(&inode->i_lock);
fs/dcache.c:				       dentry->d_inode->i_ino : 0UL,
fs/dcache.c:		hlist_add_head(&dentry->d_alias, &inode->i_dentry);
fs/dcache.c:		spin_lock(&inode->i_lock);
fs/dcache.c:		spin_unlock(&inode->i_lock);
fs/dcache.c:	hlist_for_each_entry(alias, p, &inode->i_dentry, d_alias) {
fs/dcache.c:		spin_lock(&inode->i_lock);
fs/dcache.c:		spin_unlock(&inode->i_lock);
fs/dcache.c:		res = __d_alloc(root_inode->i_sb, &name);
fs/dcache.c:	if (hlist_empty(&inode->i_dentry))
fs/dcache.c:	alias = hlist_entry(inode->i_dentry.first, struct dentry, d_alias);
fs/dcache.c:	spin_lock(&inode->i_lock);
fs/dcache.c:	spin_unlock(&inode->i_lock);
fs/dcache.c:	tmp = __d_alloc(inode->i_sb, &anonstring);
fs/dcache.c:	spin_lock(&inode->i_lock);
fs/dcache.c:		spin_unlock(&inode->i_lock);
fs/dcache.c:	hlist_add_head(&tmp->d_alias, &inode->i_dentry);
fs/dcache.c:	spin_unlock(&inode->i_lock);
fs/dcache.c:	if (inode && S_ISDIR(inode->i_mode)) {
fs/dcache.c:		spin_lock(&inode->i_lock);
fs/dcache.c:			spin_unlock(&inode->i_lock);
fs/dcache.c:			/* already taking inode->i_lock, so d_add() by hand */
fs/dcache.c:			spin_unlock(&inode->i_lock);
fs/dcache.c:	isdir = S_ISDIR(inode->i_mode);
fs/dcache.c:		if (!spin_trylock(&inode->i_lock)) {
fs/dcache.c:	BUG_ON(!mutex_is_locked(&dentry->d_parent->d_inode->i_mutex));
fs/dcache.c: * dentry->d_parent->d_inode->i_mutex, inode->i_lock and rename_lock
fs/dcache.c:	if (!mutex_trylock(&alias->d_parent->d_inode->i_mutex))
fs/dcache.c:	m2 = &alias->d_parent->d_inode->i_mutex;
fs/dcache.c:	spin_unlock(&inode->i_lock);
fs/dcache.c:	spin_lock(&inode->i_lock);
fs/dcache.c:	if (S_ISDIR(inode->i_mode)) {
fs/dcache.c:				spin_unlock(&inode->i_lock);
fs/dcache.c:				 * aliasing. This drops inode->i_lock */
fs/dcache.c:						inode->i_sb->s_type->name,
fs/dcache.c:						inode->i_sb->s_id);
fs/dcache.c:	spin_unlock(&inode->i_lock);
fs/dcache.c:			ino = dentry->d_inode->i_ino;
fs/exec.c~:	if (!S_ISREG(file->f_path.dentry->d_inode->i_mode))
fs/exec.c~:	if (!S_ISREG(file->f_path.dentry->d_inode->i_mode))
fs/exec.c~:	mode = inode->i_mode;
fs/exec.c~:	    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&
fs/exec.c~:	    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {
fs/exec.c~:			bprm->cred->euid = inode->i_uid;
fs/exec.c~:			bprm->cred->egid = inode->i_gid;
fs/binfmt_misc.c:		inode->i_ino = get_next_ino();
fs/binfmt_misc.c:		inode->i_mode = mode;
fs/binfmt_misc.c:		inode->i_atime = inode->i_mtime = inode->i_ctime =
fs/binfmt_misc.c:			current_fs_time(inode->i_sb);
fs/binfmt_misc.c:	kfree(inode->i_private);
fs/binfmt_misc.c:	Node *e = file->f_path.dentry->d_inode->i_private;
fs/binfmt_misc.c:	Node *e = file->f_path.dentry->d_inode->i_private;
fs/binfmt_misc.c:			mutex_lock(&root->d_inode->i_mutex);
fs/binfmt_misc.c:			mutex_unlock(&root->d_inode->i_mutex);
fs/binfmt_misc.c:	mutex_lock(&root->d_inode->i_mutex);
fs/binfmt_misc.c:	inode->i_private = e;
fs/binfmt_misc.c:	inode->i_fop = &bm_entry_operations;
fs/binfmt_misc.c:	mutex_unlock(&root->d_inode->i_mutex);
fs/binfmt_misc.c:			mutex_lock(&root->d_inode->i_mutex);
fs/binfmt_misc.c:			mutex_unlock(&root->d_inode->i_mutex);
fs/isofs/inode.c:	call_rcu(&inode->i_rcu, isofs_i_callback);
fs/isofs/inode.c:	if (!S_ISDIR(inode->i_mode)) {
fs/isofs/inode.c:		if (b_off > ((inode->i_size + PAGE_CACHE_SIZE - 1) >> ISOFS_BUFFER_BITS(inode))) {
fs/isofs/inode.c:				(unsigned long long)inode->i_size);
fs/isofs/inode.c:			ninode = isofs_iget(inode->i_sb, nextblk, nextoff);
fs/isofs/inode.c:			map_bh(*bh, inode->i_sb, firstext + b_off - offset);
fs/isofs/inode.c:			*bh = sb_getblk(inode->i_sb, firstext+b_off-offset);
fs/isofs/inode.c:	return sb_bread(inode->i_sb, blknr);
fs/isofs/inode.c:	int high_sierra = ISOFS_SB(inode->i_sb)->s_high_sierra;
fs/isofs/inode.c:	inode->i_size = 0;
fs/isofs/inode.c:			bh = sb_bread(inode->i_sb, block);
fs/isofs/inode.c:				bh = sb_bread(inode->i_sb, block);
fs/isofs/inode.c:		inode->i_size += isonum_733(de->size);
fs/isofs/inode.c:		__func__, inode->i_ino);
fs/isofs/inode.c:	struct super_block *sb = inode->i_sb;
fs/isofs/inode.c:	bh = sb_bread(inode->i_sb, block);
fs/isofs/inode.c:		bh = sb_bread(inode->i_sb, ++block);
fs/isofs/inode.c:	inode->i_ino = isofs_get_ino(ei->i_iget5_block,
fs/isofs/inode.c:			inode->i_mode = S_IFDIR | sbi->s_dmode;
fs/isofs/inode.c:			inode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;
fs/isofs/inode.c:			inode->i_mode = S_IFREG | sbi->s_fmode;
fs/isofs/inode.c:			inode->i_mode = S_IFREG | S_IRUGO | S_IXUGO;
fs/isofs/inode.c:	inode->i_uid = sbi->s_uid;
fs/isofs/inode.c:	inode->i_gid = sbi->s_gid;
fs/isofs/inode.c:	inode->i_blocks = 0;
fs/isofs/inode.c:		inode->i_size = isonum_733(de->size);
fs/isofs/inode.c:		inode->i_size &= 0x00ffffff;
fs/isofs/inode.c:		inode->i_size = 0;
fs/isofs/inode.c:			inode->i_ino);
fs/isofs/inode.c:			inode->i_ino, de->flags[-high_sierra]);
fs/isofs/inode.c:	inode->i_mtime.tv_sec =
fs/isofs/inode.c:	inode->i_atime.tv_sec =
fs/isofs/inode.c:	inode->i_ctime.tv_sec = iso_date(de->date, high_sierra);
fs/isofs/inode.c:	inode->i_mtime.tv_nsec =
fs/isofs/inode.c:	inode->i_atime.tv_nsec =
fs/isofs/inode.c:	inode->i_ctime.tv_nsec = 0;
fs/isofs/inode.c:	inode->i_blocks = (inode->i_size + 511) >> 9;
fs/isofs/inode.c:			inode->i_uid = sbi->s_uid;
fs/isofs/inode.c:			inode->i_gid = sbi->s_gid;
fs/isofs/inode.c:	if (S_ISDIR(inode->i_mode) && sbi->s_overriderockperm &&
fs/isofs/inode.c:		inode->i_mode = S_IFDIR | sbi->s_dmode;
fs/isofs/inode.c:	if (S_ISREG(inode->i_mode) && sbi->s_overriderockperm &&
fs/isofs/inode.c:		inode->i_mode = S_IFREG | sbi->s_fmode;
fs/isofs/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/isofs/inode.c:		inode->i_fop = &generic_ro_fops;
fs/isofs/inode.c:			inode->i_data.a_ops = &zisofs_aops;
fs/isofs/inode.c:			inode->i_data.a_ops = &isofs_aops;
fs/isofs/inode.c:	} else if (S_ISDIR(inode->i_mode)) {
fs/isofs/inode.c:		inode->i_op = &isofs_dir_inode_operations;
fs/isofs/inode.c:		inode->i_fop = &isofs_dir_operations;
fs/isofs/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/isofs/inode.c:		inode->i_op = &page_symlink_inode_operations;
fs/isofs/inode.c:		inode->i_data.a_ops = &isofs_symlink_aops;
fs/isofs/inode.c:		init_special_inode(inode, inode->i_mode, inode->i_rdev);
fs/isofs/inode.c:	if (inode->i_state & I_NEW) {
fs/isofs/rock.c:	ISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;
fs/isofs/rock.c:	if (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {
fs/isofs/rock.c:		rs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;
fs/isofs/rock.c:		rs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;
fs/isofs/rock.c:	int blocksize = 1 << rs->inode->i_blkbits;
fs/isofs/rock.c:		bh = sb_bread(rs->inode->i_sb, rs->cont_extent);
fs/isofs/rock.c:	if (!ISOFS_SB(inode->i_sb)->s_rock)
fs/isofs/rock.c:	if (!ISOFS_SB(inode->i_sb)->s_rock)
fs/isofs/rock.c:			ISOFS_SB(inode->i_sb)->s_rock = 1;
fs/isofs/rock.c:			inode->i_mode = isonum_733(rr->u.PX.mode);
fs/isofs/rock.c:					inode->i_rdev =
fs/isofs/rock.c:					inode->i_rdev =
fs/isofs/rock.c:				inode->i_ctime.tv_sec =
fs/isofs/rock.c:				inode->i_ctime.tv_nsec = 0;
fs/isofs/rock.c:				inode->i_mtime.tv_sec =
fs/isofs/rock.c:				inode->i_mtime.tv_nsec = 0;
fs/isofs/rock.c:				inode->i_atime.tv_sec =
fs/isofs/rock.c:				inode->i_atime.tv_nsec = 0;
fs/isofs/rock.c:				inode->i_ctime.tv_sec =
fs/isofs/rock.c:				inode->i_ctime.tv_nsec = 0;
fs/isofs/rock.c:				inode->i_size = symlink_len;
fs/isofs/rock.c:						inode->i_size +=
fs/isofs/rock.c:						inode->i_size += 1;
fs/isofs/rock.c:						inode->i_size += 2;
fs/isofs/rock.c:						inode->i_size += 1;
fs/isofs/rock.c:							inode->i_size +=
fs/isofs/rock.c:						inode->i_size += 1;
fs/isofs/rock.c:			symlink_len = inode->i_size;
fs/isofs/rock.c:			    isofs_iget(inode->i_sb,
fs/isofs/rock.c:			inode->i_mode = reloc->i_mode;
fs/isofs/rock.c:			inode->i_uid = reloc->i_uid;
fs/isofs/rock.c:			inode->i_gid = reloc->i_gid;
fs/isofs/rock.c:			inode->i_rdev = reloc->i_rdev;
fs/isofs/rock.c:			inode->i_size = reloc->i_size;
fs/isofs/rock.c:			inode->i_blocks = reloc->i_blocks;
fs/isofs/rock.c:			inode->i_atime = reloc->i_atime;
fs/isofs/rock.c:			inode->i_ctime = reloc->i_ctime;
fs/isofs/rock.c:			inode->i_mtime = reloc->i_mtime;
fs/isofs/rock.c:			if (ISOFS_SB(inode->i_sb)->s_nocompress)
fs/isofs/rock.c:					inode->i_size =
fs/isofs/rock.c:	if ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)
fs/isofs/rock.c:	    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {
fs/isofs/rock.c:	struct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);
fs/isofs/rock.c:	bh = sb_bread(inode->i_sb, block);
fs/isofs/joliet.c:	utf8 = ISOFS_SB(inode->i_sb)->s_utf8;
fs/isofs/joliet.c:	nls = ISOFS_SB(inode->i_sb)->s_nls_iocharset;
fs/isofs/dir.c:	struct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);
fs/isofs/dir.c:	while (filp->f_pos < inode->i_size) {
fs/isofs/dir.c:			       inode->i_ino);
fs/isofs/dir.c:			if (filldir(dirent, ".", 1, filp->f_pos, inode->i_ino, DT_DIR) < 0)
fs/isofs/compress.c:					       zerr, inode->i_ino, curpage,
fs/isofs/compress.c:	end_off = min_t(loff_t, start_off + PAGE_CACHE_SIZE, inode->i_size);
fs/isofs/compress.c:	struct address_space *mapping = inode->i_mapping;
fs/isofs/compress.c:	end_index = (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
fs/isofs/export.c:	if (generation && inode->i_generation != generation) {
fs/isofs/export.c:	if (!S_ISDIR(child_inode->i_mode)) {
fs/isofs/export.c:	if (e_child_inode->i_iget5_offset != 0) {
fs/isofs/export.c:	parent_block = e_child_inode->i_iget5_block;
fs/isofs/export.c:	bh = sb_bread(child_inode->i_sb, parent_block);
fs/isofs/export.c:	rv = d_obtain_alias(isofs_iget(child_inode->i_sb, parent_block,
fs/isofs/export.c:	fh32[2] = inode->i_generation;
fs/coda/inode.c:	call_rcu(&inode->i_rcu, coda_i_callback);
fs/coda/inode.c:	if (!S_ISCHR(inode->i_mode) || imajor(inode) != CODA_PSDEV_MAJOR) {
fs/coda/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/coda/inode.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/coda/inode.c:	error = venus_setattr(inode->i_sb, coda_i2f(inode), &vattr);
fs/coda/pioctl.c:	if (target_inode->i_sb != inode->i_sb) {
fs/coda/pioctl.c:	error = venus_pioctl(inode->i_sb, &(cnp->c_fid), cmd, &data);
fs/coda/cache.c:	if ( !inode || !S_ISDIR(inode->i_mode)) 
fs/coda/dir.c:/* dir inode-ops */
fs/coda/dir.c:	error = venus_access(inode->i_sb, coda_i2f(inode), mask);
fs/coda/dir.c:	error = venus_link(dir_inode->i_sb, coda_i2f(inode),
fs/coda/dir.c:	error = venus_symlink(dir_inode->i_sb, coda_i2f(dir_inode), name, len,
fs/coda/dir.c:			if (S_ISDIR(new_dentry->d_inode->i_mode)) {
fs/coda/dir.c:		mutex_lock(&host_inode->i_mutex);
fs/coda/dir.c:		mutex_unlock(&host_inode->i_mutex);
fs/coda/dir.c:		ret = filldir(buf, ".", 1, 0, de->d_inode->i_ino, DT_DIR);
fs/coda/dir.c:		error = venus_getattr(inode->i_sb, &(cii->c_fid), &attr);
fs/coda/dir.c:		old_mode = inode->i_mode;
fs/coda/dir.c:		old_ino = inode->i_ino;
fs/coda/dir.c:		if ((old_mode & S_IFMT) != (inode->i_mode & S_IFMT)) {
fs/coda/dir.c:			       inode->i_ino, coda_f2s(&(cii->c_fid)));
fs/coda/dir.c:		if (inode->i_ino != old_ino)
fs/coda/symlink.c:	error = venus_readlink(inode->i_sb, &cii->c_fid, p, &len);
fs/coda/coda_linux.c:	inode->i_mode |= inode_type;
fs/coda/coda_linux.c:	        inode->i_mode = attr->va_mode | inode_type;
fs/coda/coda_linux.c:	        inode->i_uid = (uid_t) attr->va_uid;
fs/coda/coda_linux.c:	        inode->i_gid = (gid_t) attr->va_gid;
fs/coda/coda_linux.c:	        inode->i_size = attr->va_size;
fs/coda/coda_linux.c:		inode->i_blocks = (attr->va_size + 511) >> 9;
fs/coda/coda_linux.c:	        inode->i_atime = attr->va_atime;
fs/coda/coda_linux.c:	        inode->i_mtime = attr->va_mtime;
fs/coda/coda_linux.c:	        inode->i_ctime = attr->va_ctime;
fs/coda/cnode.c:        if (S_ISREG(inode->i_mode)) {
fs/coda/cnode.c:                inode->i_op = &coda_file_inode_operations;
fs/coda/cnode.c:                inode->i_fop = &coda_file_operations;
fs/coda/cnode.c:        } else if (S_ISDIR(inode->i_mode)) {
fs/coda/cnode.c:                inode->i_op = &coda_dir_inode_operations;
fs/coda/cnode.c:                inode->i_fop = &coda_dir_operations;
fs/coda/cnode.c:        } else if (S_ISLNK(inode->i_mode)) {
fs/coda/cnode.c:		inode->i_op = &coda_symlink_inode_operations;
fs/coda/cnode.c:		inode->i_data.a_ops = &coda_symlink_aops;
fs/coda/cnode.c:		inode->i_mapping = &inode->i_data;
fs/coda/cnode.c:                init_special_inode(inode, inode->i_mode, huge_decode_dev(attr->va_rdev));
fs/coda/cnode.c:	if (inode->i_state & I_NEW) {
fs/coda/cnode.c:		inode->i_ino = hash;
fs/coda/cnode.c:	inode->i_ino = hash;
fs/coda/cnode.c:	BUG_ON(inode->i_state & I_NEW);
fs/coda/cnode.c:		inode->i_ino = CTL_INO;
fs/coda/cnode.c:		inode->i_op = &coda_ioctl_inode_operations;
fs/coda/cnode.c:		inode->i_fop = &coda_ioctl_operations;
fs/coda/cnode.c:		inode->i_mode = 0444;
fs/coda/file.c:	mutex_lock(&coda_inode->i_mutex);
fs/coda/file.c:	coda_inode->i_size = host_inode->i_size;
fs/coda/file.c:	coda_inode->i_blocks = (coda_inode->i_size + 511) >> 9;
fs/coda/file.c:	coda_inode->i_mtime = coda_inode->i_ctime = CURRENT_TIME_SEC;
fs/coda/file.c:	mutex_unlock(&coda_inode->i_mutex);
fs/coda/file.c:	if (coda_inode->i_mapping == &coda_inode->i_data)
fs/coda/file.c:		coda_inode->i_mapping = host_inode->i_mapping;
fs/coda/file.c:	else if (coda_inode->i_mapping != host_inode->i_mapping) {
fs/coda/file.c:	error = venus_open(coda_inode->i_sb, coda_i2f(coda_inode), coda_flags,
fs/coda/file.c:	err = venus_close(coda_inode->i_sb, coda_i2f(coda_inode),
fs/coda/file.c:	if (coda_inode->i_mapping == &host_inode->i_data) {
fs/coda/file.c:			coda_inode->i_mapping = &coda_inode->i_data;
fs/coda/file.c:	if (!(S_ISREG(coda_inode->i_mode) || S_ISDIR(coda_inode->i_mode) ||
fs/coda/file.c:	      S_ISLNK(coda_inode->i_mode)))
fs/coda/file.c:	err = filemap_write_and_wait_range(coda_inode->i_mapping, start, end);
fs/coda/file.c:	mutex_lock(&coda_inode->i_mutex);
fs/coda/file.c:		err = venus_fsync(coda_inode->i_sb, coda_i2f(coda_inode));
fs/coda/file.c:	mutex_unlock(&coda_inode->i_mutex);
fs/utimes.c:	mutex_lock(&inode->i_mutex);
fs/utimes.c:	mutex_unlock(&inode->i_mutex);
fs/jffs2/nodelist.h:/* NB: REF_PRISTINE for an inode-less node (ref->next_in_ino == NULL) indicates
fs/jffs2/nodelist.h:   copied. If you need to do anything different to GC inode-less nodes, then
fs/jffs2/super.c:	call_rcu(&inode->i_rcu, jffs2_i_callback);
fs/jffs2/super.c:	BUG_ON(!S_ISDIR(child->d_inode->i_mode));
fs/jffs2/super.c:	return d_obtain_alias(jffs2_iget(child->d_inode->i_sb, pino));
fs/jffs2/nodelist.c:/* Doesn't set inode->i_size */
fs/jffs2/jffs2_fs_i.h:	/* We need an internal mutex similar to inode->i_mutex.
fs/jffs2/dir.c:		  filp->f_path.dentry->d_inode->i_ino);
fs/jffs2/dir.c:		jffs2_dbg(1, "Dirent 0: \".\", ino #%lu\n", inode->i_ino);
fs/jffs2/dir.c:		if (filldir(dirent, ".", 1, 0, inode->i_ino, DT_DIR) < 0)
fs/jffs2/dir.c:	inode->i_op = &jffs2_file_inode_operations;
fs/jffs2/dir.c:	inode->i_fop = &jffs2_file_operations;
fs/jffs2/dir.c:	inode->i_mapping->a_ops = &jffs2_file_address_operations;
fs/jffs2/dir.c:	inode->i_mapping->nrpages = 0;
fs/jffs2/dir.c:		  __func__, inode->i_ino, inode->i_mode, inode->i_nlink,
fs/jffs2/dir.c:		  f->inocache->pino_nlink, inode->i_mapping->nrpages);
fs/jffs2/dir.c:	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dentry->d_inode->i_sb);
fs/jffs2/dir.c:	if (S_ISDIR(old_dentry->d_inode->i_mode))
fs/jffs2/dir.c:	type = (old_dentry->d_inode->i_mode & S_IFMT) >> 12;
fs/jffs2/dir.c:	inode->i_op = &jffs2_symlink_inode_operations;
fs/jffs2/dir.c:	inode->i_size = targetlen;
fs/jffs2/dir.c:	ri->isize = ri->dsize = ri->csize = cpu_to_je32(inode->i_size);
fs/jffs2/dir.c:	ri->totlen = cpu_to_je32(sizeof(*ri) + inode->i_size);
fs/jffs2/dir.c:	rd->ino = cpu_to_je32(inode->i_ino);
fs/jffs2/dir.c:	inode->i_op = &jffs2_dir_inode_operations;
fs/jffs2/dir.c:	inode->i_fop = &jffs2_dir_operations;
fs/jffs2/dir.c:	rd->ino = cpu_to_je32(inode->i_ino);
fs/jffs2/dir.c:	inode->i_op = &jffs2_file_inode_operations;
fs/jffs2/dir.c:	init_special_inode(inode, inode->i_mode, rdev);
fs/jffs2/dir.c:	rd->ino = cpu_to_je32(inode->i_ino);
fs/jffs2/dir.c:		if (S_ISDIR(new_dentry->d_inode->i_mode)) {
fs/jffs2/dir.c:	type = (old_dentry->d_inode->i_mode & S_IFMT) >> 12;
fs/jffs2/dir.c:			    old_dentry->d_inode->i_ino, type,
fs/jffs2/dir.c:		if (S_ISDIR(new_dentry->d_inode->i_mode))
fs/jffs2/dir.c:			if (S_ISDIR(new_dentry->d_inode->i_mode))
fs/jffs2/dir.c:	if (S_ISDIR(old_dentry->d_inode->i_mode) && !victim_f)
fs/jffs2/dir.c:	/* We don't touch inode->i_nlink */
fs/jffs2/dir.c:		if (f->inocache && !S_ISDIR(old_dentry->d_inode->i_mode))
fs/jffs2/dir.c:	if (S_ISDIR(old_dentry->d_inode->i_mode))
fs/jffs2/scan.c:	 * ref->ino is used to store 32bit inode-number, ic is not used
fs/jffs2/gc.c:		/* If it's inode-less, we don't _know_ what it is. Just copy it intact */
fs/jffs2/file.c:	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
fs/jffs2/file.c:	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/jffs2/file.c:	mutex_lock(&inode->i_mutex);
fs/jffs2/file.c:	jffs2_flush_wbuf_gc(c, inode->i_ino);
fs/jffs2/file.c:	mutex_unlock(&inode->i_mutex);
fs/jffs2/file.c:	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
fs/jffs2/file.c:		  __func__, inode->i_ino, pg->index << PAGE_CACHE_SHIFT);
fs/jffs2/file.c:	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
fs/jffs2/file.c:	if (pageofs > inode->i_size) {
fs/jffs2/file.c:			  (unsigned int)inode->i_size, pageofs);
fs/jffs2/file.c:		ri.mode = cpu_to_jemode(inode->i_mode);
fs/jffs2/file.c:		ri.isize = cpu_to_je32(max((uint32_t)inode->i_size, pageofs));
fs/jffs2/file.c:		ri.offset = cpu_to_je32(inode->i_size);
fs/jffs2/file.c:		ri.dsize = cpu_to_je32(pageofs - inode->i_size);
fs/jffs2/file.c:		inode->i_size = pageofs;
fs/jffs2/file.c:	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
fs/jffs2/file.c:		  __func__, inode->i_ino, pg->index << PAGE_CACHE_SHIFT,
fs/jffs2/file.c:	ri->ino = cpu_to_je32(inode->i_ino);
fs/jffs2/file.c:	ri->mode = cpu_to_jemode(inode->i_mode);
fs/jffs2/file.c:	ri->isize = cpu_to_je32((uint32_t)inode->i_size);
fs/jffs2/file.c:		if (inode->i_size < pos + writtenlen) {
fs/jffs2/file.c:			inode->i_size = pos + writtenlen;
fs/jffs2/file.c:			inode->i_blocks = (inode->i_size + 511) >> 9;
fs/jffs2/file.c:			inode->i_ctime = inode->i_mtime = ITIME(je32_to_cpu(ri->ctime));
fs/jffs2/acl.c:	if (S_ISLNK(inode->i_mode))
fs/jffs2/acl.c:			umode_t mode = inode->i_mode;
fs/jffs2/acl.c:			if (inode->i_mode != mode) {
fs/jffs2/acl.c:		if (!S_ISDIR(inode->i_mode))
fs/jffs2/acl.c:	if (inode->i_default_acl) {
fs/jffs2/acl.c:		rc = __jffs2_set_acl(inode, JFFS2_XPREFIX_ACL_DEFAULT, inode->i_default_acl);
fs/jffs2/acl.c:	if (inode->i_acl) {
fs/jffs2/acl.c:		rc = __jffs2_set_acl(inode, JFFS2_XPREFIX_ACL_ACCESS, inode->i_acl);
fs/jffs2/acl.c:	if (S_ISLNK(inode->i_mode))
fs/jffs2/acl.c:	rc = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
fs/jffs2/fs.c:	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
fs/jffs2/fs.c:	jffs2_dbg(1, "%s(): ino #%lu\n", __func__, inode->i_ino);
fs/jffs2/fs.c:	if (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode)) {
fs/jffs2/fs.c:		mdatalen = jffs2_encode_dev(&dev, inode->i_rdev);
fs/jffs2/fs.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/jffs2/fs.c:		if (S_ISLNK(inode->i_mode))
fs/jffs2/fs.c:		if (S_ISLNK(inode->i_mode))
fs/jffs2/fs.c:	ri->ino = cpu_to_je32(inode->i_ino);
fs/jffs2/fs.c:		ri->mode = cpu_to_jemode(inode->i_mode);
fs/jffs2/fs.c:	ri->isize = cpu_to_je32((ivalid & ATTR_SIZE)?iattr->ia_size:inode->i_size);
fs/jffs2/fs.c:	ri->atime = cpu_to_je32(I_SEC((ivalid & ATTR_ATIME)?iattr->ia_atime:inode->i_atime));
fs/jffs2/fs.c:	ri->mtime = cpu_to_je32(I_SEC((ivalid & ATTR_MTIME)?iattr->ia_mtime:inode->i_mtime));
fs/jffs2/fs.c:	ri->ctime = cpu_to_je32(I_SEC((ivalid & ATTR_CTIME)?iattr->ia_ctime:inode->i_ctime));
fs/jffs2/fs.c:	if (ivalid & ATTR_SIZE && inode->i_size < iattr->ia_size) {
fs/jffs2/fs.c:		ri->dsize = cpu_to_je32(iattr->ia_size - inode->i_size);
fs/jffs2/fs.c:		ri->offset = cpu_to_je32(inode->i_size);
fs/jffs2/fs.c:	if (S_ISLNK(inode->i_mode))
fs/jffs2/fs.c:	inode->i_atime = ITIME(je32_to_cpu(ri->atime));
fs/jffs2/fs.c:	inode->i_ctime = ITIME(je32_to_cpu(ri->ctime));
fs/jffs2/fs.c:	inode->i_mtime = ITIME(je32_to_cpu(ri->mtime));
fs/jffs2/fs.c:	inode->i_mode = jemode_to_cpu(ri->mode);
fs/jffs2/fs.c:	if (ivalid & ATTR_SIZE && inode->i_size > iattr->ia_size)
fs/jffs2/fs.c:	if (ivalid & ATTR_SIZE && inode->i_size < iattr->ia_size) {
fs/jffs2/fs.c:		inode->i_size = iattr->ia_size;
fs/jffs2/fs.c:		inode->i_blocks = (inode->i_size + 511) >> 9;
fs/jffs2/fs.c:	if (ivalid & ATTR_SIZE && inode->i_size > iattr->ia_size) {
fs/jffs2/fs.c:		inode->i_blocks = (inode->i_size + 511) >> 9;
fs/jffs2/fs.c:	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
fs/jffs2/fs.c:		  __func__, inode->i_ino, inode->i_mode);
fs/jffs2/fs.c:	truncate_inode_pages(&inode->i_data, 0);
fs/jffs2/fs.c:	if (!(inode->i_state & I_NEW))
fs/jffs2/fs.c:	c = JFFS2_SB_INFO(inode->i_sb);
fs/jffs2/fs.c:	ret = jffs2_do_read_inode(c, f, inode->i_ino, &latest_node);
fs/jffs2/fs.c:	inode->i_mode = jemode_to_cpu(latest_node.mode);
fs/jffs2/fs.c:	inode->i_size = je32_to_cpu(latest_node.isize);
fs/jffs2/fs.c:	inode->i_atime = ITIME(je32_to_cpu(latest_node.atime));
fs/jffs2/fs.c:	inode->i_mtime = ITIME(je32_to_cpu(latest_node.mtime));
fs/jffs2/fs.c:	inode->i_ctime = ITIME(je32_to_cpu(latest_node.ctime));
fs/jffs2/fs.c:	inode->i_blocks = (inode->i_size + 511) >> 9;
fs/jffs2/fs.c:	switch (inode->i_mode & S_IFMT) {
fs/jffs2/fs.c:		inode->i_op = &jffs2_symlink_inode_operations;
fs/jffs2/fs.c:		if (inode->i_ino == 1)
fs/jffs2/fs.c:		inode->i_op = &jffs2_dir_inode_operations;
fs/jffs2/fs.c:		inode->i_fop = &jffs2_dir_operations;
fs/jffs2/fs.c:		inode->i_op = &jffs2_file_inode_operations;
fs/jffs2/fs.c:		inode->i_fop = &jffs2_file_operations;
fs/jffs2/fs.c:		inode->i_mapping->a_ops = &jffs2_file_address_operations;
fs/jffs2/fs.c:		inode->i_mapping->nrpages = 0;
fs/jffs2/fs.c:				  (unsigned long)inode->i_ino);
fs/jffs2/fs.c:		inode->i_op = &jffs2_file_inode_operations;
fs/jffs2/fs.c:		init_special_inode(inode, inode->i_mode, rdev);
fs/jffs2/fs.c:			__func__, inode->i_mode, (unsigned long)inode->i_ino);
fs/jffs2/fs.c:	if (!(inode->i_state & I_DIRTY_DATASYNC)) {
fs/jffs2/fs.c:			  __func__, inode->i_ino);
fs/jffs2/fs.c:		  __func__, inode->i_ino);
fs/jffs2/fs.c:	iattr.ia_mode = inode->i_mode;
fs/jffs2/fs.c:	iattr.ia_uid = inode->i_uid;
fs/jffs2/fs.c:	iattr.ia_gid = inode->i_gid;
fs/jffs2/fs.c:	iattr.ia_atime = inode->i_atime;
fs/jffs2/fs.c:	iattr.ia_mtime = inode->i_mtime;
fs/jffs2/fs.c:	iattr.ia_ctime = inode->i_ctime;
fs/jffs2/fs.c:	inode->i_ino = je32_to_cpu(ri->ino);
fs/jffs2/fs.c:	inode->i_mode = jemode_to_cpu(ri->mode);
fs/jffs2/fs.c:	inode->i_atime = inode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;
fs/jffs2/fs.c:	ri->atime = ri->mtime = ri->ctime = cpu_to_je32(I_SEC(inode->i_mtime));
fs/jffs2/fs.c:	inode->i_blocks = 0;
fs/jffs2/fs.c:	inode->i_size = 0;
fs/jffs2/fs.c:	pg = read_cache_page_async(inode->i_mapping, offset >> PAGE_CACHE_SHIFT,
fs/jffs2/xattr.c:	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
fs/jffs2/xattr.c:	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
fs/jffs2/xattr.c:	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
fs/buffer.c:	struct address_space *bd_mapping = bd_inode->i_mapping;
fs/buffer.c:	index = block >> (PAGE_CACHE_SHIFT - bd_inode->i_blkbits);
fs/buffer.c:			1 << bd_inode->i_blkbits);
fs/buffer.c:	return !list_empty(&inode->i_data.private_list);
fs/buffer.c:	struct address_space *mapping = inode->i_mapping;
fs/buffer.c:		struct address_space *mapping = &inode->i_data;
fs/buffer.c:		struct address_space *mapping = &inode->i_data;
fs/buffer.c:	page = find_or_create_page(inode->i_mapping, index,
fs/buffer.c:		(mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS)|__GFP_MOVABLE);
fs/buffer.c:	spin_lock(&inode->i_mapping->private_lock);
fs/buffer.c:	spin_unlock(&inode->i_mapping->private_lock);
fs/buffer.c:		create_empty_buffers(page, 1 << ACCESS_ONCE(inode->i_blkbits), b_state);
fs/buffer.c:	if (pos+copied > inode->i_size) {
fs/buffer.c:	struct address_space *mapping = inode->i_mapping;
fs/buffer.c:	unsigned blocksize = 1 << inode->i_blkbits;
fs/buffer.c:	unsigned blocksize = 1 << inode->i_blkbits;
fs/buffer.c:	if ((page->mapping != inode->i_mapping) ||
fs/buffer.c:	struct super_block *sb = vma->vm_file->f_path.dentry->d_inode->i_sb;
fs/buffer.c:	const unsigned blkbits = inode->i_blkbits;
fs/buffer.c:	if (pos+copied > inode->i_size) {
fs/buffer.c:	blocksize = 1 << inode->i_blkbits;
fs/buffer.c:	iblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/buffer.c:	blocksize = 1 << inode->i_blkbits;
fs/buffer.c:	iblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/buffer.c:	tmp.b_size = 1 << inode->i_blkbits;
fs/dlm/debug_fs.c:	seq->private = inode->i_private; /* the dlm_ls */
fs/direct-io.c: * fs blocksize, (1 << inode->i_blkbits).
fs/direct-io.c: * it uses the passed inode-relative block number as the file offset, as usual.
fs/direct-io.c:	nblocks = map_bh->b_size >> dio->inode->i_blkbits;
fs/direct-io.c:	unsigned i_blkbits = ACCESS_ONCE(inode->i_blkbits);
fs/direct-io.c:			mutex_lock(&inode->i_mutex);
fs/direct-io.c:				mutex_unlock(&inode->i_mutex);
fs/direct-io.c:	atomic_inc(&inode->i_dio_count);
fs/direct-io.c:		mutex_unlock(&dio->inode->i_mutex);
fs/ext2/inode.c:		(inode->i_sb->s_blocksize >> 9) : 0;
fs/ext2/inode.c:	return (S_ISLNK(inode->i_mode) &&
fs/ext2/inode.c:		inode->i_blocks - ea_blocks == 0);
fs/ext2/inode.c:	if (to > inode->i_size) {
fs/ext2/inode.c:		truncate_pagecache(inode, to, inode->i_size);
fs/ext2/inode.c:		ext2_truncate_blocks(inode, inode->i_size);
fs/ext2/inode.c:	if (!inode->i_nlink && !is_bad_inode(inode)) {
fs/ext2/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/ext2/inode.c:		sb_start_intwrite(inode->i_sb);
fs/ext2/inode.c:		inode->i_size = 0;
fs/ext2/inode.c:		if (inode->i_blocks)
fs/ext2/inode.c:		sb_end_intwrite(inode->i_sb);
fs/ext2/inode.c: *	inode->i_sb).
fs/ext2/inode.c:	int ptrs = EXT2_ADDR_PER_BLOCK(inode->i_sb);
fs/ext2/inode.c:	int ptrs_bits = EXT2_ADDR_PER_BLOCK_BITS(inode->i_sb);
fs/ext2/inode.c:		ext2_msg(inode->i_sb, KERN_WARNING,
fs/ext2/inode.c:		ext2_msg(inode->i_sb, KERN_WARNING,
fs/ext2/inode.c:	struct super_block *sb = inode->i_sb;
fs/ext2/inode.c:	bg_start = ext2_group_first_block_no(inode->i_sb, ei->i_block_group);
fs/ext2/inode.c:			(EXT2_BLOCKS_PER_GROUP(inode->i_sb) / 16);
fs/ext2/inode.c:	int blocksize = inode->i_sb->s_blocksize;
fs/ext2/inode.c:		bh = sb_getblk(inode->i_sb, new_blocks[n-1]);
fs/ext2/inode.c:		if (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))
fs/ext2/inode.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/ext2/inode.c:	if (S_ISREG(inode->i_mode) && (!ei->i_block_alloc_info))
fs/ext2/inode.c:	if (ext2_use_xip(inode->i_sb)) {
fs/ext2/inode.c:	map_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));
fs/ext2/inode.c:	unsigned max_blocks = bh_result->b_size >> inode->i_blkbits;
fs/ext2/inode.c:		bh_result->b_size = (ret << inode->i_blkbits);
fs/ext2/inode.c: *	stored as little-endian 32-bit) and updating @inode->i_blocks
fs/ext2/inode.c: *	stored as little-endian 32-bit) and updating @inode->i_blocks
fs/ext2/inode.c:		int addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);
fs/ext2/inode.c:			bh = sb_bread(inode->i_sb, nr);
fs/ext2/inode.c:				ext2_error(inode->i_sb, "ext2_free_branches",
fs/ext2/inode.c:					inode->i_ino, nr);
fs/ext2/inode.c:	int addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);
fs/ext2/inode.c:	blocksize = inode->i_sb->s_blocksize;
fs/ext2/inode.c:	iblock = (offset + blocksize-1) >> EXT2_BLOCK_SIZE_BITS(inode->i_sb);
fs/ext2/inode.c:	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
fs/ext2/inode.c:	    S_ISLNK(inode->i_mode)))
fs/ext2/inode.c:	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
fs/ext2/inode.c:	    S_ISLNK(inode->i_mode)))
fs/ext2/inode.c:	if (mapping_is_xip(inode->i_mapping))
fs/ext2/inode.c:		error = xip_truncate_page(inode->i_mapping, newsize);
fs/ext2/inode.c:	else if (test_opt(inode->i_sb, NOBH))
fs/ext2/inode.c:		error = nobh_truncate_page(inode->i_mapping,
fs/ext2/inode.c:		error = block_truncate_page(inode->i_mapping,
fs/ext2/inode.c:	inode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;
fs/ext2/inode.c:		sync_mapping_buffers(inode->i_mapping);
fs/ext2/inode.c:	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);
fs/ext2/inode.c:		inode->i_flags |= S_SYNC;
fs/ext2/inode.c:		inode->i_flags |= S_APPEND;
fs/ext2/inode.c:		inode->i_flags |= S_IMMUTABLE;
fs/ext2/inode.c:		inode->i_flags |= S_NOATIME;
fs/ext2/inode.c:		inode->i_flags |= S_DIRSYNC;
fs/ext2/inode.c:	if (!(inode->i_state & I_NEW))
fs/ext2/inode.c:	raw_inode = ext2_get_inode(inode->i_sb, ino, &bh);
fs/ext2/inode.c:	inode->i_mode = le16_to_cpu(raw_inode->i_mode);
fs/ext2/inode.c:	i_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
fs/ext2/inode.c:	i_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
fs/ext2/inode.c:	if (!(test_opt (inode->i_sb, NO_UID32))) {
fs/ext2/inode.c:		i_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;
fs/ext2/inode.c:		i_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;
fs/ext2/inode.c:	set_nlink(inode, le16_to_cpu(raw_inode->i_links_count));
fs/ext2/inode.c:	inode->i_size = le32_to_cpu(raw_inode->i_size);
fs/ext2/inode.c:	inode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);
fs/ext2/inode.c:	inode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);
fs/ext2/inode.c:	inode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);
fs/ext2/inode.c:	inode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;
fs/ext2/inode.c:	ei->i_dtime = le32_to_cpu(raw_inode->i_dtime);
fs/ext2/inode.c:	if (inode->i_nlink == 0 && (inode->i_mode == 0 || ei->i_dtime)) {
fs/ext2/inode.c:	inode->i_blocks = le32_to_cpu(raw_inode->i_blocks);
fs/ext2/inode.c:	ei->i_flags = le32_to_cpu(raw_inode->i_flags);
fs/ext2/inode.c:	ei->i_faddr = le32_to_cpu(raw_inode->i_faddr);
fs/ext2/inode.c:	ei->i_frag_no = raw_inode->i_frag;
fs/ext2/inode.c:	ei->i_frag_size = raw_inode->i_fsize;
fs/ext2/inode.c:	ei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);
fs/ext2/inode.c:	if (S_ISREG(inode->i_mode))
fs/ext2/inode.c:		inode->i_size |= ((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;
fs/ext2/inode.c:		ei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);
fs/ext2/inode.c:	inode->i_generation = le32_to_cpu(raw_inode->i_generation);
fs/ext2/inode.c:	ei->i_block_group = (ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);
fs/ext2/inode.c:		ei->i_data[n] = raw_inode->i_block[n];
fs/ext2/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/ext2/inode.c:		inode->i_op = &ext2_file_inode_operations;
fs/ext2/inode.c:		if (ext2_use_xip(inode->i_sb)) {
fs/ext2/inode.c:			inode->i_mapping->a_ops = &ext2_aops_xip;
fs/ext2/inode.c:			inode->i_fop = &ext2_xip_file_operations;
fs/ext2/inode.c:		} else if (test_opt(inode->i_sb, NOBH)) {
fs/ext2/inode.c:			inode->i_mapping->a_ops = &ext2_nobh_aops;
fs/ext2/inode.c:			inode->i_fop = &ext2_file_operations;
fs/ext2/inode.c:			inode->i_mapping->a_ops = &ext2_aops;
fs/ext2/inode.c:			inode->i_fop = &ext2_file_operations;
fs/ext2/inode.c:	} else if (S_ISDIR(inode->i_mode)) {
fs/ext2/inode.c:		inode->i_op = &ext2_dir_inode_operations;
fs/ext2/inode.c:		inode->i_fop = &ext2_dir_operations;
fs/ext2/inode.c:		if (test_opt(inode->i_sb, NOBH))
fs/ext2/inode.c:			inode->i_mapping->a_ops = &ext2_nobh_aops;
fs/ext2/inode.c:			inode->i_mapping->a_ops = &ext2_aops;
fs/ext2/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/ext2/inode.c:			inode->i_op = &ext2_fast_symlink_inode_operations;
fs/ext2/inode.c:			nd_terminate_link(ei->i_data, inode->i_size,
fs/ext2/inode.c:			inode->i_op = &ext2_symlink_inode_operations;
fs/ext2/inode.c:			if (test_opt(inode->i_sb, NOBH))
fs/ext2/inode.c:				inode->i_mapping->a_ops = &ext2_nobh_aops;
fs/ext2/inode.c:				inode->i_mapping->a_ops = &ext2_aops;
fs/ext2/inode.c:		inode->i_op = &ext2_special_inode_operations;
fs/ext2/inode.c:		if (raw_inode->i_block[0])
fs/ext2/inode.c:			init_special_inode(inode, inode->i_mode,
fs/ext2/inode.c:			   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));
fs/ext2/inode.c:			init_special_inode(inode, inode->i_mode,
fs/ext2/inode.c:			   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));
fs/ext2/inode.c:	struct super_block *sb = inode->i_sb;
fs/ext2/inode.c:	ino_t ino = inode->i_ino;
fs/ext2/inode.c:	raw_inode->i_mode = cpu_to_le16(inode->i_mode);
fs/ext2/inode.c:		raw_inode->i_uid_low = cpu_to_le16(low_16_bits(uid));
fs/ext2/inode.c:		raw_inode->i_gid_low = cpu_to_le16(low_16_bits(gid));
fs/ext2/inode.c:			raw_inode->i_uid_high = cpu_to_le16(high_16_bits(uid));
fs/ext2/inode.c:			raw_inode->i_gid_high = cpu_to_le16(high_16_bits(gid));
fs/ext2/inode.c:			raw_inode->i_uid_high = 0;
fs/ext2/inode.c:			raw_inode->i_gid_high = 0;
fs/ext2/inode.c:		raw_inode->i_uid_low = cpu_to_le16(fs_high2lowuid(uid));
fs/ext2/inode.c:		raw_inode->i_gid_low = cpu_to_le16(fs_high2lowgid(gid));
fs/ext2/inode.c:		raw_inode->i_uid_high = 0;
fs/ext2/inode.c:		raw_inode->i_gid_high = 0;
fs/ext2/inode.c:	raw_inode->i_links_count = cpu_to_le16(inode->i_nlink);
fs/ext2/inode.c:	raw_inode->i_size = cpu_to_le32(inode->i_size);
fs/ext2/inode.c:	raw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);
fs/ext2/inode.c:	raw_inode->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);
fs/ext2/inode.c:	raw_inode->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);
fs/ext2/inode.c:	raw_inode->i_blocks = cpu_to_le32(inode->i_blocks);
fs/ext2/inode.c:	raw_inode->i_dtime = cpu_to_le32(ei->i_dtime);
fs/ext2/inode.c:	raw_inode->i_flags = cpu_to_le32(ei->i_flags);
fs/ext2/inode.c:	raw_inode->i_faddr = cpu_to_le32(ei->i_faddr);
fs/ext2/inode.c:	raw_inode->i_frag = ei->i_frag_no;
fs/ext2/inode.c:	raw_inode->i_fsize = ei->i_frag_size;
fs/ext2/inode.c:	raw_inode->i_file_acl = cpu_to_le32(ei->i_file_acl);
fs/ext2/inode.c:	if (!S_ISREG(inode->i_mode))
fs/ext2/inode.c:		raw_inode->i_dir_acl = cpu_to_le32(ei->i_dir_acl);
fs/ext2/inode.c:		raw_inode->i_size_high = cpu_to_le32(inode->i_size >> 32);
fs/ext2/inode.c:		if (inode->i_size > 0x7fffffffULL) {
fs/ext2/inode.c:	raw_inode->i_generation = cpu_to_le32(inode->i_generation);
fs/ext2/inode.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {
fs/ext2/inode.c:		if (old_valid_dev(inode->i_rdev)) {
fs/ext2/inode.c:			raw_inode->i_block[0] =
fs/ext2/inode.c:				cpu_to_le32(old_encode_dev(inode->i_rdev));
fs/ext2/inode.c:			raw_inode->i_block[1] = 0;
fs/ext2/inode.c:			raw_inode->i_block[0] = 0;
fs/ext2/inode.c:			raw_inode->i_block[1] =
fs/ext2/inode.c:				cpu_to_le32(new_encode_dev(inode->i_rdev));
fs/ext2/inode.c:			raw_inode->i_block[2] = 0;
fs/ext2/inode.c:		raw_inode->i_block[n] = ei->i_data[n];
fs/ext2/inode.c:	if ((iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid)) ||
fs/ext2/inode.c:	    (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid))) {
fs/ext2/inode.c:	if (iattr->ia_valid & ATTR_SIZE && iattr->ia_size != inode->i_size) {
fs/ext2/super.c:	call_rcu(&inode->i_rcu, ext2_i_callback);
fs/ext2/super.c:	if (generation && inode->i_generation != generation) {
fs/ext2/super.c:	if (inode->i_size < off+len-towrite)
fs/ext2/super.c:	inode->i_version++;
fs/ext2/super.c:	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/ext2/xip.c:	struct block_device *bdev = inode->i_sb->s_bdev;
fs/ext2/dir.c:	return inode->i_sb->s_blocksize;
fs/ext2/dir.c:	return (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;
fs/ext2/dir.c:	unsigned last_byte = inode->i_size;
fs/ext2/dir.c:	umode_t mode = inode->i_mode;
fs/ext2/dir.c:	if (EXT2_HAS_INCOMPAT_FEATURE(inode->i_sb, EXT2_FEATURE_INCOMPAT_FILETYPE))
fs/ext2/dir.c:	struct super_block *sb = inode->i_sb;
fs/ext2/dir.c:	int need_revalidate = filp->f_version != inode->i_version;
fs/ext2/dir.c:	if (pos > inode->i_size - EXT2_DIR_REC_LEN(1))
fs/ext2/dir.c:				   inode->i_ino);
fs/ext2/dir.c:			filp->f_version = inode->i_version;
fs/ext2/dir.c:	de->inode = cpu_to_le32(inode->i_ino);
fs/ext2/dir.c:	de->inode = cpu_to_le32(inode->i_ino);
fs/ext2/dir.c:			ext2_error(inode->i_sb, __func__,
fs/ext2/dir.c:	inode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;
fs/ext2/dir.c:	struct page *page = grab_cache_page(inode->i_mapping, 0);
fs/ext2/dir.c:	de->inode = cpu_to_le32(inode->i_ino);
fs/ext2/dir.c:				ext2_error(inode->i_sb, __func__,
fs/ext2/dir.c:					    cpu_to_le32(inode->i_ino))
fs/ext2/balloc.c:	struct super_block *sb = inode->i_sb;
fs/ext2/balloc.c:	spinlock_t *rsv_lock = &EXT2_SB(inode->i_sb)->s_rsv_window_lock;
fs/ext2/balloc.c:			rsv_window_remove(inode->i_sb, rsv);
fs/ext2/balloc.c:	struct super_block * sb = inode->i_sb;
fs/ext2/balloc.c:	sb = inode->i_sb;
fs/ext2/file.c:	struct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;
fs/ext2/ioctl.c:		flags = ext2_mask_flags(inode->i_mode, flags);
fs/ext2/ioctl.c:		mutex_lock(&inode->i_mutex);
fs/ext2/ioctl.c:			mutex_unlock(&inode->i_mutex);
fs/ext2/ioctl.c:				mutex_unlock(&inode->i_mutex);
fs/ext2/ioctl.c:		inode->i_ctime = CURRENT_TIME_SEC;
fs/ext2/ioctl.c:		mutex_unlock(&inode->i_mutex);
fs/ext2/ioctl.c:		return put_user(inode->i_generation, (int __user *) arg);
fs/ext2/ioctl.c:		mutex_lock(&inode->i_mutex);
fs/ext2/ioctl.c:		inode->i_ctime = CURRENT_TIME_SEC;
fs/ext2/ioctl.c:		inode->i_generation = generation;
fs/ext2/ioctl.c:		mutex_unlock(&inode->i_mutex);
fs/ext2/ioctl.c:		if (test_opt(inode->i_sb, RESERVATION)
fs/ext2/ioctl.c:			&& S_ISREG(inode->i_mode)
fs/ext2/ioctl.c:		if (!test_opt(inode->i_sb, RESERVATION) ||!S_ISREG(inode->i_mode))
fs/ext2/acl.c: * inode->i_mutex: don't care
fs/ext2/acl.c:	if (!test_opt(inode->i_sb, POSIX_ACL))
fs/ext2/acl.c: * inode->i_mutex: down
fs/ext2/acl.c:	if (S_ISLNK(inode->i_mode))
fs/ext2/acl.c:	if (!test_opt(inode->i_sb, POSIX_ACL))
fs/ext2/acl.c:				error = posix_acl_equiv_mode(acl, &inode->i_mode);
fs/ext2/acl.c:					inode->i_ctime = CURRENT_TIME_SEC;
fs/ext2/acl.c:			if (!S_ISDIR(inode->i_mode))
fs/ext2/acl.c: * inode->i_mutex: up (access to inode is still exclusive)
fs/ext2/acl.c:	if (!S_ISLNK(inode->i_mode)) {
fs/ext2/acl.c:			inode->i_mode &= ~current_umask();
fs/ext2/acl.c:	if (test_opt(inode->i_sb, POSIX_ACL) && acl) {
fs/ext2/acl.c:		if (S_ISDIR(inode->i_mode)) {
fs/ext2/acl.c:		error = posix_acl_create(&acl, GFP_KERNEL, &inode->i_mode);
fs/ext2/acl.c: * inode->i_mode field must be updated to the desired value by the caller
fs/ext2/acl.c: * inode->i_mutex: down
fs/ext2/acl.c:	if (!test_opt(inode->i_sb, POSIX_ACL))
fs/ext2/acl.c:	if (S_ISLNK(inode->i_mode))
fs/ext2/acl.c:	error = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
fs/ext2/namei.c:	return d_obtain_alias(ext2_iget(child->d_inode->i_sb, ino));
fs/ext2/namei.c:	inode->i_op = &ext2_file_inode_operations;
fs/ext2/namei.c:	if (ext2_use_xip(inode->i_sb)) {
fs/ext2/namei.c:		inode->i_mapping->a_ops = &ext2_aops_xip;
fs/ext2/namei.c:		inode->i_fop = &ext2_xip_file_operations;
fs/ext2/namei.c:	} else if (test_opt(inode->i_sb, NOBH)) {
fs/ext2/namei.c:		inode->i_mapping->a_ops = &ext2_nobh_aops;
fs/ext2/namei.c:		inode->i_fop = &ext2_file_operations;
fs/ext2/namei.c:		inode->i_mapping->a_ops = &ext2_aops;
fs/ext2/namei.c:		inode->i_fop = &ext2_file_operations;
fs/ext2/namei.c:		init_special_inode(inode, inode->i_mode, rdev);
fs/ext2/namei.c:		inode->i_op = &ext2_special_inode_operations;
fs/ext2/namei.c:		inode->i_op = &ext2_symlink_inode_operations;
fs/ext2/namei.c:		if (test_opt(inode->i_sb, NOBH))
fs/ext2/namei.c:			inode->i_mapping->a_ops = &ext2_nobh_aops;
fs/ext2/namei.c:			inode->i_mapping->a_ops = &ext2_aops;
fs/ext2/namei.c:		inode->i_op = &ext2_fast_symlink_inode_operations;
fs/ext2/namei.c:		inode->i_size = l-1;
fs/ext2/namei.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/ext2/namei.c:	inode->i_op = &ext2_dir_inode_operations;
fs/ext2/namei.c:	inode->i_fop = &ext2_dir_operations;
fs/ext2/namei.c:	if (test_opt(inode->i_sb, NOBH))
fs/ext2/namei.c:		inode->i_mapping->a_ops = &ext2_nobh_aops;
fs/ext2/namei.c:		inode->i_mapping->a_ops = &ext2_aops;
fs/ext2/namei.c:	inode->i_ctime = dir->i_ctime;
fs/ext2/namei.c:			inode->i_size = 0;
fs/ext2/namei.c:	if (S_ISDIR(old_inode->i_mode)) {
fs/ext2/namei.c:		new_inode->i_ctime = CURRENT_TIME_SEC;
fs/ext2/namei.c:	old_inode->i_ctime = CURRENT_TIME_SEC;
fs/ext2/ialloc.c:	struct super_block * sb = inode->i_sb;
fs/ext2/ialloc.c:	ino = inode->i_ino;
fs/ext2/ialloc.c:	is_directory = S_ISDIR(inode->i_mode);
fs/ext2/ialloc.c:	bdi = inode->i_mapping->backing_dev_info;
fs/ext2/ialloc.c:	block_group = (inode->i_ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);
fs/ext2/ialloc.c:	gdp = ext2_get_group_desc(inode->i_sb, block_group, NULL);
fs/ext2/ialloc.c:	offset = ((inode->i_ino - 1) % EXT2_INODES_PER_GROUP(inode->i_sb)) *
fs/ext2/ialloc.c:				EXT2_INODE_SIZE(inode->i_sb);
fs/ext2/ialloc.c:				(offset >> EXT2_BLOCK_SIZE_BITS(inode->i_sb));
fs/ext2/ialloc.c:	sb_breadahead(inode->i_sb, block);
fs/ext2/ialloc.c:		inode->i_mode = mode;
fs/ext2/ialloc.c:		inode->i_uid = current_fsuid();
fs/ext2/ialloc.c:		inode->i_gid = dir->i_gid;
fs/ext2/ialloc.c:	inode->i_ino = ino;
fs/ext2/ialloc.c:	inode->i_blocks = 0;
fs/ext2/ialloc.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
fs/ext2/ialloc.c:	inode->i_generation = sbi->s_next_generation++;
fs/ext2/ialloc.c:	ext2_debug("allocating inode %lu\n", inode->i_ino);
fs/ext2/ialloc.c:	inode->i_flags |= S_NOQUOTA;
fs/ext2/xattr.c:			inode->i_sb->s_id, inode->i_ino); \
fs/ext2/xattr.c:	bh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);
fs/ext2/xattr.c:bad_block:	ext2_error(inode->i_sb, "ext2_xattr_get",
fs/ext2/xattr.c:			"inode %ld: bad block %d", inode->i_ino,
fs/ext2/xattr.c:	if (size > inode->i_sb->s_blocksize ||
fs/ext2/xattr.c:	    le16_to_cpu(entry->e_value_offs) + size > inode->i_sb->s_blocksize)
fs/ext2/xattr.c:	bh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);
fs/ext2/xattr.c:bad_block:	ext2_error(inode->i_sb, "ext2_xattr_list",
fs/ext2/xattr.c:			"inode %ld: bad block %d", inode->i_ino,
fs/ext2/xattr.c: * dentry->d_inode->i_mutex: don't care
fs/ext2/xattr.c:	struct super_block *sb = inode->i_sb;
fs/ext2/xattr.c:				"inode %ld: bad block %d", inode->i_ino, 
fs/ext2/xattr.c:	struct super_block *sb = inode->i_sb;
fs/ext2/xattr.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/ext2/xattr.c:	bh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);
fs/ext2/xattr.c:		ext2_error(inode->i_sb, "ext2_xattr_delete_inode",
fs/ext2/xattr.c:			"inode %ld: block %d read error", inode->i_ino,
fs/ext2/xattr.c:		ext2_error(inode->i_sb, "ext2_xattr_delete_inode",
fs/ext2/xattr.c:			"inode %ld: bad block %d", inode->i_ino,
fs/ext2/xattr.c:	ce = mb_cache_entry_find_first(ext2_xattr_cache, inode->i_sb->s_bdev,
fs/ext2/xattr.c:		bh = sb_bread(inode->i_sb, ce->e_block);
fs/ext2/xattr.c:			ext2_error(inode->i_sb, "ext2_xattr_cache_find",
fs/ext2/xattr.c:				inode->i_ino, (unsigned long) ce->e_block);
fs/ext2/xattr.c:		ce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);
fs/notify/inotify/inotify_user.c:		int do_inode = (new_mask & ~inode->i_fsnotify_mask);
fs/notify/inode_mark.c:	assert_spin_locked(&inode->i_lock);
fs/notify/inode_mark.c:	hlist_for_each_entry(mark, pos, &inode->i_fsnotify_marks, i.i_list)
fs/notify/inode_mark.c:	inode->i_fsnotify_mask = new_mask;
fs/notify/inode_mark.c: * Recalculate the inode->i_fsnotify_mask, or the mask of all FS_* event types
fs/notify/inode_mark.c:	spin_lock(&inode->i_lock);
fs/notify/inode_mark.c:	spin_unlock(&inode->i_lock);
fs/notify/inode_mark.c:	spin_lock(&inode->i_lock);
fs/notify/inode_mark.c:	 * this mark is now off the inode->i_fsnotify_marks list and we
fs/notify/inode_mark.c:	 * hold the inode->i_lock, so this is the perfect time to update the
fs/notify/inode_mark.c:	 * inode->i_fsnotify_mask
fs/notify/inode_mark.c:	spin_unlock(&inode->i_lock);
fs/notify/inode_mark.c:	spin_lock(&inode->i_lock);
fs/notify/inode_mark.c:	hlist_for_each_entry_safe(mark, pos, n, &inode->i_fsnotify_marks, i.i_list) {
fs/notify/inode_mark.c:	spin_unlock(&inode->i_lock);
fs/notify/inode_mark.c:	assert_spin_locked(&inode->i_lock);
fs/notify/inode_mark.c:	hlist_for_each_entry(mark, pos, &inode->i_fsnotify_marks, i.i_list) {
fs/notify/inode_mark.c:	spin_lock(&inode->i_lock);
fs/notify/inode_mark.c:	spin_unlock(&inode->i_lock);
fs/notify/inode_mark.c:	spin_lock(&inode->i_lock);
fs/notify/inode_mark.c:	if (hlist_empty(&inode->i_fsnotify_marks)) {
fs/notify/inode_mark.c:		hlist_add_head_rcu(&mark->i.i_list, &inode->i_fsnotify_marks);
fs/notify/inode_mark.c:	hlist_for_each_entry(lmark, node, &inode->i_fsnotify_marks, i.i_list) {
fs/notify/inode_mark.c:	spin_unlock(&inode->i_lock);
fs/notify/inode_mark.c:		spin_lock(&inode->i_lock);
fs/notify/inode_mark.c:		if (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) {
fs/notify/inode_mark.c:			spin_unlock(&inode->i_lock);
fs/notify/inode_mark.c:		if (!atomic_read(&inode->i_count)) {
fs/notify/inode_mark.c:			spin_unlock(&inode->i_lock);
fs/notify/inode_mark.c:		spin_unlock(&inode->i_lock);
fs/notify/fanotify/fanotify.c:	if (!S_ISREG(path->dentry->d_inode->i_mode) &&
fs/notify/fanotify/fanotify.c:	    !S_ISDIR(path->dentry->d_inode->i_mode))
fs/notify/fanotify/fanotify.c:	if (S_ISDIR(path->dentry->d_inode->i_mode) &&
fs/notify/fanotify/fanotify_user.c:		    !(S_ISDIR(f.file->f_path.dentry->d_inode->i_mode))) {
fs/notify/fanotify/fanotify_user.c:	if (removed & inode->i_fsnotify_mask)
fs/notify/fanotify/fanotify_user.c:	    (atomic_read(&inode->i_writecount) > 0))
fs/notify/fanotify/fanotify_user.c:	if (added & ~inode->i_fsnotify_mask)
fs/notify/dnotify/dnotify.c:	if (!S_ISDIR(inode->i_mode))
fs/notify/dnotify/dnotify.c:	if (!S_ISDIR(inode->i_mode))
fs/notify/dnotify/dnotify.c: * dnotify mark in inode->i_fsnotify_marks but we chain a dnotify_struct
fs/notify/dnotify/dnotify.c:	if (!S_ISDIR(inode->i_mode)) {
fs/notify/fdinfo.c:				 inode_mark->wd, inode->i_ino,
fs/notify/fdinfo.c:				 inode->i_sb->s_dev,
fs/notify/fdinfo.c:				 inode->i_ino, inode->i_sb->s_dev,
fs/notify/mark.c: * inode->i_lock
fs/notify/mark.c: * inode->i_lock protects the i_fsnotify_marks list anchored inside a
fs/notify/mark.c:	 * inode->i_lock
fs/notify/fsnotify.c:	if (!S_ISDIR(inode->i_mode))
fs/notify/fsnotify.c:	spin_lock(&inode->i_lock);
fs/notify/fsnotify.c:	hlist_for_each_entry(alias, p, &inode->i_dentry, d_alias) {
fs/notify/fsnotify.c:	spin_unlock(&inode->i_lock);
fs/notify/fsnotify.c:	else if (p_inode->i_fsnotify_mask & mask) {
fs/exofs/inode.c:	struct exofs_sb_info *sbi = inode->i_sb->s_fs_info;
fs/exofs/inode.c:		     pcol->inode->i_ino, _LLU(good_bytes), pcol->length,
fs/exofs/inode.c:			  inode->i_ino, page->index,
fs/exofs/inode.c:		pcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));
fs/exofs/inode.c:		EXOFS_ERR("PageUptodate(0x%lx, 0x%lx)\n", pcol->inode->i_ino,
fs/exofs/inode.c:			     "splitting\n", inode->i_ino, len,
fs/exofs/inode.c:		     inode->i_ino, page->index, len);
fs/exofs/inode.c:		     pcol->inode->i_ino, _LLU(good_bytes), pcol->length,
fs/exofs/inode.c:			     inode->i_ino, page->index, page_stat);
fs/exofs/inode.c:		page =  find_get_page(pcol->inode->i_mapping, index);
fs/exofs/inode.c:			page = find_or_create_page(pcol->inode->i_mapping,
fs/exofs/inode.c:		pcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));
fs/exofs/inode.c:				     inode->i_ino, page->index);
fs/exofs/inode.c:			     inode->i_ino, page->index);
fs/exofs/inode.c:		     inode->i_ino, page->index, len);
fs/exofs/inode.c:		     inode->i_ino, page->index, ret);
fs/exofs/inode.c:/* i_mutex held using inode->i_size directly */
fs/exofs/inode.c:	if (to > inode->i_size)
fs/exofs/inode.c:		truncate_pagecache(inode, to, inode->i_size);
fs/exofs/inode.c:	loff_t i_size = inode->i_size;
fs/exofs/inode.c:	if (i_size != inode->i_size)
fs/exofs/inode.c:	return S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);
fs/exofs/inode.c:	struct exofs_sb_info *sbi = inode->i_sb->s_fs_info;
fs/exofs/inode.c:	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/exofs/inode.c:		     inode->i_ino, newsize, ret);
fs/exofs/inode.c:		inode->i_mode = 0040000 | (0777 & ~022);
fs/exofs/inode.c:	if (!(inode->i_state & I_NEW))
fs/exofs/inode.c:	inode->i_mode = le16_to_cpu(fcb.i_mode);
fs/exofs/inode.c:	inode->i_ctime.tv_sec = (signed)le32_to_cpu(fcb.i_ctime);
fs/exofs/inode.c:	inode->i_atime.tv_sec = (signed)le32_to_cpu(fcb.i_atime);
fs/exofs/inode.c:	inode->i_mtime.tv_sec = (signed)le32_to_cpu(fcb.i_mtime);
fs/exofs/inode.c:	inode->i_ctime.tv_nsec =
fs/exofs/inode.c:		inode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = 0;
fs/exofs/inode.c:	inode->i_blkbits = EXOFS_BLKSHIFT;
fs/exofs/inode.c:	inode->i_generation = le32_to_cpu(fcb.i_generation);
fs/exofs/inode.c:	if ((inode->i_nlink == 0) && (inode->i_mode == 0)) {
fs/exofs/inode.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {
fs/exofs/inode.c:			inode->i_rdev =
fs/exofs/inode.c:			inode->i_rdev =
fs/exofs/inode.c:	inode->i_mapping->backing_dev_info = sb->s_bdi;
fs/exofs/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/exofs/inode.c:		inode->i_op = &exofs_file_inode_operations;
fs/exofs/inode.c:		inode->i_fop = &exofs_file_operations;
fs/exofs/inode.c:		inode->i_mapping->a_ops = &exofs_aops;
fs/exofs/inode.c:	} else if (S_ISDIR(inode->i_mode)) {
fs/exofs/inode.c:		inode->i_op = &exofs_dir_inode_operations;
fs/exofs/inode.c:		inode->i_fop = &exofs_dir_operations;
fs/exofs/inode.c:		inode->i_mapping->a_ops = &exofs_aops;
fs/exofs/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/exofs/inode.c:			inode->i_op = &exofs_fast_symlink_inode_operations;
fs/exofs/inode.c:			inode->i_op = &exofs_symlink_inode_operations;
fs/exofs/inode.c:			inode->i_mapping->a_ops = &exofs_aops;
fs/exofs/inode.c:		inode->i_op = &exofs_special_inode_operations;
fs/exofs/inode.c:			init_special_inode(inode, inode->i_mode,
fs/exofs/inode.c:			init_special_inode(inode, inode->i_mode,
fs/exofs/inode.c:	struct exofs_sb_info *sbi = inode->i_sb->s_fs_info;
fs/exofs/inode.c:	inode->i_mapping->backing_dev_info = sb->s_bdi;
fs/exofs/inode.c:	inode->i_ino = sbi->s_nextid++;
fs/exofs/inode.c:	inode->i_blkbits = EXOFS_BLKSHIFT;
fs/exofs/inode.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
fs/exofs/inode.c:	oi->i_commit_size = inode->i_size = 0;
fs/exofs/inode.c:	inode->i_generation = sbi->s_next_generation++;
fs/exofs/inode.c:	struct super_block *sb = inode->i_sb;
fs/exofs/inode.c:	fcb->i_mode = cpu_to_le16(inode->i_mode);
fs/exofs/inode.c:	fcb->i_links_count = cpu_to_le16(inode->i_nlink);
fs/exofs/inode.c:	fcb->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);
fs/exofs/inode.c:	fcb->i_atime = cpu_to_le32(inode->i_atime.tv_sec);
fs/exofs/inode.c:	fcb->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);
fs/exofs/inode.c:	fcb->i_generation = cpu_to_le32(inode->i_generation);
fs/exofs/inode.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {
fs/exofs/inode.c:		if (old_valid_dev(inode->i_rdev)) {
fs/exofs/inode.c:				cpu_to_le32(old_encode_dev(inode->i_rdev));
fs/exofs/inode.c:				cpu_to_le32(new_encode_dev(inode->i_rdev));
fs/exofs/inode.c:		     inode->i_ino, do_sync, ret);
fs/exofs/inode.c:	struct super_block *sb = inode->i_sb;
fs/exofs/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/exofs/inode.c:	if (inode->i_nlink || is_bad_inode(inode))
fs/exofs/inode.c:	inode->i_size = 0;
fs/exofs/super.c:	call_rcu(&inode->i_rcu, exofs_i_callback);
fs/exofs/super.c:	return d_obtain_alias(exofs_iget(child->d_inode->i_sb, ino));
fs/exofs/super.c:	if (generation && inode->i_generation != generation) {
fs/exofs/exofs.h: * The first device of each inode is the [inode->ino % num_devices]
fs/exofs/common.h: * inode-related things
fs/exofs/dir.c:	return inode->i_sb->s_blocksize;
fs/exofs/dir.c:/* Accesses dir's inode->i_size must be called under inode lock */
fs/exofs/dir.c:	return (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
fs/exofs/dir.c:	loff_t last_byte = inode->i_size;
fs/exofs/dir.c:	umode_t mode = inode->i_mode;
fs/exofs/dir.c:	int need_revalidate = (filp->f_version != inode->i_version);
fs/exofs/dir.c:	if (pos > inode->i_size - EXOFS_DIR_REC_LEN(1))
fs/exofs/dir.c:				  inode->i_ino);
fs/exofs/dir.c:			filp->f_version = inode->i_version;
fs/exofs/dir.c:				     inode->i_ino);
fs/exofs/dir.c:	de->inode_no = cpu_to_le64(inode->i_ino);
fs/exofs/dir.c:	struct exofs_sb_info *sbi = inode->i_sb->s_fs_info;
fs/exofs/dir.c:				      inode->i_ino);
fs/exofs/dir.c:		  dentry, inode->i_ino);
fs/exofs/dir.c:	de->inode_no = cpu_to_le64(inode->i_ino);
fs/exofs/dir.c:	struct exofs_sb_info *sbi = inode->i_sb->s_fs_info;
fs/exofs/dir.c:				  inode->i_ino);
fs/exofs/dir.c:	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
fs/exofs/dir.c:	struct address_space *mapping = inode->i_mapping;
fs/exofs/dir.c:	de->inode_no = cpu_to_le64(inode->i_ino);
fs/exofs/dir.c:					    inode->i_ino)
fs/exofs/file.c:	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/exofs/file.c:	mutex_lock(&inode->i_mutex);
fs/exofs/file.c:	mutex_unlock(&inode->i_mutex);
fs/exofs/namei.c:		inode->i_op = &exofs_file_inode_operations;
fs/exofs/namei.c:		inode->i_fop = &exofs_file_operations;
fs/exofs/namei.c:		inode->i_mapping->a_ops = &exofs_aops;
fs/exofs/namei.c:		init_special_inode(inode, inode->i_mode, rdev);
fs/exofs/namei.c:		inode->i_op = &exofs_symlink_inode_operations;
fs/exofs/namei.c:		inode->i_mapping->a_ops = &exofs_aops;
fs/exofs/namei.c:		inode->i_op = &exofs_fast_symlink_inode_operations;
fs/exofs/namei.c:		inode->i_size = l-1;
fs/exofs/namei.c:	inode->i_ctime = CURRENT_TIME;
fs/exofs/namei.c:	inode->i_op = &exofs_dir_inode_operations;
fs/exofs/namei.c:	inode->i_fop = &exofs_dir_operations;
fs/exofs/namei.c:	inode->i_mapping->a_ops = &exofs_aops;
fs/exofs/namei.c:	inode->i_ctime = dir->i_ctime;
fs/exofs/namei.c:			inode->i_size = 0;
fs/exofs/namei.c:	if (S_ISDIR(old_inode->i_mode)) {
fs/exofs/namei.c:		new_inode->i_ctime = CURRENT_TIME;
fs/exofs/namei.c:	old_inode->i_ctime = CURRENT_TIME;
fs/anon_inodes.c:	inode->i_ino = get_next_ino();
fs/anon_inodes.c:	inode->i_fop = &anon_inode_fops;
fs/anon_inodes.c:	inode->i_mapping->a_ops = &anon_aops;
fs/anon_inodes.c:	inode->i_state = I_DIRTY;
fs/anon_inodes.c:	inode->i_mode = S_IRUSR | S_IWUSR;
fs/anon_inodes.c:	inode->i_uid = current_fsuid();
fs/anon_inodes.c:	inode->i_gid = current_fsgid();
fs/anon_inodes.c:	inode->i_flags |= S_PRIVATE;
fs/anon_inodes.c:	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/anon_inodes.c:	file->f_mapping = anon_inode_inode->i_mapping;
fs/hpfs/inode.c:	hpfs_inode->i_dno = 0;
fs/hpfs/inode.c:	hpfs_inode->i_n_secs = 0;
fs/hpfs/inode.c:	hpfs_inode->i_file_sec = 0;
fs/hpfs/inode.c:	hpfs_inode->i_disk_sec = 0;
fs/hpfs/inode.c:	hpfs_inode->i_dpos = 0;
fs/hpfs/inode.c:	hpfs_inode->i_dsubdno = 0;
fs/hpfs/inode.c:	hpfs_inode->i_ea_mode = 0;
fs/hpfs/inode.c:	hpfs_inode->i_ea_uid = 0;
fs/hpfs/inode.c:	hpfs_inode->i_ea_gid = 0;
fs/hpfs/inode.c:	hpfs_inode->i_ea_size = 0;
fs/hpfs/inode.c:	hpfs_inode->i_rddir_off = NULL;
fs/hpfs/inode.c:	hpfs_inode->i_dirty = 0;
fs/hpfs/inode.c:				hpfs_inode->i_ea_uid = 1;
fs/hpfs/inode.c:				hpfs_inode->i_ea_gid = 1;
fs/hpfs/inode.c:				hpfs_inode->i_ea_mode = 1;
fs/hpfs/inode.c:		hpfs_inode->i_parent_dir = le32_to_cpu(fnode->up);
fs/hpfs/inode.c:		hpfs_inode->i_dno = le32_to_cpu(fnode->u.external[0].disk_secno);
fs/hpfs/inode.c:			if (hpfs_map_fnode(sb, hpfs_inode->i_parent_dir, &bh0)) brelse(bh0);
fs/hpfs/inode.c:		hpfs_count_dnodes(i->i_sb, hpfs_inode->i_dno, &n_dnodes, &n_subdirs, NULL);
fs/hpfs/inode.c:		if (!hpfs_inode->i_ea_mode) i->i_mode &= ~0111;
fs/hpfs/inode.c:		if (!uid_eq(i->i_uid, hpfs_sb(i->i_sb)->sb_uid) || hpfs_inode->i_ea_uid) {
fs/hpfs/inode.c:			hpfs_inode->i_ea_uid = 1;
fs/hpfs/inode.c:		if (!gid_eq(i->i_gid, hpfs_sb(i->i_sb)->sb_gid) || hpfs_inode->i_ea_gid) {
fs/hpfs/inode.c:			hpfs_inode->i_ea_gid = 1;
fs/hpfs/inode.c:			  | (S_ISDIR(i->i_mode) ? S_IFDIR : S_IFREG))) || hpfs_inode->i_ea_mode) {
fs/hpfs/inode.c:				hpfs_inode->i_ea_mode = 1;
fs/hpfs/inode.c:	if (hpfs_inode->i_rddir_off && !atomic_read(&i->i_count)) {
fs/hpfs/inode.c:		if (*hpfs_inode->i_rddir_off) printk("HPFS: write_inode: some position still there\n");
fs/hpfs/inode.c:		kfree(hpfs_inode->i_rddir_off);
fs/hpfs/inode.c:		hpfs_inode->i_rddir_off = NULL;
fs/hpfs/inode.c:	parent = iget_locked(i->i_sb, hpfs_inode->i_parent_dir);
fs/hpfs/inode.c:		hpfs_inode->i_dirty = 0;
fs/hpfs/inode.c:		de->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);
fs/hpfs/inode.c:		if ((de = map_dirent(i, hpfs_inode->i_dno, "\001\001", 2, NULL, &qbh))) {
fs/hpfs/inode.c:			de->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);
fs/hpfs/inode.c:	hpfs_lock(inode->i_sb);
fs/hpfs/inode.c:	if (inode->i_ino == hpfs_sb(inode->i_sb)->sb_root)
fs/hpfs/inode.c:	if ((attr->ia_valid & ATTR_SIZE) && attr->ia_size > inode->i_size)
fs/hpfs/inode.c:	hpfs_unlock(inode->i_sb);
fs/hpfs/inode.c:	if (hpfs_inode->i_dirty)
fs/hpfs/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/hpfs/inode.c:	if (!inode->i_nlink) {
fs/hpfs/inode.c:		hpfs_lock(inode->i_sb);
fs/hpfs/inode.c:		hpfs_remove_fnode(inode->i_sb, inode->i_ino);
fs/hpfs/inode.c:		hpfs_unlock(inode->i_sb);
fs/hpfs/ea.c:	fnode_secno fno = inode->i_ino;
fs/hpfs/ea.c:	struct super_block *s = inode->i_sb;
fs/hpfs/ea.c:				inode->i_ino, le16_to_cpu(fnode->ea_size_s));
fs/hpfs/ea.c:			(unsigned long)inode->i_ino,
fs/hpfs/super.c:	call_rcu(&inode->i_rcu, hpfs_i_callback);
fs/hpfs/dir.c:	hpfs_lock(inode->i_sb);
fs/hpfs/dir.c:	hpfs_unlock(inode->i_sb);
fs/hpfs/dir.c:	pos = ((loff_t) hpfs_de_as_down_as_possible(s, hpfs_inode->i_dno) << 4) + 1;
fs/hpfs/dir.c:	hpfs_lock(inode->i_sb);
fs/hpfs/dir.c:	if (hpfs_sb(inode->i_sb)->sb_chk) {
fs/hpfs/dir.c:		if (hpfs_chk_sectors(inode->i_sb, inode->i_ino, 1, "dir_fnode")) {
fs/hpfs/dir.c:		if (hpfs_chk_sectors(inode->i_sb, hpfs_inode->i_dno, 4, "dir_dnode")) {
fs/hpfs/dir.c:	if (hpfs_sb(inode->i_sb)->sb_chk >= 2) {
fs/hpfs/dir.c:		if (!(fno = hpfs_map_fnode(inode->i_sb, inode->i_ino, &bh))) {
fs/hpfs/dir.c:			hpfs_error(inode->i_sb, "not a directory, fnode %08lx",
fs/hpfs/dir.c:					(unsigned long)inode->i_ino);
fs/hpfs/dir.c:		if (hpfs_inode->i_dno != le32_to_cpu(fno->u.external[0].disk_secno)) {
fs/hpfs/dir.c:			hpfs_error(inode->i_sb, "corrupted inode: i_dno == %08x, fnode -> dnode == %08x", hpfs_inode->i_dno, le32_to_cpu(fno->u.external[0].disk_secno));
fs/hpfs/dir.c:	lc = hpfs_sb(inode->i_sb)->sb_lowercase;
fs/hpfs/dir.c:		if (hpfs_sb(inode->i_sb)->sb_chk)
fs/hpfs/dir.c:			if (hpfs_stop_cycles(inode->i_sb, filp->f_pos, &c1, &c2, "hpfs_readdir")) {
fs/hpfs/dir.c:			if (filldir(dirent, ".", 1, filp->f_pos, inode->i_ino, DT_DIR) < 0)
fs/hpfs/dir.c:			if (filldir(dirent, "..", 2, filp->f_pos, hpfs_inode->i_parent_dir, DT_DIR) < 0)
fs/hpfs/dir.c:			filp->f_pos = ((loff_t) hpfs_de_as_down_as_possible(inode->i_sb, hpfs_inode->i_dno) << 4) + 1;
fs/hpfs/dir.c:			filp->f_version = inode->i_version;
fs/hpfs/dir.c:			if (hpfs_sb(inode->i_sb)->sb_chk) {
fs/hpfs/dir.c:					hpfs_error(inode->i_sb, "hpfs_readdir: bad ^A^A entry; pos = %08lx", old_pos);
fs/hpfs/dir.c:					hpfs_error(inode->i_sb, "hpfs_readdir: bad \\377 entry; pos = %08lx", old_pos);
fs/hpfs/dir.c:		tempname = hpfs_translate_name(inode->i_sb, de->name, de->namelen, lc, de->not_8x3);
fs/hpfs/dir.c:	hpfs_unlock(inode->i_sb);
fs/hpfs/file.c:	hpfs_lock(inode->i_sb);
fs/hpfs/file.c:	hpfs_unlock(inode->i_sb);
fs/hpfs/file.c:	return sync_blockdev(inode->i_sb->s_bdev);
fs/hpfs/file.c:	n = file_secno - hpfs_inode->i_file_sec;
fs/hpfs/file.c:	if (n < hpfs_inode->i_n_secs) return hpfs_inode->i_disk_sec + n;
fs/hpfs/file.c:	if (!(fnode = hpfs_map_fnode(inode->i_sb, inode->i_ino, &bh))) return 0;
fs/hpfs/file.c:	disk_secno = hpfs_bplus_lookup(inode->i_sb, inode, &fnode->btree, file_secno, bh);
fs/hpfs/file.c:	if (hpfs_chk_sectors(inode->i_sb, disk_secno, 1, "bmap")) return 0;
fs/hpfs/file.c:	hpfs_lock(inode->i_sb);
fs/hpfs/file.c:		map_bh(bh_result, inode->i_sb, s);
fs/hpfs/file.c:	if ((s = hpfs_add_sector_to_btree(inode->i_sb, inode->i_ino, 1, inode->i_blocks - 1)) == -1) {
fs/hpfs/file.c:		hpfs_truncate_btree(inode->i_sb, inode->i_ino, 1, inode->i_blocks - 1);
fs/hpfs/file.c:	inode->i_blocks++;
fs/hpfs/file.c:	map_bh(bh_result, inode->i_sb, s);
fs/hpfs/file.c:	hpfs_unlock(inode->i_sb);
fs/hpfs/file.c:	if (to > inode->i_size) {
fs/hpfs/file.c:		truncate_pagecache(inode, to, inode->i_size);
fs/hpfs/anode.c:				hpfs_inode->i_file_sec = le32_to_cpu(btree->u.external[i].file_secno);
fs/hpfs/anode.c:				hpfs_inode->i_disk_sec = le32_to_cpu(btree->u.external[i].disk_secno);
fs/hpfs/anode.c:				hpfs_inode->i_n_secs = le32_to_cpu(btree->u.external[i].length);
fs/hpfs/namei.c:		    !S_ISREG(inode->i_mode) ||
fs/hpfs/namei.c:	if (new_inode && S_ISDIR(new_inode->i_mode)) {
fs/hpfs/dnode.c:	if (hpfs_inode->i_rddir_off)
fs/hpfs/dnode.c:		for (; hpfs_inode->i_rddir_off[i]; i++)
fs/hpfs/dnode.c:			if (hpfs_inode->i_rddir_off[i] == pos) return;
fs/hpfs/dnode.c:		if (hpfs_inode->i_rddir_off) {
fs/hpfs/dnode.c:			memcpy(ppos, hpfs_inode->i_rddir_off, i * sizeof(loff_t));
fs/hpfs/dnode.c:			kfree(hpfs_inode->i_rddir_off);
fs/hpfs/dnode.c:		hpfs_inode->i_rddir_off = ppos;
fs/hpfs/dnode.c:	hpfs_inode->i_rddir_off[i] = pos;
fs/hpfs/dnode.c:	hpfs_inode->i_rddir_off[i + 1] = NULL;
fs/hpfs/dnode.c:	if (!hpfs_inode->i_rddir_off) goto not_f;
fs/hpfs/dnode.c:	for (i = hpfs_inode->i_rddir_off; *i; i++) if (*i == pos) goto fnd;
fs/hpfs/dnode.c:	if (j - 1 == hpfs_inode->i_rddir_off) {
fs/hpfs/dnode.c:		kfree(hpfs_inode->i_rddir_off);
fs/hpfs/dnode.c:		hpfs_inode->i_rddir_off = NULL;
fs/hpfs/dnode.c:	if (!hpfs_inode->i_rddir_off) return;
fs/hpfs/dnode.c:	for (i = hpfs_inode->i_rddir_off; *i; i++) (*f)(*i, p1, p2);
fs/hpfs/dnode.c:	dno = hpfs_inode->i_dno;
fs/hpfs/dnode.c:			hpfs_inode->i_dno = down;
fs/hpfs/dnode.c:	if (!(de = map_nth_dirent(inode->i_sb, dno, pos, qbh, &dnode)))
fs/hpfs/dnode.c:			hpfs_error(inode->i_sb,
fs/hpfs/dnode.c:			*posp = ((loff_t) hpfs_de_as_down_as_possible(inode->i_sb, de_down_pointer(d)) << 4) + 1;
fs/hpfs/dnode.c:	if (!(up_dnode = hpfs_map_dnode(inode->i_sb, le32_to_cpu(dnode->up), &qbh0)))
fs/hpfs/dnode.c:		if (!(++c & 077)) hpfs_error(inode->i_sb,
fs/hpfs/dnode.c:	hpfs_error(inode->i_sb, "map_pos_dirent: pointer to dnode %08x not found in parent dnode %08x",
fs/hpfs/dnode.c:	if (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, "map_dirent: not a directory\n");
fs/hpfs/dnode.c:	if (hpfs_sb(inode->i_sb)->sb_chk)
fs/hpfs/dnode.c:		if (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, "map_dirent")) return NULL;
fs/hpfs/dnode.c:	if (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;
fs/hpfs/dnode.c:		int t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);
fs/nfs/getroot.c:		spin_lock(&sb->s_root->d_inode->i_lock);
fs/nfs/getroot.c:		spin_unlock(&sb->s_root->d_inode->i_lock);
fs/nfs/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/nfs/inode.c:	int mode = inode->i_mode;
fs/nfs/inode.c:	spin_lock(&inode->i_lock);
fs/nfs/inode.c:	spin_unlock(&inode->i_lock);
fs/nfs/inode.c:		spin_lock(&inode->i_lock);
fs/nfs/inode.c:		spin_unlock(&inode->i_lock);
fs/nfs/inode.c:	spin_lock(&inode->i_lock);
fs/nfs/inode.c:	spin_unlock(&inode->i_lock);
fs/nfs/inode.c:	spin_lock(&inode->i_lock);
fs/nfs/inode.c:	spin_unlock(&inode->i_lock);
fs/nfs/inode.c: * NB: must be called with inode->i_lock held!
fs/nfs/inode.c:	if (inode->i_state & I_NEW) {
fs/nfs/inode.c:		inode->i_ino = hash;
fs/nfs/inode.c:		inode->i_flags |= S_NOATIME|S_NOCMTIME;
fs/nfs/inode.c:		inode->i_mode = fattr->mode;
fs/nfs/inode.c:		inode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->file_inode_ops;
fs/nfs/inode.c:		if (S_ISREG(inode->i_mode)) {
fs/nfs/inode.c:			inode->i_fop = NFS_SB(sb)->nfs_client->rpc_ops->file_ops;
fs/nfs/inode.c:			inode->i_data.a_ops = &nfs_file_aops;
fs/nfs/inode.c:			inode->i_data.backing_dev_info = &NFS_SB(sb)->backing_dev_info;
fs/nfs/inode.c:		} else if (S_ISDIR(inode->i_mode)) {
fs/nfs/inode.c:			inode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->dir_inode_ops;
fs/nfs/inode.c:			inode->i_fop = &nfs_dir_operations;
fs/nfs/inode.c:			inode->i_data.a_ops = &nfs_dir_aops;
fs/nfs/inode.c:					inode->i_op = &nfs_referral_inode_operations;
fs/nfs/inode.c:					inode->i_op = &nfs_mountpoint_inode_operations;
fs/nfs/inode.c:				inode->i_fop = NULL;
fs/nfs/inode.c:				inode->i_flags |= S_AUTOMOUNT;
fs/nfs/inode.c:		} else if (S_ISLNK(inode->i_mode))
fs/nfs/inode.c:			inode->i_op = &nfs_symlink_inode_operations;
fs/nfs/inode.c:			init_special_inode(inode, inode->i_mode, fattr->rdev);
fs/nfs/inode.c:		memset(&inode->i_atime, 0, sizeof(inode->i_atime));
fs/nfs/inode.c:		memset(&inode->i_mtime, 0, sizeof(inode->i_mtime));
fs/nfs/inode.c:		memset(&inode->i_ctime, 0, sizeof(inode->i_ctime));
fs/nfs/inode.c:		inode->i_version = 0;
fs/nfs/inode.c:		inode->i_size = 0;
fs/nfs/inode.c:		inode->i_uid = -2;
fs/nfs/inode.c:		inode->i_gid = -2;
fs/nfs/inode.c:		inode->i_blocks = 0;
fs/nfs/inode.c:			inode->i_atime = fattr->atime;
fs/nfs/inode.c:			inode->i_mtime = fattr->mtime;
fs/nfs/inode.c:			inode->i_ctime = fattr->ctime;
fs/nfs/inode.c:			inode->i_version = fattr->change_attr;
fs/nfs/inode.c:			inode->i_size = nfs_size_to_loff_t(fattr->size);
fs/nfs/inode.c:			inode->i_uid = fattr->uid;
fs/nfs/inode.c:			inode->i_gid = fattr->gid;
fs/nfs/inode.c:			inode->i_blocks = fattr->du.nfs2.blocks;
fs/nfs/inode.c:			inode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);
fs/nfs/inode.c:		inode->i_sb->s_id,
fs/nfs/inode.c:		atomic_read(&inode->i_count));
fs/nfs/inode.c:		if (!S_ISREG(inode->i_mode) || attr->ia_size == i_size_read(inode))
fs/nfs/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/nfs/inode.c: * inode->i_size to be updated under the inode->i_lock.
fs/nfs/inode.c:	spin_lock(&inode->i_lock);
fs/nfs/inode.c:	oldsize = inode->i_size;
fs/nfs/inode.c:	spin_unlock(&inode->i_lock);
fs/nfs/inode.c:		spin_lock(&inode->i_lock);
fs/nfs/inode.c:			mode |= inode->i_mode & ~S_IALLUGO;
fs/nfs/inode.c:			inode->i_mode = mode;
fs/nfs/inode.c:			inode->i_uid = attr->ia_uid;
fs/nfs/inode.c:			inode->i_gid = attr->ia_gid;
fs/nfs/inode.c:		spin_unlock(&inode->i_lock);
fs/nfs/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/nfs/inode.c:		err = filemap_write_and_wait(inode->i_mapping);
fs/nfs/inode.c: 	    ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode)))
fs/nfs/inode.c:	spin_lock(&inode->i_lock);
fs/nfs/inode.c:		spin_unlock(&inode->i_lock);
fs/nfs/inode.c:		spin_lock(&inode->i_lock);
fs/nfs/inode.c:	spin_unlock(&inode->i_lock);
fs/nfs/inode.c:	if (!atomic_dec_and_lock(&l_ctx->count, &inode->i_lock))
fs/nfs/inode.c:	spin_unlock(&inode->i_lock);
fs/nfs/inode.c:		if (!atomic_dec_and_lock(&ctx->lock_context.count, &inode->i_lock))
fs/nfs/inode.c:		spin_unlock(&inode->i_lock);
fs/nfs/inode.c:	spin_lock(&inode->i_lock);
fs/nfs/inode.c:	spin_unlock(&inode->i_lock);
fs/nfs/inode.c:	spin_lock(&inode->i_lock);
fs/nfs/inode.c:	spin_unlock(&inode->i_lock);
fs/nfs/inode.c:		spin_lock(&inode->i_lock);
fs/nfs/inode.c:		spin_unlock(&inode->i_lock);
fs/nfs/inode.c:		inode->i_sb->s_id, (long long)NFS_FILEID(inode));
fs/nfs/inode.c:			 inode->i_sb->s_id,
fs/nfs/inode.c:			if (!S_ISDIR(inode->i_mode))
fs/nfs/inode.c:			 inode->i_sb->s_id,
fs/nfs/inode.c:		inode->i_sb->s_id,
fs/nfs/inode.c:	spin_lock(&inode->i_lock);
fs/nfs/inode.c:	if (S_ISDIR(inode->i_mode))
fs/nfs/inode.c:	spin_unlock(&inode->i_lock);
fs/nfs/inode.c:			inode->i_sb->s_id, (long long)NFS_FILEID(inode));
fs/nfs/inode.c:			&& inode->i_version == fattr->pre_change_attr) {
fs/nfs/inode.c:		inode->i_version = fattr->change_attr;
fs/nfs/inode.c:		if (S_ISDIR(inode->i_mode))
fs/nfs/inode.c:			&& timespec_equal(&inode->i_ctime, &fattr->pre_ctime)) {
fs/nfs/inode.c:		memcpy(&inode->i_ctime, &fattr->ctime, sizeof(inode->i_ctime));
fs/nfs/inode.c:			&& timespec_equal(&inode->i_mtime, &fattr->pre_mtime)) {
fs/nfs/inode.c:		memcpy(&inode->i_mtime, &fattr->mtime, sizeof(inode->i_mtime));
fs/nfs/inode.c:		if (S_ISDIR(inode->i_mode))
fs/nfs/inode.c:	if ((fattr->valid & NFS_ATTR_FATTR_TYPE) && (inode->i_mode & S_IFMT) != (fattr->mode & S_IFMT))
fs/nfs/inode.c:			inode->i_version != fattr->change_attr)
fs/nfs/inode.c:	if ((fattr->valid & NFS_ATTR_FATTR_MTIME) && !timespec_equal(&inode->i_mtime, &fattr->mtime))
fs/nfs/inode.c:	if ((fattr->valid & NFS_ATTR_FATTR_MODE) && (inode->i_mode & S_IALLUGO) != (fattr->mode & S_IALLUGO))
fs/nfs/inode.c:	if ((fattr->valid & NFS_ATTR_FATTR_OWNER) && inode->i_uid != fattr->uid)
fs/nfs/inode.c:	if ((fattr->valid & NFS_ATTR_FATTR_GROUP) && inode->i_gid != fattr->gid)
fs/nfs/inode.c:	if ((fattr->valid & NFS_ATTR_FATTR_NLINK) && inode->i_nlink != fattr->nlink)
fs/nfs/inode.c:	if ((fattr->valid & NFS_ATTR_FATTR_ATIME) && !timespec_equal(&inode->i_atime, &fattr->atime))
fs/nfs/inode.c:	return timespec_compare(&fattr->ctime, &inode->i_ctime) > 0;
fs/nfs/inode.c:	spin_lock(&inode->i_lock);
fs/nfs/inode.c:	spin_unlock(&inode->i_lock);
fs/nfs/inode.c:	if (S_ISDIR(inode->i_mode)) {
fs/nfs/inode.c:	spin_lock(&inode->i_lock);
fs/nfs/inode.c:	spin_unlock(&inode->i_lock);
fs/nfs/inode.c:	spin_lock(&inode->i_lock);
fs/nfs/inode.c:		fattr->pre_change_attr = inode->i_version;
fs/nfs/inode.c:		memcpy(&fattr->pre_ctime, &inode->i_ctime, sizeof(fattr->pre_ctime));
fs/nfs/inode.c:		memcpy(&fattr->pre_mtime, &inode->i_mtime, sizeof(fattr->pre_mtime));
fs/nfs/inode.c:	spin_unlock(&inode->i_lock);
fs/nfs/inode.c:			__func__, inode->i_sb->s_id, inode->i_ino,
fs/nfs/inode.c:			atomic_read(&inode->i_count), fattr->valid);
fs/nfs/inode.c:			inode->i_sb->s_id, (long long)nfsi->fileid,
fs/nfs/inode.c:	if ((fattr->valid & NFS_ATTR_FATTR_TYPE) && (inode->i_mode & S_IFMT) != (fattr->mode & S_IFMT)) {
fs/nfs/inode.c:				__func__, inode->i_ino, inode->i_mode, fattr->mode);
fs/nfs/inode.c:	if (S_ISDIR(inode->i_mode) && (fattr->valid & NFS_ATTR_FATTR_FSID) &&
fs/nfs/inode.c:		if (inode->i_version != fattr->change_attr) {
fs/nfs/inode.c:					inode->i_sb->s_id, inode->i_ino);
fs/nfs/inode.c:			if (S_ISDIR(inode->i_mode))
fs/nfs/inode.c:			inode->i_version = fattr->change_attr;
fs/nfs/inode.c:		memcpy(&inode->i_mtime, &fattr->mtime, sizeof(inode->i_mtime));
fs/nfs/inode.c:		memcpy(&inode->i_ctime, &fattr->ctime, sizeof(inode->i_ctime));
fs/nfs/inode.c:					inode->i_sb->s_id,
fs/nfs/inode.c:					inode->i_ino,
fs/nfs/inode.c:		memcpy(&inode->i_atime, &fattr->atime, sizeof(inode->i_atime));
fs/nfs/inode.c:		if ((inode->i_mode & S_IALLUGO) != (fattr->mode & S_IALLUGO)) {
fs/nfs/inode.c:			umode_t newmode = inode->i_mode & S_IFMT;
fs/nfs/inode.c:			inode->i_mode = newmode;
fs/nfs/inode.c:		if (inode->i_uid != fattr->uid) {
fs/nfs/inode.c:			inode->i_uid = fattr->uid;
fs/nfs/inode.c:		if (inode->i_gid != fattr->gid) {
fs/nfs/inode.c:			inode->i_gid = fattr->gid;
fs/nfs/inode.c:		if (inode->i_nlink != fattr->nlink) {
fs/nfs/inode.c:			if (S_ISDIR(inode->i_mode))
fs/nfs/inode.c:		inode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);
fs/nfs/inode.c:		inode->i_blocks = fattr->du.nfs2.blocks;
fs/nfs/inode.c:	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)
fs/nfs/inode.c:				|| S_ISLNK(inode->i_mode)))
fs/nfs/inode.c:	call_rcu(&inode->i_rcu, nfs_i_callback);
fs/nfs/nfs3acl.c:	if (S_ISDIR(inode->i_mode)) {
fs/nfs/nfs3acl.c:	dprintk("NFS: nfs3_forget_cached_acls(%s/%ld)\n", inode->i_sb->s_id,
fs/nfs/nfs3acl.c:		inode->i_ino);
fs/nfs/nfs3acl.c:	spin_lock(&inode->i_lock);
fs/nfs/nfs3acl.c:	spin_unlock(&inode->i_lock);
fs/nfs/nfs3acl.c:	spin_lock(&inode->i_lock);
fs/nfs/nfs3acl.c:	spin_unlock(&inode->i_lock);
fs/nfs/nfs3acl.c:	dprintk("NFS: nfs3_get_cached_acl(%s/%ld, %d) = %p\n", inode->i_sb->s_id,
fs/nfs/nfs3acl.c:		inode->i_ino, type, acl);
fs/nfs/nfs3acl.c:	dprintk("nfs3_cache_acls(%s/%ld, %p, %p)\n", inode->i_sb->s_id,
fs/nfs/nfs3acl.c:		inode->i_ino, acl, dfacl);
fs/nfs/nfs3acl.c:	spin_lock(&inode->i_lock);
fs/nfs/nfs3acl.c:	spin_unlock(&inode->i_lock);
fs/nfs/nfs3acl.c:	if (S_ISDIR(inode->i_mode))
fs/nfs/nfs3acl.c:	if (S_ISDIR(inode->i_mode)) {
fs/nfs/nfs3acl.c:	if (S_ISDIR(inode->i_mode)) {
fs/nfs/nfs3acl.c:		alloc = acl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);
fs/nfs/nfs3acl.c:	error = nfs3_proc_setacls(inode, acl, S_ISDIR(inode->i_mode) ?
fs/nfs/super.c:	if (mntroot->d_inode->i_op != NFS_SB(s)->nfs_client->rpc_ops->dir_inode_ops)
fs/nfs/nfs4state.c:	spin_lock(&inode->i_lock);
fs/nfs/nfs4state.c:	spin_unlock(&inode->i_lock);
fs/nfs/nfs4state.c:	spin_lock(&inode->i_lock);
fs/nfs/nfs4state.c:		spin_unlock(&inode->i_lock);
fs/nfs/nfs4state.c:		spin_unlock(&inode->i_lock);
fs/nfs/nfs4state.c:	spin_lock(&inode->i_lock);
fs/nfs/nfs4state.c:	spin_unlock(&inode->i_lock);
fs/nfs/nfs4state.c:	spin_lock(&inode->i_lock);
fs/nfs/nfs4state.c:	spin_unlock(&inode->i_lock);
fs/nfs/nfs4state.c:	if (inode->i_flock == NULL)
fs/nfs/nfs4state.c:	/* Protect inode->i_flock using the BKL */
fs/nfs/nfs4state.c:	for (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {
fs/nfs/delegation.c:	if (inode->i_flock == NULL)
fs/nfs/delegation.c:	/* Protect inode->i_flock using the file locks lock */
fs/nfs/delegation.c:	for (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {
fs/nfs/delegation.c:	spin_lock(&inode->i_lock);
fs/nfs/delegation.c:		spin_unlock(&inode->i_lock);
fs/nfs/delegation.c:	spin_unlock(&inode->i_lock);
fs/nfs/delegation.c:	delegation->change_attr = inode->i_version;
fs/nfs/delegation.c:	spin_lock(&inode->i_lock);
fs/nfs/delegation.c:	spin_unlock(&inode->i_lock);
fs/nfs/delegation.c:	filemap_flush(inode->i_mapping);
fs/nfs/nfs4super.c:	truncate_inode_pages(&inode->i_data, 0);
fs/nfs/nfs4file.c:		ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/nfs/nfs4file.c:		mutex_lock(&inode->i_mutex);
fs/nfs/nfs4file.c:		mutex_unlock(&inode->i_mutex);
fs/nfs/fscache.c:	if (S_ISREG(inode->i_mode))
fs/nfs/fscache.c:	struct super_block *sb = inode->i_sb;
fs/nfs/direct.c:		req->wb_context->dentry->d_inode->i_sb->s_id,
fs/nfs/direct.c:	nfs_zap_mapping(inode, inode->i_mapping);
fs/nfs/direct.c:	atomic_inc(&inode->i_dio_count);
fs/nfs/direct.c:		spin_lock(&inode->i_lock);
fs/nfs/direct.c:		spin_unlock(&inode->i_lock);
fs/nfs/nfs4proc.c:	spin_lock(&state->inode->i_lock);
fs/nfs/nfs4proc.c:		spin_unlock(&state->inode->i_lock);
fs/nfs/nfs4proc.c:	spin_unlock(&state->inode->i_lock);
fs/nfs/nfs4proc.c:	struct super_block *sb = calldata->state->inode->i_sb;
fs/nfs/nfs4proc.c:	nfs_sb_active(calldata->inode->i_sb);
fs/nfs/nfs4proc.c:	if (S_ISDIR(inode->i_mode)) {
fs/nfs/nfs4proc.c:	spin_lock(&inode->i_lock);
fs/nfs/nfs4proc.c:	spin_unlock(&inode->i_lock);
fs/nfs/nfs4proc.c:	spin_lock(&inode->i_lock);
fs/nfs/nfs4proc.c:	spin_unlock(&inode->i_lock);
fs/nfs/nfs4proc.c:	spin_lock(&inode->i_lock);
fs/nfs/nfs4proc.c:	spin_unlock(&inode->i_lock);
fs/nfs/nfs4proc.c:		spin_lock(&inode->i_lock);
fs/nfs/nfs4proc.c:			spin_unlock(&inode->i_lock);
fs/nfs/nfs4proc.c:			spin_unlock(&inode->i_lock);
fs/nfs/nfs4proc.c:	spin_lock(&lo->plh_inode->i_lock);
fs/nfs/nfs4proc.c:	spin_unlock(&lo->plh_inode->i_lock);
fs/nfs/nfs4proc.c:		data->args.inode->i_ino);
fs/nfs/nfs4xdr.c:	spin_lock(&args->inode->i_lock);
fs/nfs/nfs4xdr.c:	spin_unlock(&args->inode->i_lock);
fs/nfs/blocklayout/blocklayout.c:	if ((isect << SECTOR_SHIFT) >= header->inode->i_size) {
fs/nfs/blocklayout/blocklayout.c:		rdata->res.count = header->inode->i_size - rdata->args.offset;
fs/nfs/blocklayout/blocklayout.c:	    (be->be_mdev->bd_inode->i_blkbits - SECTOR_SHIFT);
fs/nfs/blocklayout/blocklayout.c:	page = find_get_page(inode->i_mapping, index);
fs/nfs/blocklayout/blocklayout.c:	page = find_or_create_page(inode->i_mapping, index, GFP_NOFS);
fs/nfs/blocklayout/blocklayout.c:	struct address_space *mapping = inode->i_mapping;
fs/nfs/dir.c:	if (invalidate_inode_pages2_range(inode->i_mapping, page->index + 1, -1) < 0) {
fs/nfs/dir.c:		nfs_zap_mapping(inode, inode->i_mapping);
fs/nfs/dir.c:	return read_cache_page(desc->file->f_path.dentry->d_inode->i_mapping,
fs/nfs/dir.c:	mutex_lock(&inode->i_mutex);
fs/nfs/dir.c:	mutex_unlock(&inode->i_mutex);
fs/nfs/dir.c:	mutex_lock(&inode->i_mutex);
fs/nfs/dir.c:	mutex_unlock(&inode->i_mutex);
fs/nfs/dir.c:	    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))
fs/nfs/dir.c:	return (inode->i_nlink == 0) ? -ENOENT : 0;
fs/nfs/dir.c:	if (inode && S_ISDIR(inode->i_mode)) {
fs/nfs/dir.c:/* Ensure that we revalidate inode->i_nlink */
fs/nfs/dir.c:	spin_lock(&inode->i_lock);
fs/nfs/dir.c:	if (inode->i_nlink == 1)
fs/nfs/dir.c:	spin_unlock(&inode->i_lock);
fs/nfs/dir.c:	if (S_ISDIR(inode->i_mode))
fs/nfs/dir.c:	if (!S_ISREG(inode->i_mode))
fs/nfs/dir.c:	if (!add_to_page_cache(page, dentry->d_inode->i_mapping, 0,
fs/nfs/dir.c:	if (new_inode && !S_ISDIR(new_inode->i_mode)) {
fs/nfs/dir.c:		spin_lock(&inode->i_lock);
fs/nfs/dir.c:		spin_unlock(&inode->i_lock);
fs/nfs/dir.c:	spin_lock(&inode->i_lock);
fs/nfs/dir.c:	spin_unlock(&inode->i_lock);
fs/nfs/dir.c:	spin_lock(&inode->i_lock);
fs/nfs/dir.c:	spin_unlock(&inode->i_lock);
fs/nfs/dir.c:	spin_unlock(&inode->i_lock);
fs/nfs/dir.c:	spin_unlock(&inode->i_lock);
fs/nfs/dir.c:	spin_lock(&inode->i_lock);
fs/nfs/dir.c:	spin_unlock(&inode->i_lock);
fs/nfs/dir.c:	spin_unlock(&inode->i_lock);
fs/nfs/dir.c:			if (!S_ISDIR(inode->i_mode))
fs/nfs/dir.c:	switch (inode->i_mode & S_IFMT) {
fs/nfs/dir.c:		inode->i_sb->s_id, inode->i_ino, mask, res);
fs/nfs/symlink.c:	err = ERR_PTR(nfs_revalidate_mapping(inode, inode->i_mapping));
fs/nfs/symlink.c:	page = read_cache_page(&inode->i_data, 0,
fs/nfs/callback_proc.c:	res->ctime = inode->i_ctime;
fs/nfs/callback_proc.c:	res->mtime = inode->i_mtime;
fs/nfs/pnfs.c:	if (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {
fs/nfs/pnfs.c:		spin_unlock(&inode->i_lock);
fs/nfs/pnfs.c:	spin_lock(&inode->i_lock);
fs/nfs/pnfs.c:	spin_unlock(&inode->i_lock);
fs/nfs/pnfs.c:	if (atomic_dec_and_lock(&lseg->pls_refcount, &inode->i_lock)) {
fs/nfs/pnfs.c:		spin_unlock(&inode->i_lock);
fs/nfs/pnfs.c:	spin_lock(&inode->i_lock);
fs/nfs/pnfs.c:	spin_unlock(&inode->i_lock);
fs/nfs/pnfs.c:			lo->plh_inode->i_ino);
fs/nfs/pnfs.c:		spin_lock(&inode->i_lock);
fs/nfs/pnfs.c:		spin_unlock(&inode->i_lock);
fs/nfs/pnfs.c:	spin_lock(&lo->plh_inode->i_lock);
fs/nfs/pnfs.c:	spin_unlock(&lo->plh_inode->i_lock);
fs/nfs/pnfs.c:		inode->i_ino, wdata->args.count, wdata->args.offset, how);
fs/nfs/pnfs.c:		__func__, inode->i_ino, rdata->args.count, rdata->args.offset);
fs/nfs/pnfs.c:	spin_lock(&inode->i_lock);
fs/nfs/pnfs.c:			__func__, inode->i_ino);
fs/nfs/pnfs.c:	spin_unlock(&inode->i_lock);
fs/nfs/pnfs.c:	dprintk("--> %s inode %lu\n", __func__, inode->i_ino);
fs/nfs/pnfs.c:	spin_lock(&inode->i_lock);
fs/nfs/pnfs.c:		spin_unlock(&inode->i_lock);
fs/nfs/pnfs.c:	spin_unlock(&inode->i_lock);
fs/nfs/nfs3proc.c:	if (S_ISDIR(inode->i_mode)) {
fs/nfs/write.c:	spin_lock(&inode->i_lock);
fs/nfs/write.c:	spin_unlock(&inode->i_lock);
fs/nfs/write.c:	spin_lock(&inode->i_lock);
fs/nfs/write.c:	spin_unlock(&inode->i_lock);
fs/nfs/write.c:	spin_lock(&inode->i_lock);
fs/nfs/write.c:		spin_unlock(&inode->i_lock);
fs/nfs/write.c:		spin_lock(&inode->i_lock);
fs/nfs/write.c:	spin_unlock(&inode->i_lock);
fs/nfs/write.c:	spin_lock(&inode->i_lock);
fs/nfs/write.c:		inode->i_version++;
fs/nfs/write.c:	spin_unlock(&inode->i_lock);
fs/nfs/write.c:	spin_lock(&inode->i_lock);
fs/nfs/write.c:	spin_unlock(&inode->i_lock);
fs/nfs/write.c:	cinfo->lock = &inode->i_lock;
fs/nfs/write.c:	spin_lock(&inode->i_lock);
fs/nfs/write.c:		spin_unlock(&inode->i_lock);
fs/nfs/write.c:		spin_lock(&inode->i_lock);
fs/nfs/write.c:	spin_unlock(&inode->i_lock);
fs/nfs/write.c:	spin_unlock(&inode->i_lock);
fs/nfs/write.c:			inode->i_flock == NULL &&
fs/nfs/write.c:		inode->i_sb->s_id,
fs/nfs/file.c:		ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/nfs/file.c:		mutex_lock(&inode->i_mutex);
fs/nfs/file.c:		mutex_unlock(&inode->i_mutex);
fs/nfs/file.c:		inode->i_ino, (long long)page_offset(page));
fs/nfs/file.c:	if (mapping != dentry->d_inode->i_mapping)
fs/nfs/objlayout/objlayout.c:		__func__, inode->i_ino, offset, count, rdata->res.eof);
fs/nfs/objlayout/objio_osd.c:	struct address_space *mapping = wdata->header->inode->i_mapping;
fs/nfs/read.c:			req->wb_context->dentry->d_inode->i_sb->s_id,
fs/nfs/read.c:			inode->i_sb->s_id,
fs/nfs/read.c:			inode->i_sb->s_id,
fs/nfs/nfs4filelayout.c:			hdr->inode->i_sb->s_id,
fs/nfs/nfs4filelayout.c:			hdr->inode->i_sb->s_id,
fs/nfs/nfs4filelayout.c:	dprintk("%s ionde %lu pls_end_pos %lu\n", __func__, hdr->inode->i_ino,
fs/nfs/nfs4filelayout.c:		__func__, hdr->inode->i_ino,
fs/nfs/nfs4filelayout.c:		__func__, hdr->inode->i_ino, sync, (size_t) data->args.count,
fs/nfs/nfs4filelayout.c:		data->inode->i_ino, how, atomic_read(&ds->ds_clp->cl_count));
fs/hugetlbfs/inode.c:	mutex_lock(&inode->i_mutex);
fs/hugetlbfs/inode.c:	if (vma->vm_flags & VM_WRITE && inode->i_size < len)
fs/hugetlbfs/inode.c:		inode->i_size = len;
fs/hugetlbfs/inode.c:	mutex_unlock(&inode->i_mutex);
fs/hugetlbfs/inode.c:	struct address_space *mapping = &inode->i_data;
fs/hugetlbfs/inode.c:	struct address_space *mapping = inode->i_mapping;
fs/hugetlbfs/inode.c:		inode->i_ino = get_next_ino();
fs/hugetlbfs/inode.c:		inode->i_mode = S_IFDIR | config->mode;
fs/hugetlbfs/inode.c:		inode->i_uid = config->uid;
fs/hugetlbfs/inode.c:		inode->i_gid = config->gid;
fs/hugetlbfs/inode.c:		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/hugetlbfs/inode.c:		inode->i_op = &hugetlbfs_dir_inode_operations;
fs/hugetlbfs/inode.c:		inode->i_fop = &simple_dir_operations;
fs/hugetlbfs/inode.c:		inode->i_ino = get_next_ino();
fs/hugetlbfs/inode.c:		inode->i_mapping->a_ops = &hugetlbfs_aops;
fs/hugetlbfs/inode.c:		inode->i_mapping->backing_dev_info =&hugetlbfs_backing_dev_info;
fs/hugetlbfs/inode.c:		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/hugetlbfs/inode.c:		INIT_LIST_HEAD(&inode->i_mapping->private_list);
fs/hugetlbfs/inode.c:			inode->i_op = &hugetlbfs_inode_operations;
fs/hugetlbfs/inode.c:			inode->i_fop = &hugetlbfs_file_operations;
fs/hugetlbfs/inode.c:			inode->i_op = &hugetlbfs_dir_inode_operations;
fs/hugetlbfs/inode.c:			inode->i_fop = &simple_dir_operations;
fs/hugetlbfs/inode.c:			inode->i_op = &page_symlink_inode_operations;
fs/hugetlbfs/inode.c:	hugetlbfs_inc_free_inodes(HUGETLBFS_SB(inode->i_sb));
fs/hugetlbfs/inode.c:	call_rcu(&inode->i_rcu, hugetlbfs_i_callback);
fs/hugetlbfs/inode.c:	inode->i_size = size;
fs/lockd/svcsubs.c:		msg, inode->i_sb->s_id, inode->i_ino);
fs/lockd/svcsubs.c:	for (fl = inode->i_flock; fl; fl = fl->fl_next) {
fs/lockd/svcsubs.c:	for (fl = inode->i_flock; fl; fl = fl->fl_next) {
fs/lockd/svclock.c:				file->f_file->f_path.dentry->d_inode->i_sb->s_id,
fs/lockd/svclock.c:				file->f_file->f_path.dentry->d_inode->i_ino,
fs/lockd/svclock.c:				file->f_file->f_path.dentry->d_inode->i_sb->s_id,
fs/lockd/svclock.c:				file->f_file->f_path.dentry->d_inode->i_ino,
fs/lockd/svclock.c:				file->f_file->f_path.dentry->d_inode->i_sb->s_id,
fs/lockd/svclock.c:				file->f_file->f_path.dentry->d_inode->i_ino,
fs/lockd/svclock.c:				file->f_file->f_path.dentry->d_inode->i_sb->s_id,
fs/lockd/svclock.c:				file->f_file->f_path.dentry->d_inode->i_ino,
fs/sysv/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/sysv/inode.c:		inode->i_op = &sysv_file_inode_operations;
fs/sysv/inode.c:		inode->i_fop = &sysv_file_operations;
fs/sysv/inode.c:		inode->i_mapping->a_ops = &sysv_aops;
fs/sysv/inode.c:	} else if (S_ISDIR(inode->i_mode)) {
fs/sysv/inode.c:		inode->i_op = &sysv_dir_inode_operations;
fs/sysv/inode.c:		inode->i_fop = &sysv_dir_operations;
fs/sysv/inode.c:		inode->i_mapping->a_ops = &sysv_aops;
fs/sysv/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/sysv/inode.c:		if (inode->i_blocks) {
fs/sysv/inode.c:			inode->i_op = &sysv_symlink_inode_operations;
fs/sysv/inode.c:			inode->i_mapping->a_ops = &sysv_aops;
fs/sysv/inode.c:			inode->i_op = &sysv_fast_symlink_inode_operations;
fs/sysv/inode.c:			nd_terminate_link(SYSV_I(inode)->i_data, inode->i_size,
fs/sysv/inode.c:		init_special_inode(inode, inode->i_mode, rdev);
fs/sysv/inode.c:	if (!(inode->i_state & I_NEW))
fs/sysv/inode.c:		       inode->i_sb->s_id);
fs/sysv/inode.c:	inode->i_mode = fs16_to_cpu(sbi, raw_inode->i_mode);
fs/sysv/inode.c:	i_uid_write(inode, (uid_t)fs16_to_cpu(sbi, raw_inode->i_uid));
fs/sysv/inode.c:	i_gid_write(inode, (gid_t)fs16_to_cpu(sbi, raw_inode->i_gid));
fs/sysv/inode.c:	set_nlink(inode, fs16_to_cpu(sbi, raw_inode->i_nlink));
fs/sysv/inode.c:	inode->i_size = fs32_to_cpu(sbi, raw_inode->i_size);
fs/sysv/inode.c:	inode->i_atime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_atime);
fs/sysv/inode.c:	inode->i_mtime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_mtime);
fs/sysv/inode.c:	inode->i_ctime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_ctime);
fs/sysv/inode.c:	inode->i_ctime.tv_nsec = 0;
fs/sysv/inode.c:	inode->i_atime.tv_nsec = 0;
fs/sysv/inode.c:	inode->i_mtime.tv_nsec = 0;
fs/sysv/inode.c:	inode->i_blocks = 0;
fs/sysv/inode.c:		read3byte(sbi, &raw_inode->i_data[3*block],
fs/sysv/inode.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
fs/sysv/inode.c:	struct super_block * sb = inode->i_sb;
fs/sysv/inode.c:	ino = inode->i_ino;
fs/sysv/inode.c:		       inode->i_sb->s_id, ino);
fs/sysv/inode.c:	raw_inode->i_mode = cpu_to_fs16(sbi, inode->i_mode);
fs/sysv/inode.c:	raw_inode->i_uid = cpu_to_fs16(sbi, fs_high2lowuid(i_uid_read(inode)));
fs/sysv/inode.c:	raw_inode->i_gid = cpu_to_fs16(sbi, fs_high2lowgid(i_gid_read(inode)));
fs/sysv/inode.c:	raw_inode->i_nlink = cpu_to_fs16(sbi, inode->i_nlink);
fs/sysv/inode.c:	raw_inode->i_size = cpu_to_fs32(sbi, inode->i_size);
fs/sysv/inode.c:	raw_inode->i_atime = cpu_to_fs32(sbi, inode->i_atime.tv_sec);
fs/sysv/inode.c:	raw_inode->i_mtime = cpu_to_fs32(sbi, inode->i_mtime.tv_sec);
fs/sysv/inode.c:	raw_inode->i_ctime = cpu_to_fs32(sbi, inode->i_ctime.tv_sec);
fs/sysv/inode.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
fs/sysv/inode.c:		si->i_data[0] = cpu_to_fs32(sbi, old_encode_dev(inode->i_rdev));
fs/sysv/inode.c:			&raw_inode->i_data[3*block]);
fs/sysv/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/sysv/inode.c:	if (!inode->i_nlink) {
fs/sysv/inode.c:		inode->i_size = 0;
fs/sysv/inode.c:	if (!inode->i_nlink)
fs/sysv/inode.c:	call_rcu(&inode->i_rcu, sysv_i_callback);
fs/sysv/itree.c:	struct super_block *sb = inode->i_sb;
fs/sysv/itree.c:	struct super_block *sb = inode->i_sb;
fs/sysv/itree.c:	int blocksize = inode->i_sb->s_blocksize;
fs/sysv/itree.c:	branch[0].key = sysv_new_block(inode->i_sb);
fs/sysv/itree.c:		branch[n].key = sysv_new_block(inode->i_sb);
fs/sysv/itree.c:		parent = block_to_cpu(SYSV_SB(inode->i_sb), branch[n-1].key);
fs/sysv/itree.c:		bh = sb_getblk(inode->i_sb, parent);
fs/sysv/itree.c:		sysv_free_block(inode->i_sb, branch[i].key);
fs/sysv/itree.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/sysv/itree.c:		sysv_free_block(inode->i_sb, where[i].key);
fs/sysv/itree.c:	struct super_block *sb = inode->i_sb;
fs/sysv/itree.c:			sysv_free_block(inode->i_sb, nr);
fs/sysv/itree.c:	struct super_block *sb = inode->i_sb;
fs/sysv/itree.c:	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
fs/sysv/itree.c:	    S_ISLNK(inode->i_mode)))
fs/sysv/itree.c:	blocksize = inode->i_sb->s_blocksize;
fs/sysv/itree.c:	iblock = (inode->i_size + blocksize-1)
fs/sysv/itree.c:					>> inode->i_sb->s_blocksize_bits;
fs/sysv/itree.c:	block_truncate_page(inode->i_mapping, inode->i_size, get_block);
fs/sysv/itree.c:	inode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;
fs/sysv/itree.c:	if (to > inode->i_size) {
fs/sysv/itree.c:		truncate_pagecache(inode, to, inode->i_size);
fs/sysv/dir.c:	return (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;
fs/sysv/dir.c:	struct super_block *sb = inode->i_sb;
fs/sysv/dir.c:	if (pos >= inode->i_size)
fs/sysv/dir.c:	de->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);
fs/sysv/dir.c:	inode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;
fs/sysv/dir.c:	struct page *page = grab_cache_page(inode->i_mapping, 0);
fs/sysv/dir.c:	de->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);
fs/sysv/dir.c:	de->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), dir->i_ino);
fs/sysv/dir.c:	struct super_block *sb = inode->i_sb;
fs/sysv/dir.c:							inode->i_ino))
fs/sysv/dir.c:	de->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);
fs/sysv/namei.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/sysv/namei.c:	inode->i_ctime = dir->i_ctime;
fs/sysv/namei.c:			inode->i_size = 0;
fs/sysv/namei.c:	if (S_ISDIR(old_inode->i_mode)) {
fs/sysv/namei.c:		new_inode->i_ctime = CURRENT_TIME_SEC;
fs/sysv/ialloc.c:		if (raw_inode->i_mode == 0 && raw_inode->i_nlink == 0) {
fs/sysv/ialloc.c:	struct super_block *sb = inode->i_sb;
fs/sysv/ialloc.c:	sb = inode->i_sb;
fs/sysv/ialloc.c:	ino = inode->i_ino;
fs/sysv/ialloc.c:		       "%s\n", inode->i_sb->s_id);
fs/sysv/ialloc.c:	inode->i_ino = fs16_to_cpu(sbi, ino);
fs/sysv/ialloc.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
fs/sysv/ialloc.c:	inode->i_blocks = 0;
fs/sysv/ialloc.c:		if (raw_inode->i_mode == 0 && raw_inode->i_nlink == 0)
fs/hfsplus/inode.c:	if (to > inode->i_size) {
fs/hfsplus/inode.c:		truncate_pagecache(inode, to, inode->i_size);
fs/hfsplus/inode.c:	struct super_block *sb = inode->i_sb;
fs/hfsplus/inode.c:	switch (inode->i_ino) {
fs/hfsplus/inode.c:	struct inode *inode = file->f_path.dentry->d_inode->i_mapping->host;
fs/hfsplus/inode.c:	inode->i_ino = dir->i_ino;
fs/hfsplus/inode.c:	hlist_add_fake(&inode->i_hash);
fs/hfsplus/inode.c:	struct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);
fs/hfsplus/inode.c:		inode->i_uid = sbi->uid;
fs/hfsplus/inode.c:		inode->i_gid = sbi->gid;
fs/hfsplus/inode.c:	inode->i_mode = mode;
fs/hfsplus/inode.c:		inode->i_flags |= S_IMMUTABLE;
fs/hfsplus/inode.c:		inode->i_flags &= ~S_IMMUTABLE;
fs/hfsplus/inode.c:		inode->i_flags |= S_APPEND;
fs/hfsplus/inode.c:		inode->i_flags &= ~S_APPEND;
fs/hfsplus/inode.c:	struct super_block *sb = inode->i_sb;
fs/hfsplus/inode.c:		mutex_lock(&inode->i_mutex);
fs/hfsplus/inode.c:		if (inode->i_flags & S_DEAD) {
fs/hfsplus/inode.c:			hfsplus_delete_cat(inode->i_ino,
fs/hfsplus/inode.c:		mutex_unlock(&inode->i_mutex);
fs/hfsplus/inode.c:	struct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);
fs/hfsplus/inode.c:	error = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/hfsplus/inode.c:	mutex_lock(&inode->i_mutex);
fs/hfsplus/inode.c:		error = filemap_write_and_wait(sbi->cat_tree->inode->i_mapping);
fs/hfsplus/inode.c:			filemap_write_and_wait(sbi->ext_tree->inode->i_mapping);
fs/hfsplus/inode.c:		blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);
fs/hfsplus/inode.c:	mutex_unlock(&inode->i_mutex);
fs/hfsplus/inode.c:	inode->i_ino = sbi->next_cnid++;
fs/hfsplus/inode.c:	inode->i_mode = mode;
fs/hfsplus/inode.c:	inode->i_uid = current_fsuid();
fs/hfsplus/inode.c:	inode->i_gid = current_fsgid();
fs/hfsplus/inode.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
fs/hfsplus/inode.c:	if (S_ISDIR(inode->i_mode)) {
fs/hfsplus/inode.c:		inode->i_size = 2;
fs/hfsplus/inode.c:		inode->i_op = &hfsplus_dir_inode_operations;
fs/hfsplus/inode.c:		inode->i_fop = &hfsplus_dir_operations;
fs/hfsplus/inode.c:	} else if (S_ISREG(inode->i_mode)) {
fs/hfsplus/inode.c:		inode->i_op = &hfsplus_file_inode_operations;
fs/hfsplus/inode.c:		inode->i_fop = &hfsplus_file_operations;
fs/hfsplus/inode.c:		inode->i_mapping->a_ops = &hfsplus_aops;
fs/hfsplus/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/hfsplus/inode.c:		inode->i_op = &page_symlink_inode_operations;
fs/hfsplus/inode.c:		inode->i_mapping->a_ops = &hfsplus_aops;
fs/hfsplus/inode.c:	struct super_block *sb = inode->i_sb;
fs/hfsplus/inode.c:	if (S_ISDIR(inode->i_mode)) {
fs/hfsplus/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/hfsplus/inode.c:		if (!inode->i_nlink) {
fs/hfsplus/inode.c:			inode->i_size = 0;
fs/hfsplus/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/hfsplus/inode.c:		inode->i_size = 0;
fs/hfsplus/inode.c:	struct super_block *sb = inode->i_sb;
fs/hfsplus/inode.c:	hip->phys_size = inode->i_size = be64_to_cpu(fork->total_size);
fs/hfsplus/inode.c:		(inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;
fs/hfsplus/inode.c:	fork->total_size = cpu_to_be64(inode->i_size);
fs/hfsplus/inode.c:		inode->i_size = 2 + be32_to_cpu(folder->valence);
fs/hfsplus/inode.c:		inode->i_atime = hfsp_mt2ut(folder->access_date);
fs/hfsplus/inode.c:		inode->i_mtime = hfsp_mt2ut(folder->content_mod_date);
fs/hfsplus/inode.c:		inode->i_ctime = hfsp_mt2ut(folder->attribute_mod_date);
fs/hfsplus/inode.c:		inode->i_op = &hfsplus_dir_inode_operations;
fs/hfsplus/inode.c:		inode->i_fop = &hfsplus_dir_operations;
fs/hfsplus/inode.c:		if (S_ISREG(inode->i_mode)) {
fs/hfsplus/inode.c:			inode->i_op = &hfsplus_file_inode_operations;
fs/hfsplus/inode.c:			inode->i_fop = &hfsplus_file_operations;
fs/hfsplus/inode.c:			inode->i_mapping->a_ops = &hfsplus_aops;
fs/hfsplus/inode.c:		} else if (S_ISLNK(inode->i_mode)) {
fs/hfsplus/inode.c:			inode->i_op = &page_symlink_inode_operations;
fs/hfsplus/inode.c:			inode->i_mapping->a_ops = &hfsplus_aops;
fs/hfsplus/inode.c:			init_special_inode(inode, inode->i_mode,
fs/hfsplus/inode.c:		inode->i_atime = hfsp_mt2ut(file->access_date);
fs/hfsplus/inode.c:		inode->i_mtime = hfsp_mt2ut(file->content_mod_date);
fs/hfsplus/inode.c:		inode->i_ctime = hfsp_mt2ut(file->attribute_mod_date);
fs/hfsplus/inode.c:	if (!main_inode->i_nlink)
fs/hfsplus/inode.c:	if (hfs_find_init(HFSPLUS_SB(main_inode->i_sb)->cat_tree, &fd))
fs/hfsplus/inode.c:	if (hfsplus_find_cat(main_inode->i_sb, main_inode->i_ino, &fd))
fs/hfsplus/inode.c:	if (S_ISDIR(main_inode->i_mode)) {
fs/hfsplus/inode.c:		folder->access_date = hfsp_ut2mt(inode->i_atime);
fs/hfsplus/inode.c:		folder->content_mod_date = hfsp_ut2mt(inode->i_mtime);
fs/hfsplus/inode.c:		folder->attribute_mod_date = hfsp_ut2mt(inode->i_ctime);
fs/hfsplus/inode.c:		folder->valence = cpu_to_be32(inode->i_size - 2);
fs/hfsplus/inode.c:		file->access_date = hfsp_ut2mt(inode->i_atime);
fs/hfsplus/inode.c:		file->content_mod_date = hfsp_ut2mt(inode->i_mtime);
fs/hfsplus/inode.c:		file->attribute_mod_date = hfsp_ut2mt(inode->i_ctime);
fs/hfsplus/super.c:	struct hfsplus_vh *vhdr = HFSPLUS_SB(inode->i_sb)->s_vhdr;
fs/hfsplus/super.c:	switch (inode->i_ino) {
fs/hfsplus/super.c:		inode->i_mapping->a_ops = &hfsplus_btree_aops;
fs/hfsplus/super.c:		inode->i_mapping->a_ops = &hfsplus_btree_aops;
fs/hfsplus/super.c:		inode->i_mapping->a_ops = &hfsplus_aops;
fs/hfsplus/super.c:		inode->i_mapping->a_ops = &hfsplus_btree_aops;
fs/hfsplus/super.c:	if (!(inode->i_state & I_NEW))
fs/hfsplus/super.c:	if (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||
fs/hfsplus/super.c:	    inode->i_ino == HFSPLUS_ROOT_CNID) {
fs/hfsplus/super.c:		err = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);
fs/hfsplus/super.c:			err = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);
fs/hfsplus/super.c:	struct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);
fs/hfsplus/super.c:	switch (inode->i_ino) {
fs/hfsplus/super.c:	if (fork->total_size != cpu_to_be64(inode->i_size)) {
fs/hfsplus/super.c:		hfsplus_mark_mdb_dirty(inode->i_sb);
fs/hfsplus/super.c:					err, inode->i_ino);
fs/hfsplus/super.c:	dprint(DBG_INODE, "hfsplus_write_inode: %lu\n", inode->i_ino);
fs/hfsplus/super.c:	if (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||
fs/hfsplus/super.c:	    inode->i_ino == HFSPLUS_ROOT_CNID)
fs/hfsplus/super.c:	dprint(DBG_INODE, "hfsplus_evict_inode: %lu\n", inode->i_ino);
fs/hfsplus/super.c:	truncate_inode_pages(&inode->i_data, 0);
fs/hfsplus/super.c:	error = filemap_write_and_wait(sbi->cat_tree->inode->i_mapping);
fs/hfsplus/super.c:	error2 = filemap_write_and_wait(sbi->ext_tree->inode->i_mapping);
fs/hfsplus/super.c:	call_rcu(&inode->i_rcu, hfsplus_i_callback);
fs/hfsplus/extents.c:	hfsplus_ext_build_key(fd->search_key, inode->i_ino, hip->cached_start,
fs/hfsplus/extents.c:		res = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);
fs/hfsplus/extents.c:	res = __hfsplus_ext_read_extent(fd, hip->cached_extents, inode->i_ino,
fs/hfsplus/extents.c:	res = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);
fs/hfsplus/extents.c:	struct super_block *sb = inode->i_sb;
fs/hfsplus/extents.c:	if (inode->i_ino == HFSPLUS_EXT_CNID)
fs/hfsplus/extents.c:		inode->i_ino, (long long)iblock, dblock);
fs/hfsplus/extents.c:	struct super_block *sb = inode->i_sb;
fs/hfsplus/extents.c:	dprint(DBG_EXTENT, "extend %lu: %u,%u\n", inode->i_ino, start, len);
fs/hfsplus/extents.c:	struct super_block *sb = inode->i_sb;
fs/hfsplus/extents.c:		inode->i_ino, (long long)hip->phys_size,
fs/hfsplus/extents.c:		inode->i_size);
fs/hfsplus/extents.c:	if (inode->i_size > hip->phys_size) {
fs/hfsplus/extents.c:		struct address_space *mapping = inode->i_mapping;
fs/hfsplus/extents.c:		loff_t size = inode->i_size;
fs/hfsplus/extents.c:	} else if (inode->i_size == hip->phys_size)
fs/hfsplus/extents.c:	blk_cnt = (inode->i_size + HFSPLUS_SB(sb)->alloc_blksz - 1) >>
fs/hfsplus/extents.c:	hip->phys_size = inode->i_size;
fs/hfsplus/extents.c:	hip->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >>
fs/hfsplus/bnode.c:	sb = tree->inode->i_sb;
fs/hfsplus/bnode.c:	mapping = tree->inode->i_mapping;
fs/hfsplus/dir.c:	if (S_ISREG(inode->i_mode))
fs/hfsplus/dir.c:	struct super_block *sb = inode->i_sb;
fs/hfsplus/dir.c:	if (filp->f_pos >= inode->i_size)
fs/hfsplus/dir.c:	hfsplus_cat_build_key(sb, fd.search_key, inode->i_ino, NULL);
fs/hfsplus/dir.c:		if (filldir(dirent, ".", 1, 0, inode->i_ino, DT_DIR))
fs/hfsplus/dir.c:		if (filp->f_pos >= inode->i_size)
fs/hfsplus/dir.c:		if (be32_to_cpu(fd.key->cat.parent) != inode->i_ino) {
fs/hfsplus/dir.c:		if (filp->f_pos >= inode->i_size)
fs/hfsplus/dir.c:		mutex_lock(&inode->i_mutex);
fs/hfsplus/dir.c:		mutex_unlock(&inode->i_mutex);
fs/hfsplus/dir.c:	if (!S_ISREG(inode->i_mode))
fs/hfsplus/dir.c:	if (inode->i_ino == (u32)(unsigned long)src_dentry->d_fsdata) {
fs/hfsplus/dir.c:			res = hfsplus_rename_cat(inode->i_ino,
fs/hfsplus/dir.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/hfsplus/dir.c:	if (inode->i_ino == cnid &&
fs/hfsplus/dir.c:		str.len = sprintf(name, "temp%lu", inode->i_ino);
fs/hfsplus/dir.c:		res = hfsplus_rename_cat(inode->i_ino,
fs/hfsplus/dir.c:			inode->i_flags |= S_DEAD;
fs/hfsplus/dir.c:	if (inode->i_nlink > 0)
fs/hfsplus/dir.c:	if (inode->i_ino == cnid)
fs/hfsplus/dir.c:	if (!inode->i_nlink) {
fs/hfsplus/dir.c:		if (inode->i_ino != cnid) {
fs/hfsplus/dir.c:				res = hfsplus_delete_cat(inode->i_ino,
fs/hfsplus/dir.c:				inode->i_flags |= S_DEAD;
fs/hfsplus/dir.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/hfsplus/dir.c:	if (inode->i_size != 2)
fs/hfsplus/dir.c:	res = hfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);
fs/hfsplus/dir.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/hfsplus/dir.c:	res = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);
fs/hfsplus/dir.c:	hfsplus_instantiate(dentry, inode, inode->i_ino);
fs/hfsplus/dir.c:	res = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);
fs/hfsplus/dir.c:	hfsplus_instantiate(dentry, inode, inode->i_ino);
fs/hfsplus/dir.c:		if (S_ISDIR(new_dentry->d_inode->i_mode))
fs/hfsplus/btree.c:	mapping = tree->inode->i_mapping;
fs/hfsplus/btree.c:	tree->inode->i_mapping->a_ops = &hfsplus_aops;
fs/hfsplus/btree.c:		hip->phys_size = inode->i_size =
fs/hfsplus/btree.c:		inode_set_bytes(inode, inode->i_size);
fs/hfsplus/btree.c:		count = inode->i_size >> tree->node_size_shift;
fs/hfsplus/wrapper.c:	*size = sb->s_bdev->bd_inode->i_size >> 9;
fs/hfsplus/ioctl.c:	struct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);
fs/hfsplus/ioctl.c:	if (inode->i_flags & S_IMMUTABLE)
fs/hfsplus/ioctl.c:	if (inode->i_flags & S_APPEND)
fs/hfsplus/ioctl.c:	mutex_lock(&inode->i_mutex);
fs/hfsplus/ioctl.c:	    inode->i_flags & (S_IMMUTABLE|S_APPEND)) {
fs/hfsplus/ioctl.c:		inode->i_flags |= S_IMMUTABLE;
fs/hfsplus/ioctl.c:		inode->i_flags &= ~S_IMMUTABLE;
fs/hfsplus/ioctl.c:		inode->i_flags |= S_APPEND;
fs/hfsplus/ioctl.c:		inode->i_flags &= ~S_APPEND;
fs/hfsplus/ioctl.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/hfsplus/ioctl.c:	mutex_unlock(&inode->i_mutex);
fs/hfsplus/ioctl.c:	if (!S_ISREG(inode->i_mode) || HFSPLUS_IS_RSRC(inode))
fs/hfsplus/ioctl.c:	res = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);
fs/hfsplus/ioctl.c:	res = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);
fs/hfsplus/ioctl.c:	if (!S_ISREG(inode->i_mode) || HFSPLUS_IS_RSRC(inode))
fs/hfsplus/ioctl.c:		res = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);
fs/hfsplus/ioctl.c:		res = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);
fs/hfsplus/ioctl.c:	if (!S_ISREG(inode->i_mode) || HFSPLUS_IS_RSRC(inode))
fs/hfsplus/catalog.c:	if (inode->i_flags & S_IMMUTABLE)
fs/hfsplus/catalog.c:	if (inode->i_flags & S_APPEND)
fs/hfsplus/catalog.c:	perms->mode = cpu_to_be16(inode->i_mode);
fs/hfsplus/catalog.c:	if (S_ISREG(inode->i_mode))
fs/hfsplus/catalog.c:		perms->dev = cpu_to_be32(inode->i_nlink);
fs/hfsplus/catalog.c:	else if (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode))
fs/hfsplus/catalog.c:		perms->dev = cpu_to_be32(inode->i_rdev);
fs/hfsplus/catalog.c:	struct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);
fs/hfsplus/catalog.c:	if (S_ISDIR(inode->i_mode)) {
fs/hfsplus/catalog.c:		folder->id = cpu_to_be32(inode->i_ino);
fs/hfsplus/catalog.c:		if (cnid == inode->i_ino) {
fs/hfsplus/catalog.c:			if (S_ISLNK(inode->i_mode)) {
fs/hfsplus/catalog.c:		str->name, cnid, inode->i_nlink);
fs/hfsplus/catalog.c:		S_ISDIR(inode->i_mode) ?
fs/autofs4/inode.c:	if (!uid_eq(root_inode->i_uid, GLOBAL_ROOT_UID))
fs/autofs4/inode.c:			from_kuid_munged(&init_user_ns, root_inode->i_uid));
fs/autofs4/inode.c:	if (!gid_eq(root_inode->i_gid, GLOBAL_ROOT_GID))
fs/autofs4/inode.c:			from_kgid_munged(&init_user_ns, root_inode->i_gid));
fs/autofs4/inode.c:	kfree(inode->i_private);
fs/autofs4/inode.c:	if (parse_options(data, &pipefd, &root_inode->i_uid, &root_inode->i_gid,
fs/autofs4/inode.c:	root_inode->i_fop = &autofs4_root_operations;
fs/autofs4/inode.c:	root_inode->i_op = &autofs4_dir_inode_operations;
fs/autofs4/inode.c:	inode->i_mode = mode;
fs/autofs4/inode.c:		inode->i_uid = sb->s_root->d_inode->i_uid;
fs/autofs4/inode.c:		inode->i_gid = sb->s_root->d_inode->i_gid;
fs/autofs4/inode.c:	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/autofs4/inode.c:	inode->i_ino = get_next_ino();
fs/autofs4/inode.c:		inode->i_op = &autofs4_dir_inode_operations;
fs/autofs4/inode.c:		inode->i_fop = &autofs4_dir_operations;
fs/autofs4/inode.c:		inode->i_op = &autofs4_symlink_inode_operations;
fs/autofs4/autofs_i.h:	if (!S_ISFIFO(pipe->f_dentry->d_inode->i_mode))
fs/autofs4/autofs_i.h:	return sbi->sb->s_root->d_inode->i_ino;
fs/autofs4/dev-ioctl.c:		sbi = autofs4_sbi(inode->i_sb);
fs/autofs4/symlink.c:	nd_set_link(nd, dentry->d_inode->i_private);
fs/autofs4/root.c:	if (dentry->d_inode && S_ISLNK(dentry->d_inode->i_mode)) {
fs/autofs4/root.c:		    (dentry->d_inode && S_ISLNK(dentry->d_inode->i_mode)))
fs/autofs4/root.c:	inode->i_private = cp;
fs/autofs4/root.c:	inode->i_size = size;
fs/autofs4/root.c:	dentry->d_inode->i_size = 0;
fs/autofs4/root.c:	dentry->d_inode->i_size = 0;
fs/autofs4/root.c:	struct autofs_sb_info *sbi = autofs4_sbi(inode->i_sb);
fs/autofs4/root.c:		return autofs4_expire_run(inode->i_sb,filp->f_path.mnt,sbi, p);
fs/autofs4/root.c:		return autofs4_expire_multi(inode->i_sb,filp->f_path.mnt,sbi, p);
fs/open.c:	/* Not pretty: "inode->i_size" shouldn't really be signed. But it is. */
fs/open.c:	mutex_lock(&dentry->d_inode->i_mutex);
fs/open.c:	mutex_unlock(&dentry->d_inode->i_mutex);
fs/open.c:	if (S_ISDIR(inode->i_mode))
fs/open.c:	if (!S_ISREG(inode->i_mode))
fs/open.c:	if (!S_ISREG(inode->i_mode) || !(f.file->f_mode & FMODE_WRITE))
fs/open.c:	sb_start_write(inode->i_sb);
fs/open.c:	sb_end_write(inode->i_sb);
fs/open.c:	if (S_ISFIFO(inode->i_mode))
fs/open.c:	if (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))
fs/open.c:	if (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))
fs/open.c:	sb_start_write(inode->i_sb);
fs/open.c:	sb_end_write(inode->i_sb);
fs/open.c:	if ((mode & MAY_EXEC) && S_ISREG(inode->i_mode)) {
fs/open.c:	if (res || !(mode & S_IWOTH) || special_file(inode->i_mode))
fs/open.c:	if (!S_ISDIR(inode->i_mode))
fs/open.c:	mutex_lock(&inode->i_mutex);
fs/open.c:	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
fs/open.c:	mutex_unlock(&inode->i_mutex);
fs/open.c:	if (!S_ISDIR(inode->i_mode))
fs/open.c:	mutex_lock(&inode->i_mutex);
fs/open.c:	mutex_unlock(&inode->i_mutex);
fs/open.c:	if (!special_file(inode->i_mode)) {
fs/open.c:		if (!special_file(inode->i_mode))
fs/open.c:	f->f_mapping = inode->i_mapping;
fs/open.c:	file_sb_list_add(f, inode->i_sb);
fs/open.c:	f->f_op = fops_get(inode->i_fop);
fs/open.c:		if (!special_file(inode->i_mode)) {
fs/open.c:		if (!dentry->d_inode->i_op->lookup)
fs/posix_acl.c:				if (uid_eq(inode->i_uid, current_fsuid()))
fs/posix_acl.c:                                if (in_group_p(inode->i_gid)) {
fs/ubifs/super.c:	if (inode->i_size > c->max_inode_sz) {
fs/ubifs/super.c:			  (long long)inode->i_size);
fs/ubifs/super.c:	if (ui->xattr && !S_ISREG(inode->i_mode))
fs/ubifs/super.c:			   inode->i_ino, ubifs_compr_name(ui->compr_type));
fs/ubifs/super.c:	if (!(inode->i_state & I_NEW))
fs/ubifs/super.c:	ino_key_init(c, &key, inode->i_ino);
fs/ubifs/super.c:	inode->i_flags |= (S_NOCMTIME | S_NOATIME);
fs/ubifs/super.c:	inode->i_atime.tv_sec  = (int64_t)le64_to_cpu(ino->atime_sec);
fs/ubifs/super.c:	inode->i_atime.tv_nsec = le32_to_cpu(ino->atime_nsec);
fs/ubifs/super.c:	inode->i_mtime.tv_sec  = (int64_t)le64_to_cpu(ino->mtime_sec);
fs/ubifs/super.c:	inode->i_mtime.tv_nsec = le32_to_cpu(ino->mtime_nsec);
fs/ubifs/super.c:	inode->i_ctime.tv_sec  = (int64_t)le64_to_cpu(ino->ctime_sec);
fs/ubifs/super.c:	inode->i_ctime.tv_nsec = le32_to_cpu(ino->ctime_nsec);
fs/ubifs/super.c:	inode->i_mode = le32_to_cpu(ino->mode);
fs/ubifs/super.c:	inode->i_size = le64_to_cpu(ino->size);
fs/ubifs/super.c:	ui->synced_i_size = ui->ui_size = inode->i_size;
fs/ubifs/super.c:	inode->i_mapping->backing_dev_info = &c->bdi;
fs/ubifs/super.c:	switch (inode->i_mode & S_IFMT) {
fs/ubifs/super.c:		inode->i_mapping->a_ops = &ubifs_file_address_operations;
fs/ubifs/super.c:		inode->i_op = &ubifs_file_inode_operations;
fs/ubifs/super.c:		inode->i_fop = &ubifs_file_operations;
fs/ubifs/super.c:		inode->i_op  = &ubifs_dir_inode_operations;
fs/ubifs/super.c:		inode->i_fop = &ubifs_dir_operations;
fs/ubifs/super.c:		inode->i_op = &ubifs_symlink_inode_operations;
fs/ubifs/super.c:		inode->i_op = &ubifs_file_inode_operations;
fs/ubifs/super.c:		init_special_inode(inode, inode->i_mode, rdev);
fs/ubifs/super.c:		inode->i_op = &ubifs_file_inode_operations;
fs/ubifs/super.c:		init_special_inode(inode, inode->i_mode, 0);
fs/ubifs/super.c:	ubifs_err("inode %lu validation failed, error %d", inode->i_ino, err);
fs/ubifs/super.c:	ubifs_err("failed to read inode %lu, error %d", inode->i_ino, err);
fs/ubifs/super.c:	call_rcu(&inode->i_rcu, ubifs_i_callback);
fs/ubifs/super.c:	struct ubifs_info *c = inode->i_sb->s_fs_info;
fs/ubifs/super.c:		inode->i_ino, (int)inode->i_mode, inode->i_nlink);
fs/ubifs/super.c:	if (inode->i_nlink) {
fs/ubifs/super.c:				  inode->i_ino, err);
fs/ubifs/super.c:	struct ubifs_info *c = inode->i_sb->s_fs_info;
fs/ubifs/super.c:	dbg_gen("inode %lu, mode %#x", inode->i_ino, (int)inode->i_mode);
fs/ubifs/super.c:	ubifs_assert(!atomic_read(&inode->i_count));
fs/ubifs/super.c:	truncate_inode_pages(&inode->i_data, 0);
fs/ubifs/super.c:	if (inode->i_nlink)
fs/ubifs/super.c:	ui->ui_size = inode->i_size = 0;
fs/ubifs/super.c:			  inode->i_ino, err);
fs/ubifs/super.c:		dbg_gen("inode %lu",  inode->i_ino);
fs/ubifs/tnc.c:	if (!S_ISREG(inode->i_mode))
fs/ubifs/tnc.c:	data_key_init(c, &from_key, inode->i_ino, block);
fs/ubifs/tnc.c:	highest_data_key(c, &to_key, inode->i_ino);
fs/ubifs/tnc.c:		  (unsigned long)inode->i_ino, size,
fs/ubifs/dir.c:	inode->i_flags |= S_NOCMTIME;
fs/ubifs/dir.c:	inode->i_mtime = inode->i_atime = inode->i_ctime =
fs/ubifs/dir.c:	inode->i_mapping->nrpages = 0;
fs/ubifs/dir.c:	inode->i_mapping->backing_dev_info = &c->bdi;
fs/ubifs/dir.c:		inode->i_mapping->a_ops = &ubifs_file_address_operations;
fs/ubifs/dir.c:		inode->i_op = &ubifs_file_inode_operations;
fs/ubifs/dir.c:		inode->i_fop = &ubifs_file_operations;
fs/ubifs/dir.c:		inode->i_op  = &ubifs_dir_inode_operations;
fs/ubifs/dir.c:		inode->i_fop = &ubifs_dir_operations;
fs/ubifs/dir.c:		inode->i_size = ui->ui_size = UBIFS_INO_NODE_SZ;
fs/ubifs/dir.c:		inode->i_op = &ubifs_symlink_inode_operations;
fs/ubifs/dir.c:		inode->i_op  = &ubifs_file_inode_operations;
fs/ubifs/dir.c:	inode->i_ino = ++c->highest_inum;
fs/ubifs/dir.c:	dir->i_mtime = dir->i_ctime = inode->i_ctime;
fs/ubifs/dir.c:		dentry->d_name.len, dentry->d_name.name, inode->i_ino,
fs/ubifs/dir.c:		inode->i_nlink, dir->i_ino);
fs/ubifs/dir.c:	ubifs_assert(mutex_is_locked(&inode->i_mutex));
fs/ubifs/dir.c:	inode->i_ctime = ubifs_current_time(inode);
fs/ubifs/dir.c:	dir->i_mtime = dir->i_ctime = inode->i_ctime;
fs/ubifs/dir.c:	unsigned int saved_nlink = inode->i_nlink;
fs/ubifs/dir.c:		dentry->d_name.len, dentry->d_name.name, inode->i_ino,
fs/ubifs/dir.c:		inode->i_nlink, dir->i_ino);
fs/ubifs/dir.c:	ubifs_assert(mutex_is_locked(&inode->i_mutex));
fs/ubifs/dir.c:	inode->i_ctime = ubifs_current_time(dir);
fs/ubifs/dir.c:	dir->i_mtime = dir->i_ctime = inode->i_ctime;
fs/ubifs/dir.c:		dentry->d_name.name, inode->i_ino, dir->i_ino);
fs/ubifs/dir.c:	ubifs_assert(mutex_is_locked(&inode->i_mutex));
fs/ubifs/dir.c:	inode->i_ctime = ubifs_current_time(dir);
fs/ubifs/dir.c:	dir->i_mtime = dir->i_ctime = inode->i_ctime;
fs/ubifs/dir.c:	dir->i_mtime = dir->i_ctime = inode->i_ctime;
fs/ubifs/dir.c:	init_special_inode(inode, inode->i_mode, rdev);
fs/ubifs/dir.c:	inode->i_size = ubifs_inode(inode)->ui_size = devlen;
fs/ubifs/dir.c:	dir->i_mtime = dir->i_ctime = inode->i_ctime;
fs/ubifs/dir.c:	inode->i_size = ubifs_inode(inode)->ui_size = len;
fs/ubifs/dir.c:	dir->i_mtime = dir->i_ctime = inode->i_ctime;
fs/ubifs/dir.c:	int is_dir = S_ISDIR(old_inode->i_mode);
fs/ubifs/dir.c:		old_inode->i_ino, old_dir->i_ino, new_dentry->d_name.len,
fs/ubifs/dir.c:		ubifs_assert(mutex_is_locked(&new_inode->i_mutex));
fs/ubifs/dir.c:	old_inode->i_ctime = time;
fs/ubifs/dir.c:		saved_nlink = new_inode->i_nlink;
fs/ubifs/dir.c:		new_inode->i_ctime = time;
fs/ubifs/dir.c:		err = old_inode->i_sb->s_op->write_inode(old_inode, NULL);
fs/ubifs/dir.c:	if (S_ISREG(inode->i_mode)) {
fs/ubifs/debug.c:	pr_err("\tinode          %lu\n", inode->i_ino);
fs/ubifs/debug.c:	pr_err("\tnlink          %u\n", inode->i_nlink);
fs/ubifs/debug.c:	       (unsigned int)inode->i_atime.tv_sec,
fs/ubifs/debug.c:	       (unsigned int)inode->i_atime.tv_nsec);
fs/ubifs/debug.c:	       (unsigned int)inode->i_mtime.tv_sec,
fs/ubifs/debug.c:	       (unsigned int)inode->i_mtime.tv_nsec);
fs/ubifs/debug.c:	       (unsigned int)inode->i_ctime.tv_sec,
fs/ubifs/debug.c:	       (unsigned int)inode->i_ctime.tv_nsec);
fs/ubifs/debug.c:	if (!S_ISDIR(inode->i_mode))
fs/ubifs/debug.c:	lowest_dent_key(c, &key, inode->i_ino);
fs/ubifs/debug.c:	if (!S_ISREG(inode->i_mode))
fs/ubifs/debug.c:		ubifs_err("i_ino %lu, i_mode %#x, i_size %lld", inode->i_ino,
fs/ubifs/debug.c:			  inode->i_mode, i_size_read(inode));
fs/ubifs/debug.c:		fscki->nlink = inode->i_nlink;
fs/ubifs/debug.c:		fscki->size = inode->i_size;
fs/ubifs/debug.c:		fscki->mode = inode->i_mode;
fs/ubifs/debug.c:	file->private_data = inode->i_private;
fs/ubifs/recovery.c:				if (inode->i_size < e->d_size) {
fs/ubifs/recovery.c:						  inode->i_size, e->d_size);
fs/ubifs/recovery.c:					inode->i_size = e->d_size;
fs/ubifs/file.c:	struct ubifs_info *c = inode->i_sb->s_fs_info;
fs/ubifs/file.c:	data_key_init(c, &key, inode->i_ino, block);
fs/ubifs/file.c:		  block, inode->i_ino);
fs/ubifs/file.c:		inode->i_ino, page->index, i_size, page->flags);
fs/ubifs/file.c:			  page->index, inode->i_ino, err);
fs/ubifs/file.c:	struct ubifs_info *c = inode->i_sb->s_fs_info;
fs/ubifs/file.c:	int uninitialized_var(err), appending = !!(pos + len > inode->i_size);
fs/ubifs/file.c:		inode->i_ino, pos, len, inode->i_size);
fs/ubifs/file.c:	struct ubifs_info *c = inode->i_sb->s_fs_info;
fs/ubifs/file.c:	int uninitialized_var(err), appending = !!(pos + len > inode->i_size);
fs/ubifs/file.c:	ubifs_assert(ubifs_inode(inode)->ui_size == inode->i_size);
fs/ubifs/file.c:	struct ubifs_info *c = inode->i_sb->s_fs_info;
fs/ubifs/file.c:	int appending = !!(end_pos > inode->i_size);
fs/ubifs/file.c:		inode->i_ino, pos, page->index, len, copied, inode->i_size);
fs/ubifs/file.c:		inode->i_ino, page->index, i_size, page->flags);
fs/ubifs/file.c:		  page_block, inode->i_ino);
fs/ubifs/file.c:	struct ubifs_info *c = inode->i_sb->s_fs_info;
fs/ubifs/file.c:	data_key_init(c, &bu->key, inode->i_ino,
fs/ubifs/file.c:	struct ubifs_info *c = inode->i_sb->s_fs_info;
fs/ubifs/file.c:		data_key_init(c, &key, inode->i_ino, block);
fs/ubifs/file.c:			  page->index, inode->i_ino, err);
fs/ubifs/file.c: * we have to call 'truncate_setsize()', which first changes @inode->i_size,
fs/ubifs/file.c: * This means that @inode->i_size is changed while @ui_mutex is unlocked.
fs/ubifs/file.c: * inode size. How do we do this if @inode->i_size may became smaller while we
fs/ubifs/file.c: * @ui->ui_isize "shadow" field which UBIFS uses instead of @inode->i_size
fs/ubifs/file.c:		inode->i_ino, page->index, page->flags);
fs/ubifs/file.c:			err = inode->i_sb->s_op->write_inode(inode, NULL);
fs/ubifs/file.c:		err = inode->i_sb->s_op->write_inode(inode, NULL);
fs/ubifs/file.c:		inode->i_uid = attr->ia_uid;
fs/ubifs/file.c:		inode->i_gid = attr->ia_gid;
fs/ubifs/file.c:		inode->i_atime = timespec_trunc(attr->ia_atime,
fs/ubifs/file.c:						inode->i_sb->s_time_gran);
fs/ubifs/file.c:		inode->i_mtime = timespec_trunc(attr->ia_mtime,
fs/ubifs/file.c:						inode->i_sb->s_time_gran);
fs/ubifs/file.c:		inode->i_ctime = timespec_trunc(attr->ia_ctime,
fs/ubifs/file.c:						inode->i_sb->s_time_gran);
fs/ubifs/file.c:		if (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))
fs/ubifs/file.c:		inode->i_mode = mode;
fs/ubifs/file.c:	loff_t old_size = inode->i_size, new_size = attr->ia_size;
fs/ubifs/file.c:	dbg_gen("ino %lu, size %lld -> %lld", inode->i_ino, old_size, new_size);
fs/ubifs/file.c:		page = find_lock_page(inode->i_mapping, index);
fs/ubifs/file.c:	ui->ui_size = inode->i_size;
fs/ubifs/file.c:	inode->i_mtime = inode->i_ctime = ubifs_current_time(inode);
fs/ubifs/file.c:		dbg_gen("size %lld -> %lld", inode->i_size, new_size);
fs/ubifs/file.c:		inode->i_mtime = inode->i_ctime = ubifs_current_time(inode);
fs/ubifs/file.c:		ui->ui_size = inode->i_size;
fs/ubifs/file.c:		err = inode->i_sb->s_op->write_inode(inode, NULL);
fs/ubifs/file.c:	struct ubifs_info *c = inode->i_sb->s_fs_info;
fs/ubifs/file.c:		inode->i_ino, inode->i_mode, attr->ia_valid);
fs/ubifs/file.c:	if ((attr->ia_valid & ATTR_SIZE) && attr->ia_size < inode->i_size)
fs/ubifs/file.c:	struct ubifs_info *c = inode->i_sb->s_fs_info;
fs/ubifs/file.c:	struct ubifs_info *c = inode->i_sb->s_fs_info;
fs/ubifs/file.c:	dbg_gen("syncing inode %lu", inode->i_ino);
fs/ubifs/file.c:	err = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/ubifs/file.c:	mutex_lock(&inode->i_mutex);
fs/ubifs/file.c:	if (!datasync || (inode->i_state & I_DIRTY_DATASYNC)) {
fs/ubifs/file.c:		err = inode->i_sb->s_op->write_inode(inode, NULL);
fs/ubifs/file.c:	mutex_unlock(&inode->i_mutex);
fs/ubifs/file.c:	if (!timespec_equal(&inode->i_mtime, now) ||
fs/ubifs/file.c:	    !timespec_equal(&inode->i_ctime, now))
fs/ubifs/file.c:		inode->i_mtime = inode->i_ctime = ubifs_current_time(inode);
fs/ubifs/file.c:	struct ubifs_info *c = inode->i_sb->s_fs_info;
fs/ubifs/file.c:	struct ubifs_info *c = inode->i_sb->s_fs_info;
fs/ubifs/file.c:	dbg_gen("ino %lu, pg %lu, i_size %lld",	inode->i_ino, page->index,
fs/ubifs/file.c:				   inode->i_ino);
fs/ubifs/file.c:	if (unlikely(page->mapping != inode->i_mapping ||
fs/ubifs/file.c:		inode->i_mtime = inode->i_ctime = ubifs_current_time(inode);
fs/ubifs/journal.c:	int data_len = 0, last_reference = !inode->i_nlink;
fs/ubifs/journal.c:	ino_key_init_flash(c, &ino->key, inode->i_ino);
fs/ubifs/journal.c:	ino->atime_sec  = cpu_to_le64(inode->i_atime.tv_sec);
fs/ubifs/journal.c:	ino->atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);
fs/ubifs/journal.c:	ino->ctime_sec  = cpu_to_le64(inode->i_ctime.tv_sec);
fs/ubifs/journal.c:	ino->ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);
fs/ubifs/journal.c:	ino->mtime_sec  = cpu_to_le64(inode->i_mtime.tv_sec);
fs/ubifs/journal.c:	ino->mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);
fs/ubifs/journal.c:	ino->mode  = cpu_to_le32(inode->i_mode);
fs/ubifs/journal.c:	ino->nlink = cpu_to_le32(inode->i_nlink);
fs/ubifs/journal.c:	int last_reference = !!(deletion && inode->i_nlink == 0);
fs/ubifs/journal.c:		inode->i_ino, nm->len, nm->name, ui->data_len, dir->i_ino);
fs/ubifs/journal.c:	dent->inum = deletion ? 0 : cpu_to_le64(inode->i_ino);
fs/ubifs/journal.c:	dent->type = get_dent_type(inode->i_mode);
fs/ubifs/journal.c:		err = ubifs_add_orphan(c, inode->i_ino);
fs/ubifs/journal.c:		ubifs_wbuf_add_ino_nolock(wbuf, inode->i_ino);
fs/ubifs/journal.c:	ino_key_init(c, &ino_key, inode->i_ino);
fs/ubifs/journal.c:		ubifs_delete_orphan(c, inode->i_ino);
fs/ubifs/journal.c:	int sync = 0, len = UBIFS_INO_NODE_SZ, last_reference = !inode->i_nlink;
fs/ubifs/journal.c:	dbg_jnl("ino %lu, nlink %u", inode->i_ino, inode->i_nlink);
fs/ubifs/journal.c:					  inode->i_ino);
fs/ubifs/journal.c:		err = ubifs_tnc_remove_ino(c, inode->i_ino);
fs/ubifs/journal.c:		ubifs_delete_orphan(c, inode->i_ino);
fs/ubifs/journal.c:		ino_key_init(c, &key, inode->i_ino);
fs/ubifs/journal.c:	ubifs_assert(inode->i_nlink == 0);
fs/ubifs/journal.c:	err = ubifs_tnc_remove_ino(c, inode->i_ino);
fs/ubifs/journal.c:		ubifs_delete_orphan(c, inode->i_ino);
fs/ubifs/journal.c:	int last_reference = !!(new_inode && new_inode->i_nlink == 0);
fs/ubifs/journal.c:	dent->inum = cpu_to_le64(old_inode->i_ino);
fs/ubifs/journal.c:	dent->type = get_dent_type(old_inode->i_mode);
fs/ubifs/journal.c:		err = ubifs_add_orphan(c, new_inode->i_ino);
fs/ubifs/journal.c:						  new_inode->i_ino);
fs/ubifs/journal.c:		ino_key_init(c, &key, new_inode->i_ino);
fs/ubifs/journal.c:		ubifs_delete_orphan(c, new_inode->i_ino);
fs/ubifs/journal.c:	ino_t inum = inode->i_ino;
fs/ubifs/journal.c:	ubifs_assert(S_ISREG(inode->i_mode));
fs/ubifs/journal.c:		host->i_ino, inode->i_ino, nm->name,
fs/ubifs/journal.c:	ubifs_assert(inode->i_nlink == 0);
fs/ubifs/journal.c:	xent->type = get_dent_type(inode->i_mode);
fs/ubifs/journal.c:	lowest_ino_key(c, &key1, inode->i_ino);
fs/ubifs/journal.c:	highest_ino_key(c, &key2, inode->i_ino);
fs/ubifs/journal.c:	dbg_jnl("ino %lu, ino %lu", host->i_ino, inode->i_ino);
fs/ubifs/journal.c:	ubifs_assert(inode->i_nlink > 0);
fs/ubifs/journal.c:		ubifs_wbuf_add_ino_nolock(wbuf, inode->i_ino);
fs/ubifs/journal.c:	ino_key_init(c, &key, inode->i_ino);
fs/ubifs/io.c:		if (!wbuf_has_ino(wbuf, inode->i_ino))
fs/ubifs/io.c:		if (wbuf_has_ino(wbuf, inode->i_ino))
fs/ubifs/ioctl.c:	inode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_DIRSYNC);
fs/ubifs/ioctl.c:		inode->i_flags |= S_SYNC;
fs/ubifs/ioctl.c:		inode->i_flags |= S_APPEND;
fs/ubifs/ioctl.c:		inode->i_flags |= S_IMMUTABLE;
fs/ubifs/ioctl.c:		inode->i_flags |= S_DIRSYNC;
fs/ubifs/ioctl.c:	struct ubifs_info *c = inode->i_sb->s_fs_info;
fs/ubifs/ioctl.c:	inode->i_ctime = ubifs_current_time(inode);
fs/ubifs/ioctl.c:	ubifs_err("can't modify inode %lu attributes", inode->i_ino);
fs/ubifs/ioctl.c:		dbg_gen("get flags: %#x, i_flags %#x", flags, inode->i_flags);
fs/ubifs/ioctl.c:		if (!S_ISDIR(inode->i_mode))
fs/ubifs/ioctl.c:		dbg_gen("set flags: %#x, i_flags %#x", flags, inode->i_flags);
fs/ubifs/ubifs.h: * The @ui_size is a "shadow" variable for @inode->i_size and UBIFS uses
fs/ubifs/ubifs.h: * @ui_size instead of @inode->i_size. The reason for this is that UBIFS cannot
fs/ubifs/ubifs.h: * make sure @inode->i_size is always changed under @ui_mutex, because it
fs/ubifs/misc.h:	return (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?
fs/ubifs/misc.h:		current_fs_time(inode->i_sb) : CURRENT_TIME_SEC;
fs/ubifs/xattr.c:	inode->i_mapping->a_ops = &empty_aops;
fs/ubifs/xattr.c:	inode->i_op = &empty_iops;
fs/ubifs/xattr.c:	inode->i_fop = &empty_fops;
fs/ubifs/xattr.c:	inode->i_flags |= S_SYNC | S_NOATIME | S_NOCMTIME | S_NOQUOTA;
fs/ubifs/xattr.c:	inode->i_size = ui->ui_size = size;
fs/ubifs/xattr.c:	ubifs_assert(ui->data_len == inode->i_size);
fs/ubifs/xattr.c:	inode->i_size = ui->ui_size = size;
fs/ubifs/xattr.c:	ubifs_assert(inode->i_size == ui->data_len);
fs/ubifs/xattr.c:	ubifs_assert(ui->data_len == inode->i_size);
fs/ubifs/xattr.c:	ubifs_assert(inode->i_nlink == 1);
fs/compat_ioctl.c:		if (S_ISREG(f.file->f_path.dentry->d_inode->i_mode))
fs/sysfs/inode.c:	inode->i_mode = mode;
fs/sysfs/inode.c:	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/sysfs/inode.c:	inode->i_uid = iattr->ia_uid;
fs/sysfs/inode.c:	inode->i_gid = iattr->ia_gid;
fs/sysfs/inode.c:	inode->i_atime = iattr->ia_atime;
fs/sysfs/inode.c:	inode->i_mtime = iattr->ia_mtime;
fs/sysfs/inode.c:	inode->i_ctime = iattr->ia_ctime;
fs/sysfs/inode.c:	inode->i_mode = sd->s_mode;
fs/sysfs/inode.c:	inode->i_private = sysfs_get(sd);
fs/sysfs/inode.c:	inode->i_mapping->a_ops = &sysfs_aops;
fs/sysfs/inode.c:	inode->i_mapping->backing_dev_info = &sysfs_backing_dev_info;
fs/sysfs/inode.c:	inode->i_op = &sysfs_inode_operations;
fs/sysfs/inode.c:		inode->i_op = &sysfs_dir_inode_operations;
fs/sysfs/inode.c:		inode->i_fop = &sysfs_dir_operations;
fs/sysfs/inode.c:		inode->i_size = PAGE_SIZE;
fs/sysfs/inode.c:		inode->i_fop = &sysfs_file_operations;
fs/sysfs/inode.c:		inode->i_size = bin_attr->size;
fs/sysfs/inode.c:		inode->i_fop = &bin_fops;
fs/sysfs/inode.c:		inode->i_op = &sysfs_symlink_inode_operations;
fs/sysfs/inode.c:	if (inode && (inode->i_state & I_NEW))
fs/sysfs/inode.c:	struct sysfs_dirent *sd  = inode->i_private;
fs/sysfs/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/sysfs/inode.c:	sd = inode->i_private;
fs/sysfs/dir.c:	mutex_lock(&inode->i_mutex);
fs/sysfs/dir.c:	mutex_unlock(&inode->i_mutex);
fs/sysfs/file.c:		if (!(inode->i_mode & S_IWUGO) || !ops->store)
fs/sysfs/file.c:		if (!(inode->i_mode & S_IRUGO) || !ops->show)
fs/sysfs/bin.c:	int size = file->f_path.dentry->d_inode->i_size;
fs/sysfs/bin.c:	int size = file->f_path.dentry->d_inode->i_size;
fs/sysfs/bin.c:		unmap_mapping_range(inode->i_mapping, 0, 0, 1);
fs/openpromfs/inode.c:		inode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;
fs/openpromfs/inode.c:		inode->i_op = &openprom_inode_operations;
fs/openpromfs/inode.c:		inode->i_fop = &openprom_operations;
fs/openpromfs/inode.c:			inode->i_mode = S_IFREG | S_IRUSR | S_IWUSR;
fs/openpromfs/inode.c:			inode->i_mode = S_IFREG | S_IRUGO;
fs/openpromfs/inode.c:		inode->i_fop = &openpromfs_prop_ops;
fs/openpromfs/inode.c:		inode->i_size = ent_oi->u.prop->length;
fs/openpromfs/inode.c:	ino = inode->i_ino;
fs/openpromfs/inode.c:	call_rcu(&inode->i_rcu, openprom_i_callback);
fs/openpromfs/inode.c:	if (inode->i_state & I_NEW) {
fs/openpromfs/inode.c:		inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
fs/openpromfs/inode.c:		if (inode->i_ino == OPENPROM_ROOT_INO) {
fs/openpromfs/inode.c:			inode->i_op = &openprom_inode_operations;
fs/openpromfs/inode.c:			inode->i_fop = &openprom_operations;
fs/openpromfs/inode.c:			inode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;
fs/romfs/super.c:		ret = romfs_dev_read(inode->i_sb, pos, buf, fillsize);
fs/romfs/super.c:	inode->i_metasize = (ROMFH_SIZE + nlen + 1 + ROMFH_PAD) & ROMFH_MASK;
fs/romfs/super.c:	inode->i_dataoffset = pos + inode->i_metasize;
fs/romfs/super.c:	return inode ? &inode->vfs_inode : NULL;
fs/romfs/super.c:	call_rcu(&inode->i_rcu, romfs_i_callback);
fs/romfs/super.c:	inode_init_once(&inode->vfs_inode);
fs/romfs/mmap-nommu.c:	struct mtd_info *mtd = inode->i_sb->s_mtd;
fs/logfs/inode.c:	switch (inode->i_mode & S_IFMT) {
fs/logfs/inode.c:		inode->i_op = &logfs_dir_iops;
fs/logfs/inode.c:		inode->i_fop = &logfs_dir_fops;
fs/logfs/inode.c:		inode->i_mapping->a_ops = &logfs_reg_aops;
fs/logfs/inode.c:		inode->i_op = &logfs_reg_iops;
fs/logfs/inode.c:		inode->i_fop = &logfs_reg_fops;
fs/logfs/inode.c:		inode->i_mapping->a_ops = &logfs_reg_aops;
fs/logfs/inode.c:		inode->i_op = &logfs_symlink_iops;
fs/logfs/inode.c:		inode->i_mapping->a_ops = &logfs_reg_aops;
fs/logfs/inode.c:		init_special_inode(inode, inode->i_mode, inode->i_rdev);
fs/logfs/inode.c:	if (!(inode->i_state & I_NEW))
fs/logfs/inode.c:	if (err || inode->i_nlink == 0) {
fs/logfs/inode.c:		/* inode->i_nlink == 0 can be true when called from
fs/logfs/inode.c:	call_rcu(&inode->i_rcu, logfs_i_callback);
fs/logfs/inode.c:	call_rcu(&inode->i_rcu, logfs_i_callback);
fs/logfs/inode.c:	if (inode->i_ino < LOGFS_RESERVED_INOS) {
fs/logfs/inode.c:	if (inode->i_ino == LOGFS_INO_MASTER)
fs/logfs/inode.c:	if (inode->i_ino == LOGFS_INO_SEGFILE)
fs/logfs/inode.c:	inode->i_size	= 0;
fs/logfs/inode.c:	inode->i_blocks	= 0;
fs/logfs/inode.c:	inode->i_ctime	= CURRENT_TIME;
fs/logfs/inode.c:	inode->i_mtime	= CURRENT_TIME;
fs/logfs/inode.c:	inode->i_mode = S_IFREG;
fs/logfs/inode.c:	inode->i_ino = ino;
fs/logfs/inode.c:	inode->i_data.a_ops = &logfs_reg_aops;
fs/logfs/inode.c:	mapping_set_gfp_mask(&inode->i_data, GFP_NOFS);
fs/logfs/inode.c:	LOGFS_BUG_ON(ret, inode->i_sb);
fs/logfs/inode.c:/* called with inode->i_lock held */
fs/logfs/inode.c:	struct logfs_super *super = logfs_super(inode->i_sb);
fs/logfs/inode.c:	inode->i_ino = ino;
fs/logfs/inode.c:	inode->i_generation = super->s_generation;
fs/logfs/inode.c:	inode->i_mode = mode;
fs/logfs/dev_bdev.c:	struct address_space *mapping = super->s_mapping_inode->i_mapping;
fs/logfs/dev_bdev.c:	struct address_space *mapping = super->s_mapping_inode->i_mapping;
fs/logfs/dev_bdev.c:	struct address_space *mapping = super->s_mapping_inode->i_mapping;
fs/logfs/dev_bdev.c:	u64 pos = (super->s_bdev->bd_inode->i_size & ~0xfffULL) - 0x1000;
fs/logfs/dev_mtd.c:	struct address_space *mapping = super->s_mapping_inode->i_mapping;
fs/logfs/dev_mtd.c:	struct address_space *mapping = super->s_mapping_inode->i_mapping;
fs/logfs/dev_mtd.c:	struct address_space *mapping = super->s_mapping_inode->i_mapping;
fs/logfs/dev_mtd.c:	struct address_space *mapping = super->s_mapping_inode->i_mapping;
fs/logfs/dir.c:	loff_t pos = bix << inode->i_sb->s_blocksize_bits;
fs/logfs/dir.c:	LOGFS_BUG_ON(ret, inode->i_sb);
fs/logfs/dir.c:	ta->ino = inode->i_ino;
fs/logfs/dir.c:	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
fs/logfs/dir.c:		if (filldir(buf, ".", 1, 1, inode->i_ino, DT_DIR) < 0)
fs/logfs/dir.c:		dd->ino = cpu_to_be64(inode->i_ino);
fs/logfs/dir.c:	ta->ino = inode->i_ino;
fs/logfs/dir.c:	inode->i_op = &logfs_dir_iops;
fs/logfs/dir.c:	inode->i_fop = &logfs_dir_fops;
fs/logfs/dir.c:	inode->i_op = &logfs_reg_iops;
fs/logfs/dir.c:	inode->i_fop = &logfs_reg_fops;
fs/logfs/dir.c:	inode->i_mapping->a_ops = &logfs_reg_aops;
fs/logfs/dir.c:	inode->i_op = &logfs_symlink_iops;
fs/logfs/dir.c:	inode->i_mapping->a_ops = &logfs_reg_aops;
fs/logfs/dir.c:	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
fs/logfs/dir.c:	dd->ino = cpu_to_be64(inode->i_ino);
fs/logfs/dir.c:	int isdir = S_ISDIR(old_inode->i_mode);
fs/logfs/dir.c:	BUG_ON(isdir != S_ISDIR(new_inode->i_mode));
fs/logfs/dir.c:	ta->ino = new_inode->i_ino;
fs/logfs/readwrite.c:	inode->i_mode	= be16_to_cpu(di->di_mode);
fs/logfs/readwrite.c:	inode->i_size	= be64_to_cpu(di->di_size);
fs/logfs/readwrite.c:	inode->i_atime	= be64_to_timespec(di->di_atime);
fs/logfs/readwrite.c:	inode->i_ctime	= be64_to_timespec(di->di_ctime);
fs/logfs/readwrite.c:	inode->i_mtime	= be64_to_timespec(di->di_mtime);
fs/logfs/readwrite.c:	inode->i_generation = be32_to_cpu(di->di_generation);
fs/logfs/readwrite.c:	switch (inode->i_mode & S_IFMT) {
fs/logfs/readwrite.c:		inode->i_rdev = be64_to_cpu(di->di_data[0]);
fs/logfs/readwrite.c:	di->di_mode	= cpu_to_be16(inode->i_mode);
fs/logfs/readwrite.c:	di->di_atime	= timespec_to_be64(inode->i_atime);
fs/logfs/readwrite.c:	di->di_ctime	= timespec_to_be64(inode->i_ctime);
fs/logfs/readwrite.c:	di->di_mtime	= timespec_to_be64(inode->i_mtime);
fs/logfs/readwrite.c:	di->di_refcount	= cpu_to_be32(inode->i_nlink);
fs/logfs/readwrite.c:	di->di_generation = cpu_to_be32(inode->i_generation);
fs/logfs/readwrite.c:	switch (inode->i_mode & S_IFMT) {
fs/logfs/readwrite.c:		di->di_data[0] = cpu_to_be64(inode->i_rdev);
fs/logfs/readwrite.c:	struct super_block *sb = inode->i_sb;
fs/logfs/readwrite.c:	inode->i_blocks = ULONG_MAX;
fs/logfs/readwrite.c:		inode->i_blocks = ALIGN(li->li_used_bytes, 512) >> 9;
fs/logfs/readwrite.c:	return find_or_create_page(inode->i_mapping,
fs/logfs/readwrite.c:	struct address_space *mapping = inode->i_mapping;
fs/logfs/readwrite.c:	if (inode->i_ino == LOGFS_INO_MASTER)
fs/logfs/readwrite.c:		logfs_write_anchor(inode->i_sb);
fs/logfs/readwrite.c:	val =	(u64)inode->i_mode << 48 |
fs/logfs/readwrite.c:		bix = inode->i_ino;
fs/logfs/readwrite.c:	block = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);
fs/logfs/readwrite.c:	block = __alloc_block(inode->i_sb, inode->i_ino, bix, level);
fs/logfs/readwrite.c:	struct super_block *sb = inode->i_sb;
fs/logfs/readwrite.c:	if ((inode->i_nlink == 0) && atomic_read(&inode->i_count) == 1)
fs/logfs/readwrite.c:	struct logfs_super *super = logfs_super(inode->i_sb);
fs/logfs/readwrite.c:	struct logfs_super *super = logfs_super(inode->i_sb);
fs/logfs/readwrite.c:	logfs_get_wblocks(inode->i_sb, page, WF_LOCK);
fs/logfs/readwrite.c:	logfs_put_wblocks(inode->i_sb, page, WF_LOCK);
fs/logfs/readwrite.c:	struct logfs_super *super = logfs_super(inode->i_sb);
fs/logfs/readwrite.c:	if (inode->i_ino != LOGFS_INO_MASTER) {
fs/logfs/readwrite.c:	struct logfs_super *super = logfs_super(inode->i_sb);
fs/logfs/readwrite.c:	shadow->ino = inode->i_ino;
fs/logfs/readwrite.c:	shadow->gc_level = expand_level(inode->i_ino, level);
fs/logfs/readwrite.c:	struct logfs_super *super = logfs_super(inode->i_sb);
fs/logfs/readwrite.c:	struct logfs_super *super = logfs_super(inode->i_sb);
fs/logfs/readwrite.c:		block->ops->free_block(inode->i_sb, block);
fs/logfs/readwrite.c:	if (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {
fs/logfs/readwrite.c: * change inode->i_size and li->li_used_bytes.  Which is done by setting
fs/logfs/readwrite.c:	logfs_set_alias(inode->i_sb, li->li_block, INODE_USED_OFS);
fs/logfs/readwrite.c:	logfs_set_alias(inode->i_sb, li->li_block, INODE_SIZE_OFS);
fs/logfs/readwrite.c:	logfs_set_alias(inode->i_sb, li->li_block,
fs/logfs/readwrite.c:		logfs_set_alias(inode->i_sb, logfs_block(ipage), child_no);
fs/logfs/readwrite.c:		logfs_set_alias(inode->i_sb, li->li_block,
fs/logfs/readwrite.c:		logfs_set_alias(inode->i_sb, li->li_block, INODE_HEIGHT_OFS);
fs/logfs/readwrite.c:	struct logfs_super *super = logfs_super(inode->i_sb);
fs/logfs/readwrite.c:	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
fs/logfs/readwrite.c:	struct super_block *sb = inode->i_sb;
fs/logfs/readwrite.c:	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
fs/logfs/readwrite.c:	struct super_block *sb = inode->i_sb;
fs/logfs/readwrite.c:			if (inode->i_ino == LOGFS_INO_MASTER)
fs/logfs/readwrite.c:				logfs_write_anchor(inode->i_sb);
fs/logfs/readwrite.c:	loff_t pageofs = page->index << inode->i_sb->s_blocksize_bits;
fs/logfs/readwrite.c:		printk("ineffectual truncate (%lx, %lx, %llx)\n", inode->i_ino, ipage->index, size);
fs/logfs/readwrite.c:	struct super_block *sb = inode->i_sb;
fs/logfs/readwrite.c:	struct super_block *sb = inode->i_sb;
fs/logfs/readwrite.c:	u64 ino = inode->i_ino;
fs/logfs/readwrite.c:	page = read_cache_page(master_inode->i_mapping, ino,
fs/logfs/readwrite.c:	struct inode *master_inode = logfs_super(inode->i_sb)->s_master_inode;
fs/logfs/readwrite.c:	BUG_ON(inode->i_ino == LOGFS_INO_MASTER);
fs/logfs/readwrite.c:	page = logfs_get_write_page(master_inode, inode->i_ino, 0);
fs/logfs/readwrite.c:	struct super_block *sb = inode->i_sb;
fs/logfs/readwrite.c:	loff_t size = (inode->i_ino + 1) << inode->i_sb->s_blocksize_bits;
fs/logfs/readwrite.c:	BUG_ON(inode->i_ino == LOGFS_INO_MASTER);
fs/logfs/readwrite.c:	struct super_block *sb = inode->i_sb;
fs/logfs/readwrite.c:	struct super_block *sb = inode->i_sb;
fs/logfs/readwrite.c:	page = logfs_get_write_page(master_inode, inode->i_ino, 0);
fs/logfs/readwrite.c:	struct super_block *sb = inode->i_sb;
fs/logfs/readwrite.c:	if (!inode->i_nlink) {
fs/logfs/readwrite.c:	truncate_inode_pages(&inode->i_data, 0);
fs/logfs/readwrite.c:	BUG_ON(inode->i_state & I_DIRTY && inode->i_nlink);
fs/logfs/readwrite.c:		block->ops->free_block(inode->i_sb, block);
fs/logfs/readwrite.c:	loff_t pos = bix << inode->i_sb->s_blocksize_bits;
fs/logfs/segment.c:	struct address_space *mapping = super->s_mapping_inode->i_mapping;
fs/logfs/segment.c:		if (S_ISDIR(inode->i_mode))
fs/logfs/segment.c:		if (inode->i_ino == LOGFS_INO_MASTER)
fs/logfs/segment.c:	struct super_block *sb = inode->i_sb;
fs/logfs/segment.c:	h.ino	= cpu_to_be64(inode->i_ino);
fs/logfs/segment.c:	struct super_block *sb = inode->i_sb;
fs/logfs/segment.c:	struct super_block *sb = inode->i_sb;
fs/logfs/segment.c:	struct super_block *sb = inode->i_sb;
fs/logfs/segment.c:	block = btree_remove128(head, inode->i_ino, page->index);
fs/logfs/segment.c:	struct super_block *sb = inode->i_sb;
fs/logfs/segment.c:	if (be64_to_cpu(oh.ino) != inode->i_ino
fs/logfs/segment.c:				ofs, inode->i_ino, bix,
fs/logfs/segment.c:			inode->i_ino, bix, level, ofs, err);
fs/logfs/segment.c:	struct super_block *sb = inode->i_sb;
fs/logfs/segment.c:	LOGFS_BUG_ON(be64_to_cpu(h.ino) != inode->i_ino, sb);
fs/logfs/segment.c:	struct address_space *mapping = super->s_mapping_inode->i_mapping;
fs/logfs/segment.c:	mapping = inode->i_mapping;
fs/logfs/file.c:	BUG_ON(PAGE_CACHE_SIZE != inode->i_sb->s_blocksize);
fs/logfs/file.c:	log_file("logfs_writepage(%lx, %lx, %p)\n", inode->i_ino, page->index,
fs/logfs/file.c:		mutex_lock(&inode->i_mutex);
fs/logfs/file.c:		mutex_unlock(&inode->i_mutex);
fs/logfs/file.c:		inode->i_ctime = CURRENT_TIME;
fs/logfs/file.c:	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/logfs/file.c:	mutex_lock(&inode->i_mutex);
fs/logfs/file.c:	mutex_unlock(&inode->i_mutex);
fs/logfs/journal.c:	struct address_space *mapping = super->s_mapping_inode->i_mapping;
fs/logfs/logfs.h:	return (inode->i_mode >> 12) & 15;
fs/exportfs/expfs.c:	spin_lock(&inode->i_lock);
fs/exportfs/expfs.c:	hlist_for_each_entry(dentry, p, &inode->i_dentry, d_alias) {
fs/exportfs/expfs.c:		spin_unlock(&inode->i_lock);
fs/exportfs/expfs.c:		spin_lock(&inode->i_lock);
fs/exportfs/expfs.c:	spin_unlock(&inode->i_lock);
fs/exportfs/expfs.c:			mutex_lock(&pd->d_inode->i_mutex);
fs/exportfs/expfs.c:			mutex_unlock(&pd->d_inode->i_mutex);
fs/exportfs/expfs.c:					__func__, pd->d_inode->i_ino, err);
fs/exportfs/expfs.c:				pd->d_inode->i_ino, ppd->d_inode->i_ino);
fs/exportfs/expfs.c:			mutex_lock(&ppd->d_inode->i_mutex);
fs/exportfs/expfs.c:			mutex_unlock(&ppd->d_inode->i_mutex);
fs/exportfs/expfs.c:	buffer.ino = child->d_inode->i_ino;
fs/exportfs/expfs.c:	fid->i32.ino = inode->i_ino;
fs/exportfs/expfs.c:	fid->i32.gen = inode->i_generation;
fs/exportfs/expfs.c:	const struct export_operations *nop = inode->i_sb->s_export_op;
fs/exportfs/expfs.c:	if (connectable && !S_ISDIR(inode->i_mode)) {
fs/exportfs/expfs.c:	if (S_ISDIR(result->d_inode->i_mode)) {
fs/exportfs/expfs.c:			mutex_lock(&target_dir->d_inode->i_mutex);
fs/exportfs/expfs.c:			mutex_unlock(&target_dir->d_inode->i_mutex);
fs/qnx6/inode.c:			inode->i_ino, (unsigned long)iblock));
fs/qnx6/inode.c:		map_bh(bh, inode->i_sb, phys);
fs/qnx6/inode.c:	struct super_block *s = inode->i_sb;
fs/qnx6/inode.c:		inode->i_size = fs64_to_cpu(sbi, p->size);
fs/qnx6/inode.c:		inode->i_mode = S_IFREG | S_IRUSR; /* probably wrong */
fs/qnx6/inode.c:		inode->i_mapping->a_ops = &qnx6_aops;
fs/qnx6/inode.c:	if (!(inode->i_state & I_NEW))
fs/qnx6/inode.c:	inode->i_mode = 0;
fs/qnx6/inode.c:	inode->i_mode    = fs16_to_cpu(sbi, raw_inode->di_mode);
fs/qnx6/inode.c:	i_uid_write(inode, (uid_t)fs32_to_cpu(sbi, raw_inode->di_uid));
fs/qnx6/inode.c:	i_gid_write(inode, (gid_t)fs32_to_cpu(sbi, raw_inode->di_gid));
fs/qnx6/inode.c:	inode->i_size    = fs64_to_cpu(sbi, raw_inode->di_size);
fs/qnx6/inode.c:	inode->i_mtime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_mtime);
fs/qnx6/inode.c:	inode->i_mtime.tv_nsec = 0;
fs/qnx6/inode.c:	inode->i_atime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_atime);
fs/qnx6/inode.c:	inode->i_atime.tv_nsec = 0;
fs/qnx6/inode.c:	inode->i_ctime.tv_sec   = fs32_to_cpu(sbi, raw_inode->di_ctime);
fs/qnx6/inode.c:	inode->i_ctime.tv_nsec = 0;
fs/qnx6/inode.c:	inode->i_blocks = (inode->i_size + 511) >> 9;
fs/qnx6/inode.c:	memcpy(&ei->di_block_ptr, &raw_inode->di_block_ptr,
fs/qnx6/inode.c:				sizeof(raw_inode->di_block_ptr));
fs/qnx6/inode.c:	ei->di_filelevels = raw_inode->di_filelevels;
fs/qnx6/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/qnx6/inode.c:		inode->i_fop = &generic_ro_fops;
fs/qnx6/inode.c:		inode->i_mapping->a_ops = &qnx6_aops;
fs/qnx6/inode.c:	} else if (S_ISDIR(inode->i_mode)) {
fs/qnx6/inode.c:		inode->i_op = &qnx6_dir_inode_operations;
fs/qnx6/inode.c:		inode->i_fop = &qnx6_dir_operations;
fs/qnx6/inode.c:		inode->i_mapping->a_ops = &qnx6_aops;
fs/qnx6/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/qnx6/inode.c:		inode->i_op = &page_symlink_inode_operations;
fs/qnx6/inode.c:		inode->i_mapping->a_ops = &qnx6_aops;
fs/qnx6/inode.c:		init_special_inode(inode, inode->i_mode, 0);
fs/qnx6/inode.c:	call_rcu(&inode->i_rcu, qnx6_i_callback);
fs/qnx6/dir.c:	return (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;
fs/qnx6/dir.c:	unsigned long last_byte = inode->i_size;
fs/qnx6/dir.c:	struct super_block *s = inode->i_sb;
fs/qnx6/dir.c:	struct super_block *s = inode->i_sb;
fs/qnx6/dir.c:	if (filp->f_pos >= inode->i_size)
fs/btrfs/inode.c:#include "inode-map.h"
fs/btrfs/inode.c:		page = find_get_page(inode->i_mapping,
fs/btrfs/inode.c:	BTRFS_I(inode)->disk_i_size = inode->i_size;
fs/btrfs/inode.c:					   inode->i_mapping, start,
fs/btrfs/inode.c:	if (atomic_add_unless(&inode->i_count, -1, 1))
fs/btrfs/inode.c:		if (inode->i_nlink) {
fs/btrfs/inode.c:			if (!S_ISREG(inode->i_mode)) {
fs/btrfs/inode.c:	inode->i_mode = btrfs_inode_mode(leaf, inode_item);
fs/btrfs/inode.c:	inode->i_atime.tv_sec = btrfs_timespec_sec(leaf, tspec);
fs/btrfs/inode.c:	inode->i_atime.tv_nsec = btrfs_timespec_nsec(leaf, tspec);
fs/btrfs/inode.c:	inode->i_mtime.tv_sec = btrfs_timespec_sec(leaf, tspec);
fs/btrfs/inode.c:	inode->i_mtime.tv_nsec = btrfs_timespec_nsec(leaf, tspec);
fs/btrfs/inode.c:	inode->i_ctime.tv_sec = btrfs_timespec_sec(leaf, tspec);
fs/btrfs/inode.c:	inode->i_ctime.tv_nsec = btrfs_timespec_nsec(leaf, tspec);
fs/btrfs/inode.c:	inode->i_version = btrfs_inode_sequence(leaf, inode_item);
fs/btrfs/inode.c:	inode->i_generation = BTRFS_I(inode)->generation;
fs/btrfs/inode.c:	inode->i_rdev = 0;
fs/btrfs/inode.c:	switch (inode->i_mode & S_IFMT) {
fs/btrfs/inode.c:		inode->i_mapping->a_ops = &btrfs_aops;
fs/btrfs/inode.c:		inode->i_mapping->backing_dev_info = &root->fs_info->bdi;
fs/btrfs/inode.c:		inode->i_fop = &btrfs_file_operations;
fs/btrfs/inode.c:		inode->i_op = &btrfs_file_inode_operations;
fs/btrfs/inode.c:		inode->i_fop = &btrfs_dir_file_operations;
fs/btrfs/inode.c:			inode->i_op = &btrfs_dir_ro_inode_operations;
fs/btrfs/inode.c:			inode->i_op = &btrfs_dir_inode_operations;
fs/btrfs/inode.c:		inode->i_op = &btrfs_symlink_inode_operations;
fs/btrfs/inode.c:		inode->i_mapping->a_ops = &btrfs_symlink_aops;
fs/btrfs/inode.c:		inode->i_mapping->backing_dev_info = &root->fs_info->bdi;
fs/btrfs/inode.c:		inode->i_op = &btrfs_special_inode_operations;
fs/btrfs/inode.c:		init_special_inode(inode, inode->i_mode, rdev);
fs/btrfs/inode.c:	btrfs_set_inode_mode(leaf, item, inode->i_mode);
fs/btrfs/inode.c:	btrfs_set_inode_nlink(leaf, item, inode->i_nlink);
fs/btrfs/inode.c:			       inode->i_atime.tv_sec);
fs/btrfs/inode.c:				inode->i_atime.tv_nsec);
fs/btrfs/inode.c:			       inode->i_mtime.tv_sec);
fs/btrfs/inode.c:				inode->i_mtime.tv_nsec);
fs/btrfs/inode.c:			       inode->i_ctime.tv_sec);
fs/btrfs/inode.c:				inode->i_ctime.tv_nsec);
fs/btrfs/inode.c:	btrfs_set_inode_sequence(leaf, item, inode->i_version);
fs/btrfs/inode.c:	btrfs_set_inode_rdev(leaf, item, inode->i_rdev);
fs/btrfs/inode.c:	inode->i_ctime = dir->i_mtime = dir->i_ctime = CURRENT_TIME;
fs/btrfs/inode.c:	if (S_ISDIR(inode->i_mode) && atomic_read(&inode->i_count) > 1)
fs/btrfs/inode.c:	if (atomic_read(&inode->i_count) > 2)
fs/btrfs/inode.c:	if (ret == 0 && S_ISREG(inode->i_mode)) {
fs/btrfs/inode.c:	if (inode->i_nlink == 0) {
fs/btrfs/inode.c:	if (inode->i_size > BTRFS_EMPTY_DIR_SIZE)
fs/btrfs/inode.c:	struct address_space *mapping = inode->i_mapping;
fs/btrfs/inode.c:		inode->i_ctime = inode->i_mtime = current_fs_time(inode->i_sb);
fs/btrfs/inode.c:		if (ret && inode->i_nlink)
fs/btrfs/inode.c:	if (S_ISREG(inode->i_mode) && (attr->ia_valid & ATTR_SIZE)) {
fs/btrfs/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/btrfs/inode.c:	if (inode->i_nlink && (btrfs_root_refs(&root->root_item) != 0 ||
fs/btrfs/inode.c:	if (inode->i_nlink > 0) {
fs/btrfs/inode.c:			if (atomic_read(&inode->i_count) > 1)
fs/btrfs/inode.c:	inode->i_ino = args->ino;
fs/btrfs/inode.c:	if (inode->i_state & I_NEW) {
fs/btrfs/inode.c:	inode->i_ino = BTRFS_EMPTY_SUBVOL_DIR_OBJECTID;
fs/btrfs/inode.c:	inode->i_op = &btrfs_dir_ro_inode_operations;
fs/btrfs/inode.c:	inode->i_fop = &simple_dir_operations;
fs/btrfs/inode.c:	inode->i_mode = S_IFDIR | S_IRUGO | S_IWUSR | S_IXUGO;
fs/btrfs/inode.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
fs/btrfs/inode.c:		if (!(inode->i_sb->s_flags & MS_RDONLY))
fs/btrfs/inode.c:		inode->i_ctime = *now;
fs/btrfs/inode.c:		inode->i_mtime = *now;
fs/btrfs/inode.c:		inode->i_atime = *now;
fs/btrfs/inode.c:	inode->i_ino = objectid;
fs/btrfs/inode.c:	inode->i_generation = BTRFS_I(inode)->generation;
fs/btrfs/inode.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
fs/btrfs/inode.c:	return btrfs_type_by_mode[(inode->i_mode & S_IFMT) >> S_SHIFT];
fs/btrfs/inode.c:	btrfs_i_size_write(parent_inode, parent_inode->i_size +
fs/btrfs/inode.c:	parent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;
fs/btrfs/inode.c:	inode->i_op = &btrfs_special_inode_operations;
fs/btrfs/inode.c:		init_special_inode(inode, inode->i_mode, rdev);
fs/btrfs/inode.c:	inode->i_fop = &btrfs_file_operations;
fs/btrfs/inode.c:	inode->i_op = &btrfs_file_inode_operations;
fs/btrfs/inode.c:	inode->i_mapping->a_ops = &btrfs_aops;
fs/btrfs/inode.c:	inode->i_mapping->backing_dev_info = &root->fs_info->bdi;
fs/btrfs/inode.c:	if (inode->i_nlink >= BTRFS_LINK_MAX)
fs/btrfs/inode.c:	inode->i_ctime = CURRENT_TIME;
fs/btrfs/inode.c:	inode->i_op = &btrfs_dir_inode_operations;
fs/btrfs/inode.c:	inode->i_fop = &btrfs_dir_file_operations;
fs/btrfs/inode.c:			ret = filemap_write_and_wait_range(inode->i_mapping,
fs/btrfs/inode.c:			ret = invalidate_inode_pages2_range(inode->i_mapping,
fs/btrfs/inode.c:	u64 start = iblock << inode->i_blkbits;
fs/btrfs/inode.c:		inode->i_blkbits;
fs/btrfs/inode.c:	sb_start_pagefault(inode->i_sb);
fs/btrfs/inode.c:	if ((page->mapping != inode->i_mapping) ||
fs/btrfs/inode.c:		sb_end_pagefault(inode->i_sb);
fs/btrfs/inode.c:	sb_end_pagefault(inode->i_sb);
fs/btrfs/inode.c:	ret = btrfs_truncate_page(inode, inode->i_size, 0, 0);
fs/btrfs/inode.c:	btrfs_wait_ordered_range(inode, inode->i_size & (~mask), (u64)-1);
fs/btrfs/inode.c:	btrfs_ordered_update_i_size(inode, inode->i_size, NULL);
fs/btrfs/inode.c:	if (inode->i_size == 0 && test_bit(BTRFS_INODE_ORDERED_DATA_CLOSE,
fs/btrfs/inode.c:						 inode->i_size,
fs/btrfs/inode.c:	if (ret == 0 && inode->i_nlink > 0) {
fs/btrfs/inode.c:	inode->i_op = &btrfs_dir_inode_operations;
fs/btrfs/inode.c:	inode->i_fop = &btrfs_dir_file_operations;
fs/btrfs/inode.c:	extent_io_tree_init(&ei->io_tree, &inode->i_data);
fs/btrfs/inode.c:	extent_io_tree_init(&ei->io_failure_tree, &inode->i_data);
fs/btrfs/inode.c:	WARN_ON(!hlist_empty(&inode->i_dentry));
fs/btrfs/inode.c:	WARN_ON(inode->i_data.nrpages);
fs/btrfs/inode.c:	call_rcu(&inode->i_rcu, btrfs_i_callback);
fs/btrfs/inode.c:	u32 blocksize = inode->i_sb->s_blocksize;
fs/btrfs/inode.c:		b_inode->flags |= BTRFS_INODE_NODATACOW;
fs/btrfs/inode.c:		b_inode->flags &= ~BTRFS_INODE_NODATACOW;
fs/btrfs/inode.c:		b_inode->flags |= BTRFS_INODE_COMPRESS;
fs/btrfs/inode.c:		b_inode->flags &= ~BTRFS_INODE_NOCOMPRESS;
fs/btrfs/inode.c:		b_inode->flags &= ~(BTRFS_INODE_COMPRESS |
fs/btrfs/inode.c:	if (S_ISDIR(old_inode->i_mode) && new_inode &&
fs/btrfs/inode.c:	    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE)
fs/btrfs/inode.c:	if (new_inode && S_ISREG(old_inode->i_mode) && new_inode->i_size &&
fs/btrfs/inode.c:	    old_inode->i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT)
fs/btrfs/inode.c:		filemap_flush(old_inode->i_mapping);
fs/btrfs/inode.c:	if (new_inode && new_inode->i_size && S_ISREG(old_inode->i_mode))
fs/btrfs/inode.c:	old_inode->i_ctime = ctime;
fs/btrfs/inode.c:		new_inode->i_ctime = CURRENT_TIME;
fs/btrfs/inode.c:			BUG_ON(new_inode->i_nlink == 0);
fs/btrfs/inode.c:		if (!ret && new_inode->i_nlink == 0) {
fs/btrfs/inode.c:		filemap_flush(delalloc_work->inode->i_mapping);
fs/btrfs/inode.c:		list_del_init(&binode->delalloc_inodes);
fs/btrfs/inode.c:		inode = igrab(&binode->vfs_inode);
fs/btrfs/inode.c:		list_add_tail(&binode->delalloc_inodes,
fs/btrfs/inode.c:	inode->i_fop = &btrfs_file_operations;
fs/btrfs/inode.c:	inode->i_op = &btrfs_file_inode_operations;
fs/btrfs/inode.c:		inode->i_mapping->a_ops = &btrfs_aops;
fs/btrfs/inode.c:		inode->i_mapping->backing_dev_info = &root->fs_info->bdi;
fs/btrfs/inode.c:	inode->i_op = &btrfs_symlink_inode_operations;
fs/btrfs/inode.c:	inode->i_mapping->a_ops = &btrfs_symlink_aops;
fs/btrfs/inode.c:	inode->i_mapping->backing_dev_info = &root->fs_info->bdi;
fs/btrfs/inode.c:		inode->i_ctime = CURRENT_TIME;
fs/btrfs/inode.c:		    (actual_len > inode->i_size) &&
fs/btrfs/inode.c:		    (cur_offset > inode->i_size)) {
fs/btrfs/inode.c:	umode_t mode = inode->i_mode;
fs/btrfs/ctree.h:/* inode-item.c */
fs/btrfs/super.c:		filemap_flush(fs_info->btree_inode->i_mapping);
fs/btrfs/super.c:	if (inode && inode->i_ino == BTRFS_FIRST_FREE_OBJECTID)
fs/btrfs/Makefile:	   file-item.o inode-item.o inode-map.o disk-io.o \
fs/btrfs/free-space-cache.c:#include "inode-map.h"
fs/btrfs/free-space-cache.c:	mapping_set_gfp_mask(inode->i_mapping,
fs/btrfs/free-space-cache.c:			mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);
fs/btrfs/free-space-cache.c:	file_ra_state_init(ra, inode->i_mapping);
fs/btrfs/free-space-cache.c:	page_cache_sync_readahead(inode->i_mapping, ra, NULL, 0, last_index);
fs/btrfs/free-space-cache.c:	gfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);
fs/btrfs/free-space-cache.c:		page = find_or_create_page(inode->i_mapping, i, mask);
fs/btrfs/free-space-cache.c:		clear_extent_bit(&BTRFS_I(inode)->io_tree, 0, inode->i_size - 1,
fs/btrfs/free-space-cache.c:					 inode->i_size - 1,
fs/btrfs/free-space-cache.c:		invalidate_inode_pages2(inode->i_mapping);
fs/btrfs/free-space-cache.c:		btrfs_delalloc_release_metadata(inode, inode->i_size);
fs/btrfs/disk-io.c:#include "inode-map.h"
fs/btrfs/disk-io.c:			     fs_info->btree_inode->i_mapping);
fs/btrfs/disk-io.c:	mapping_set_gfp_mask(fs_info->btree_inode->i_mapping, GFP_NOFS);
fs/btrfs/disk-io.c:	fs_info->btree_inode->i_ino = BTRFS_BTREE_INODE_OBJECTID;
fs/btrfs/disk-io.c:	fs_info->btree_inode->i_size = OFFSET_MAX;
fs/btrfs/disk-io.c:	fs_info->btree_inode->i_mapping->a_ops = &btree_aops;
fs/btrfs/disk-io.c:	fs_info->btree_inode->i_mapping->backing_dev_info = &fs_info->bdi;
fs/btrfs/disk-io.c:			     fs_info->btree_inode->i_mapping);
fs/btrfs/disk-io.c:			     fs_info->btree_inode->i_mapping);
fs/btrfs/disk-io.c:			     fs_info->btree_inode->i_mapping);
fs/btrfs/disk-io.c:	filemap_write_and_wait(fs_info->btree_inode->i_mapping);
fs/btrfs/disk-io.c:	invalidate_inode_pages2(fs_info->btree_inode->i_mapping);
fs/btrfs/disk-io.c:	invalidate_inode_pages2(fs_info->btree_inode->i_mapping);
fs/btrfs/disk-io.c:				   root->fs_info->btree_inode->i_mapping);
fs/btrfs/disk-io.c:		list_del_init(&btrfs_inode->ordered_operations);
fs/btrfs/disk-io.c:		btrfs_invalidate_inodes(btrfs_inode->root);
fs/btrfs/disk-io.c:		list_del_init(&btrfs_inode->delalloc_inodes);
fs/btrfs/disk-io.c:		btrfs_invalidate_inodes(btrfs_inode->root);
fs/btrfs/disk-io.c:			page = find_get_page(btree_inode->i_mapping, index);
fs/btrfs/compression.c:		ret = find_get_pages_contig(inode->i_mapping, index,
fs/btrfs/compression.c:	cb->compressed_pages[0]->mapping = cb->inode->i_mapping;
fs/btrfs/compression.c:		page->mapping = inode->i_mapping;
fs/btrfs/compression.c:	struct address_space *mapping = inode->i_mapping;
fs/btrfs/compression.c:		page->mapping = inode->i_mapping;
fs/btrfs/btrfs_inode.h:		ino = inode->i_ino;
fs/btrfs/relocation.c:#include "inode-map.h"
fs/btrfs/relocation.c:		if (!S_ISREG(inode->i_mode))
fs/btrfs/relocation.c:	mutex_lock(&inode->i_mutex);
fs/btrfs/relocation.c:	mutex_unlock(&inode->i_mutex);
fs/btrfs/relocation.c:	gfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);
fs/btrfs/relocation.c:	file_ra_state_init(ra, inode->i_mapping);
fs/btrfs/relocation.c:		page = find_lock_page(inode->i_mapping, index);
fs/btrfs/relocation.c:			page_cache_sync_readahead(inode->i_mapping,
fs/btrfs/relocation.c:			page = find_or_create_page(inode->i_mapping, index,
fs/btrfs/relocation.c:			page_cache_async_readahead(inode->i_mapping,
fs/btrfs/relocation.c:		balance_dirty_pages_ratelimited(inode->i_mapping);
fs/btrfs/relocation.c:			invalidate_mapping_pages(rc->data_inode->i_mapping,
fs/btrfs/relocation.c:	filemap_write_and_wait_range(fs_info->btree_inode->i_mapping,
fs/btrfs/extent_io.c:		page = find_get_page(inode->i_mapping, index);
fs/btrfs/extent_io.c:		page = find_get_page(inode->i_mapping, index);
fs/btrfs/extent_io.c:		ret = find_get_pages_contig(inode->i_mapping, index,
fs/btrfs/extent_io.c:		ret = find_get_pages_contig(inode->i_mapping, index,
fs/btrfs/extent_io.c:				    pages[i]->mapping != inode->i_mapping) {
fs/btrfs/extent_io.c:		ret = find_get_pages_contig(inode->i_mapping, index,
fs/btrfs/extent_io.c:	size_t blocksize = inode->i_sb->s_blocksize;
fs/btrfs/extent_io.c:	blocksize = inode->i_sb->s_blocksize;
fs/btrfs/extent_io.c:	struct address_space *mapping = inode->i_mapping;
fs/btrfs/transaction.c:#include "inode-map.h"
fs/btrfs/transaction.c:			     fs_info->btree_inode->i_mapping);
fs/btrfs/transaction.c:	struct address_space *mapping = root->fs_info->btree_inode->i_mapping;
fs/btrfs/transaction.c:	struct address_space *mapping = root->fs_info->btree_inode->i_mapping;
fs/btrfs/transaction.c:		return filemap_write_and_wait(btree_inode->i_mapping);
fs/btrfs/transaction.c:	btrfs_i_size_write(parent_inode, parent_inode->i_size +
fs/btrfs/transaction.c:	parent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;
fs/btrfs/file.c:	gfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);
fs/btrfs/file.c:		pages[i] = find_or_create_page(inode->i_mapping, index + i,
fs/btrfs/file.c:	if (start_pos < inode->i_size) {
fs/btrfs/file.c:		balance_dirty_pages_ratelimited(inode->i_mapping);
fs/btrfs/file.c:	now = current_fs_time(inode->i_sb);
fs/btrfs/file.c:	if (!timespec_equal(&inode->i_mtime, &now))
fs/btrfs/file.c:		inode->i_mtime = now;
fs/btrfs/file.c:	if (!timespec_equal(&inode->i_ctime, &now))
fs/btrfs/file.c:		inode->i_ctime = now;
fs/btrfs/file.c:	sb_start_write(inode->i_sb);
fs/btrfs/file.c:	mutex_lock(&inode->i_mutex);
fs/btrfs/file.c:		mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:	current->backing_dev_info = inode->i_mapping->backing_dev_info;
fs/btrfs/file.c:	err = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));
fs/btrfs/file.c:		mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:		mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:		mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:		mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:			mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:	mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:	sb_end_write(inode->i_sb);
fs/btrfs/file.c:		if (inode->i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT)
fs/btrfs/file.c:			filemap_flush(inode->i_mapping);
fs/btrfs/file.c:	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/btrfs/file.c:	mutex_lock(&inode->i_mutex);
fs/btrfs/file.c:		mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:		mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:		mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:		mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:	mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:	mutex_lock(&inode->i_mutex);
fs/btrfs/file.c:		if (offset < round_up(inode->i_size, PAGE_CACHE_SIZE))
fs/btrfs/file.c:		mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:	if (offset < round_up(inode->i_size, PAGE_CACHE_SIZE)) {
fs/btrfs/file.c:			mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:	if (offset + len < round_up(inode->i_size, PAGE_CACHE_SIZE)) {
fs/btrfs/file.c:			mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:		mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/btrfs/file.c:	mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:	mutex_lock(&inode->i_mutex);
fs/btrfs/file.c:	if (alloc_start > inode->i_size) {
fs/btrfs/file.c:		    (cur_offset >= inode->i_size &&
fs/btrfs/file.c:							1 << inode->i_blkbits,
fs/btrfs/file.c:		} else if (actual_end > inode->i_size &&
fs/btrfs/file.c:			inode->i_ctime = CURRENT_TIME;
fs/btrfs/file.c:	mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:	if (inode->i_size == 0)
fs/btrfs/file.c:			last_end = min_t(u64, last_end, inode->i_size);
fs/btrfs/file.c:					if (start >= inode->i_size) {
fs/btrfs/file.c:			last_end = min_t(u64, last_end, inode->i_size);
fs/btrfs/file.c:		*offset = min(*offset, inode->i_size);
fs/btrfs/file.c:	mutex_lock(&inode->i_mutex);
fs/btrfs/file.c:			mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:			mutex_unlock(&inode->i_mutex);
fs/btrfs/file.c:	if (offset > inode->i_sb->s_maxbytes) {
fs/btrfs/file.c:	mutex_unlock(&inode->i_mutex);
fs/btrfs/ordered-data.c:	struct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);
fs/btrfs/ordered-data.c:	    !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_DIRTY)) {
fs/btrfs/ordered-data.c:		inode = &btrfs_inode->vfs_inode;
fs/btrfs/ordered-data.c:		list_del_init(&btrfs_inode->ordered_operations);
fs/btrfs/ordered-data.c:				list_add_tail(&btrfs_inode->ordered_operations,
fs/btrfs/ordered-data.c:		filemap_fdatawrite_range(inode->i_mapping, start, end);
fs/btrfs/ordered-data.c:	filemap_fdatawrite_range(inode->i_mapping, start, orig_end);
fs/btrfs/ordered-data.c:		filemap_fdatawrite_range(inode->i_mapping, start, orig_end);
fs/btrfs/ordered-data.c:	filemap_fdatawait_range(inode->i_mapping, start, orig_end);
fs/btrfs/ordered-data.c:	 * if the disk i_size is already at the inode->i_size, or
fs/btrfs/ioctl.c:#include "inode-map.h"
fs/btrfs/ioctl.c: * Update inode->i_flags based on the btrfs internal flags.
fs/btrfs/ioctl.c:	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);
fs/btrfs/ioctl.c:		inode->i_flags |= S_SYNC;
fs/btrfs/ioctl.c:		inode->i_flags |= S_IMMUTABLE;
fs/btrfs/ioctl.c:		inode->i_flags |= S_APPEND;
fs/btrfs/ioctl.c:		inode->i_flags |= S_NOATIME;
fs/btrfs/ioctl.c:		inode->i_flags |= S_DIRSYNC;
fs/btrfs/ioctl.c:		if (S_ISREG(inode->i_mode))
fs/btrfs/ioctl.c:	mutex_lock(&inode->i_mutex);
fs/btrfs/ioctl.c:	i_oldflags = inode->i_flags;
fs/btrfs/ioctl.c:	mode = inode->i_mode;
fs/btrfs/ioctl.c:	flags = btrfs_mask_flags(inode->i_mode, flags);
fs/btrfs/ioctl.c:			if (inode->i_size == 0)
fs/btrfs/ioctl.c:			if (inode->i_size == 0)
fs/btrfs/ioctl.c:	inode->i_ctime = CURRENT_TIME;
fs/btrfs/ioctl.c:		inode->i_flags = i_oldflags;
fs/btrfs/ioctl.c:	mutex_unlock(&inode->i_mutex);
fs/btrfs/ioctl.c:	return put_user(inode->i_generation, arg);
fs/btrfs/ioctl.c:	if (uid_eq(inode->i_uid, fsuid))
fs/btrfs/ioctl.c:		if (!S_ISDIR(victim->d_inode->i_mode))
fs/btrfs/ioctl.c:	} else if (S_ISDIR(victim->d_inode->i_mode))
fs/btrfs/ioctl.c:	gfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);
fs/btrfs/ioctl.c:		page = find_or_create_page(inode->i_mapping,
fs/btrfs/ioctl.c:			if (page->mapping != inode->i_mapping) {
fs/btrfs/ioctl.c:		if (page->mapping != inode->i_mapping) {
fs/btrfs/ioctl.c:	if (!(inode->i_sb->s_flags & MS_ACTIVE))
fs/btrfs/ioctl.c:		file_ra_state_init(ra, inode->i_mapping);
fs/btrfs/ioctl.c:	if (i < inode->i_mapping->writeback_index)
fs/btrfs/ioctl.c:		inode->i_mapping->writeback_index = i;
fs/btrfs/ioctl.c:		if (!(inode->i_sb->s_flags & MS_ACTIVE))
fs/btrfs/ioctl.c:			btrfs_force_ra(inode->i_mapping, ra, file, ra_index,
fs/btrfs/ioctl.c:		mutex_lock(&inode->i_mutex);
fs/btrfs/ioctl.c:			mutex_unlock(&inode->i_mutex);
fs/btrfs/ioctl.c:		balance_dirty_pages_ratelimited(inode->i_mapping);
fs/btrfs/ioctl.c:		mutex_unlock(&inode->i_mutex);
fs/btrfs/ioctl.c:		filemap_flush(inode->i_mapping);
fs/btrfs/ioctl.c:		mutex_lock(&inode->i_mutex);
fs/btrfs/ioctl.c:		mutex_unlock(&inode->i_mutex);
fs/btrfs/ioctl.c:		new_size = device->bdev->bd_inode->i_size;
fs/btrfs/ioctl.c:	if (new_size > device->bdev->bd_inode->i_size) {
fs/btrfs/ioctl.c:		if (src_inode->i_sb != file->f_path.dentry->d_inode->i_sb) {
fs/btrfs/ioctl.c:	mutex_lock(&inode->i_mutex);
fs/btrfs/ioctl.c:	inode->i_flags |= S_DEAD;
fs/btrfs/ioctl.c:	mutex_unlock(&inode->i_mutex);
fs/btrfs/ioctl.c:	switch (inode->i_mode & S_IFMT) {
fs/btrfs/ioctl.c:	if (S_ISDIR(src->i_mode) || S_ISDIR(inode->i_mode))
fs/btrfs/ioctl.c:	if (src->i_sb != inode->i_sb)
fs/btrfs/ioctl.c:		mutex_lock_nested(&inode->i_mutex, I_MUTEX_PARENT);
fs/btrfs/ioctl.c:		mutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);
fs/btrfs/ioctl.c:	if (destoff > inode->i_size) {
fs/btrfs/ioctl.c:		ret = btrfs_cont_expand(inode, inode->i_size, destoff);
fs/btrfs/ioctl.c:	truncate_inode_pages_range(&inode->i_data, destoff,
fs/btrfs/ioctl.c:			inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/btrfs/ioctl.c:			if (endoff > inode->i_size)
fs/btrfs/ioctl.c:	mutex_unlock(&inode->i_mutex);
fs/btrfs/tree-log.c:	if (nlink != inode->i_nlink) {
fs/btrfs/tree-log.c:	if (inode->i_nlink == 0) {
fs/btrfs/tree-log.c:		if (S_ISDIR(inode->i_mode)) {
fs/btrfs/tree-log.c:		if (!inode->i_nlink)
fs/btrfs/tree-log.c:		btrfs_set_token_inode_size(leaf, item, inode->i_size, &token);
fs/btrfs/tree-log.c:	btrfs_set_token_inode_mode(leaf, item, inode->i_mode, &token);
fs/btrfs/tree-log.c:	btrfs_set_token_inode_nlink(leaf, item, inode->i_nlink, &token);
fs/btrfs/tree-log.c:				     inode->i_atime.tv_sec, &token);
fs/btrfs/tree-log.c:				      inode->i_atime.tv_nsec, &token);
fs/btrfs/tree-log.c:				     inode->i_mtime.tv_sec, &token);
fs/btrfs/tree-log.c:				      inode->i_mtime.tv_nsec, &token);
fs/btrfs/tree-log.c:				     inode->i_ctime.tv_sec, &token);
fs/btrfs/tree-log.c:				      inode->i_ctime.tv_nsec, &token);
fs/btrfs/tree-log.c:	btrfs_set_token_inode_sequence(leaf, item, inode->i_version, &token);
fs/btrfs/tree-log.c:	btrfs_set_token_inode_rdev(leaf, item, inode->i_rdev, &token);
fs/btrfs/tree-log.c:	if (S_ISDIR(inode->i_mode) ||
fs/btrfs/tree-log.c:	if (S_ISDIR(inode->i_mode) ||
fs/btrfs/tree-log.c:	if (S_ISDIR(inode->i_mode)) {
fs/btrfs/tree-log.c:	if (inode_only == LOG_INODE_ALL && S_ISDIR(inode->i_mode)) {
fs/btrfs/tree-log.c:	if (S_ISREG(inode->i_mode) &&
fs/btrfs/tree-log.c:	if (!S_ISDIR(inode->i_mode)) {
fs/btrfs/tree-log.c:		if (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)
fs/btrfs/tree-log.c:		if (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)
fs/btrfs/tree-log.c:	sb = inode->i_sb;
fs/btrfs/tree-log.c:	if (S_ISREG(inode->i_mode) &&
fs/btrfs/tree-log.c:		if (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)
fs/btrfs/tree-log.c:	if (S_ISREG(inode->i_mode))
fs/btrfs/tree-log.c:	if (S_ISREG(inode->i_mode))
fs/btrfs/delayed-inode.c:	struct btrfs_root *root = btrfs_inode->root;
fs/btrfs/delayed-inode.c:	node = ACCESS_ONCE(btrfs_inode->delayed_node);
fs/btrfs/delayed-inode.c:		if (btrfs_inode->delayed_node) {
fs/btrfs/delayed-inode.c:			BUG_ON(btrfs_inode->delayed_node != node);
fs/btrfs/delayed-inode.c:		btrfs_inode->delayed_node = node;
fs/btrfs/delayed-inode.c:	struct btrfs_root *root = btrfs_inode->root;
fs/btrfs/delayed-inode.c:	btrfs_inode->delayed_node = node;
fs/btrfs/delayed-inode.c:	btrfs_set_stack_inode_mode(inode_item, inode->i_mode);
fs/btrfs/delayed-inode.c:	btrfs_set_stack_inode_nlink(inode_item, inode->i_nlink);
fs/btrfs/delayed-inode.c:	btrfs_set_stack_inode_sequence(inode_item, inode->i_version);
fs/btrfs/delayed-inode.c:	btrfs_set_stack_inode_rdev(inode_item, inode->i_rdev);
fs/btrfs/delayed-inode.c:				     inode->i_atime.tv_sec);
fs/btrfs/delayed-inode.c:				      inode->i_atime.tv_nsec);
fs/btrfs/delayed-inode.c:				     inode->i_mtime.tv_sec);
fs/btrfs/delayed-inode.c:				      inode->i_mtime.tv_nsec);
fs/btrfs/delayed-inode.c:				     inode->i_ctime.tv_sec);
fs/btrfs/delayed-inode.c:				      inode->i_ctime.tv_nsec);
fs/btrfs/delayed-inode.c:	inode->i_mode = btrfs_stack_inode_mode(inode_item);
fs/btrfs/delayed-inode.c:	inode->i_version = btrfs_stack_inode_sequence(inode_item);
fs/btrfs/delayed-inode.c:	inode->i_rdev = 0;
fs/btrfs/delayed-inode.c:	inode->i_atime.tv_sec = btrfs_stack_timespec_sec(tspec);
fs/btrfs/delayed-inode.c:	inode->i_atime.tv_nsec = btrfs_stack_timespec_nsec(tspec);
fs/btrfs/delayed-inode.c:	inode->i_mtime.tv_sec = btrfs_stack_timespec_sec(tspec);
fs/btrfs/delayed-inode.c:	inode->i_mtime.tv_nsec = btrfs_stack_timespec_nsec(tspec);
fs/btrfs/delayed-inode.c:	inode->i_ctime.tv_sec = btrfs_stack_timespec_sec(tspec);
fs/btrfs/delayed-inode.c:	inode->i_ctime.tv_nsec = btrfs_stack_timespec_nsec(tspec);
fs/btrfs/delayed-inode.c:	inode->i_generation = BTRFS_I(inode)->generation;
fs/btrfs/acl.c:			ret = posix_acl_equiv_mode(acl, &inode->i_mode);
fs/btrfs/acl.c:		if (!S_ISDIR(inode->i_mode))
fs/btrfs/acl.c:	if (!S_ISLNK(inode->i_mode)) {
fs/btrfs/acl.c:			inode->i_mode &= ~current_umask();
fs/btrfs/acl.c:		if (S_ISDIR(inode->i_mode)) {
fs/btrfs/acl.c:		ret = posix_acl_create(&acl, GFP_NOFS, &inode->i_mode);
fs/btrfs/acl.c:	if (S_ISLNK(inode->i_mode))
fs/btrfs/acl.c:	ret = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
fs/btrfs/volumes.c:		filemap_write_and_wait((*bdev)->bd_inode->i_mapping);
fs/btrfs/volumes.c:	filemap_write_and_wait(bdev->bd_inode->i_mapping);
fs/btrfs/volumes.c:	filemap_write_and_wait(bdev->bd_inode->i_mapping);
fs/btrfs/export.c:	fid->gen = inode->i_generation;
fs/btrfs/export.c:	if (check_generation && generation != inode->i_generation) {
fs/btrfs/xattr.c:	inode->i_ctime = CURRENT_TIME;
fs/btrfs/inode-map.c:#include "inode-map.h"
fs/btrfs/scrub.c:	page = find_or_create_page(inode->i_mapping, index, GFP_NOFS);
fs/btrfs/scrub.c:		page = find_or_create_page(inode->i_mapping, index, GFP_NOFS);
fs/f2fs/inode.c:	inode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE |
fs/f2fs/inode.c:		inode->i_flags |= S_SYNC;
fs/f2fs/inode.c:		inode->i_flags |= S_APPEND;
fs/f2fs/inode.c:		inode->i_flags |= S_IMMUTABLE;
fs/f2fs/inode.c:		inode->i_flags |= S_NOATIME;
fs/f2fs/inode.c:		inode->i_flags |= S_DIRSYNC;
fs/f2fs/inode.c:	if (inode->i_ino != args->ino)
fs/f2fs/inode.c:	if (inode->i_state & (I_FREEING | I_WILL_FREE)) {
fs/f2fs/inode.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/inode.c:	check_nid_range(sbi, inode->i_ino);
fs/f2fs/inode.c:	node_page = get_node_page(sbi, inode->i_ino);
fs/f2fs/inode.c:	inode->i_mode = le16_to_cpu(ri->i_mode);
fs/f2fs/inode.c:	inode->i_size = le64_to_cpu(ri->i_size);
fs/f2fs/inode.c:	inode->i_blocks = le64_to_cpu(ri->i_blocks);
fs/f2fs/inode.c:	inode->i_atime.tv_sec = le64_to_cpu(ri->i_atime);
fs/f2fs/inode.c:	inode->i_ctime.tv_sec = le64_to_cpu(ri->i_ctime);
fs/f2fs/inode.c:	inode->i_mtime.tv_sec = le64_to_cpu(ri->i_mtime);
fs/f2fs/inode.c:	inode->i_atime.tv_nsec = le32_to_cpu(ri->i_atime_nsec);
fs/f2fs/inode.c:	inode->i_ctime.tv_nsec = le32_to_cpu(ri->i_ctime_nsec);
fs/f2fs/inode.c:	inode->i_mtime.tv_nsec = le32_to_cpu(ri->i_mtime_nsec);
fs/f2fs/inode.c:	inode->i_generation = le32_to_cpu(ri->i_generation);
fs/f2fs/inode.c:	if (!(inode->i_state & I_NEW))
fs/f2fs/inode.c:	if (!sbi->por_doing && inode->i_nlink == 0) {
fs/f2fs/inode.c:		inode->i_mapping->a_ops = &f2fs_node_aops;
fs/f2fs/inode.c:		mapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);
fs/f2fs/inode.c:		inode->i_mapping->a_ops = &f2fs_meta_aops;
fs/f2fs/inode.c:		mapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);
fs/f2fs/inode.c:	} else if (S_ISREG(inode->i_mode)) {
fs/f2fs/inode.c:		inode->i_op = &f2fs_file_inode_operations;
fs/f2fs/inode.c:		inode->i_fop = &f2fs_file_operations;
fs/f2fs/inode.c:		inode->i_mapping->a_ops = &f2fs_dblock_aops;
fs/f2fs/inode.c:	} else if (S_ISDIR(inode->i_mode)) {
fs/f2fs/inode.c:		inode->i_op = &f2fs_dir_inode_operations;
fs/f2fs/inode.c:		inode->i_fop = &f2fs_dir_operations;
fs/f2fs/inode.c:		inode->i_mapping->a_ops = &f2fs_dblock_aops;
fs/f2fs/inode.c:		mapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER_MOVABLE |
fs/f2fs/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/f2fs/inode.c:		inode->i_op = &f2fs_symlink_inode_operations;
fs/f2fs/inode.c:		inode->i_mapping->a_ops = &f2fs_dblock_aops;
fs/f2fs/inode.c:	} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||
fs/f2fs/inode.c:			S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {
fs/f2fs/inode.c:		inode->i_op = &f2fs_special_inode_operations;
fs/f2fs/inode.c:		init_special_inode(inode, inode->i_mode, inode->i_rdev);
fs/f2fs/inode.c:	ri->i_mode = cpu_to_le16(inode->i_mode);
fs/f2fs/inode.c:	ri->i_links = cpu_to_le32(inode->i_nlink);
fs/f2fs/inode.c:	ri->i_blocks = cpu_to_le64(inode->i_blocks);
fs/f2fs/inode.c:	ri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);
fs/f2fs/inode.c:	ri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);
fs/f2fs/inode.c:	ri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);
fs/f2fs/inode.c:	ri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);
fs/f2fs/inode.c:	ri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);
fs/f2fs/inode.c:	ri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);
fs/f2fs/inode.c:	ri->i_generation = cpu_to_le32(inode->i_generation);
fs/f2fs/inode.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/inode.c:	if (inode->i_ino == F2FS_NODE_INO(sbi) ||
fs/f2fs/inode.c:			inode->i_ino == F2FS_META_INO(sbi))
fs/f2fs/inode.c:	node_page = get_node_page(sbi, inode->i_ino);
fs/f2fs/inode.c:		node_page = get_node_page(sbi, inode->i_ino);
fs/f2fs/inode.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/f2fs/inode.c:	if (inode->i_ino == F2FS_NODE_INO(sbi) ||
fs/f2fs/inode.c:			inode->i_ino == F2FS_META_INO(sbi))
fs/f2fs/inode.c:	if (inode->i_nlink || is_bad_inode(inode))
fs/f2fs/segment.h:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/segment.h:	if (S_ISDIR(inode->i_mode))
fs/f2fs/super.c:	call_rcu(&inode->i_rcu, f2fs_i_callback);
fs/f2fs/super.c:	if (generation && inode->i_generation != generation) {
fs/f2fs/node.c:	struct address_space *mapping = sbi->meta_inode->i_mapping;
fs/f2fs/node.c:	struct f2fs_sb_info *sbi = F2FS_SB(dn->inode->i_sb);
fs/f2fs/node.c:	nids[0] = dn->inode->i_ino;
fs/f2fs/node.c:	struct f2fs_sb_info *sbi = F2FS_SB(dn->inode->i_sb);
fs/f2fs/node.c:	if (dn->inode->i_blocks == 0) {
fs/f2fs/node.c:	if (dn->nid == dn->inode->i_ino) {
fs/f2fs/node.c:	struct f2fs_sb_info *sbi = F2FS_SB(dn->inode->i_sb);
fs/f2fs/node.c:	struct f2fs_sb_info *sbi = F2FS_SB(dn->inode->i_sb);
fs/f2fs/node.c:	struct f2fs_sb_info *sbi = F2FS_SB(dn->inode->i_sb);
fs/f2fs/node.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/node.c:	page = get_node_page(sbi, inode->i_ino);
fs/f2fs/node.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/node.c:	nid_t ino = inode->i_ino;
fs/f2fs/node.c:	BUG_ON(inode->i_blocks != 0 && inode->i_blocks != 1);
fs/f2fs/node.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/node.c:	set_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);
fs/f2fs/node.c:	struct f2fs_sb_info *sbi = F2FS_SB(dn->inode->i_sb);
fs/f2fs/node.c:	struct address_space *mapping = sbi->node_inode->i_mapping;
fs/f2fs/node.c:	fill_node_footer(page, dn->nid, dn->inode->i_ino, ofs, true);
fs/f2fs/node.c:	new_ni.ino = dn->inode->i_ino;
fs/f2fs/node.c:	struct address_space *mapping = sbi->node_inode->i_mapping;
fs/f2fs/node.c:	struct address_space *mapping = sbi->node_inode->i_mapping;
fs/f2fs/node.c:	struct address_space *mapping = sbi->node_inode->i_mapping;
fs/f2fs/node.c:	struct address_space *mapping = sbi->node_inode->i_mapping;
fs/f2fs/node.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/node.c:	struct address_space *mapping = sbi->node_inode->i_mapping;
fs/f2fs/dir.c:	mode_t mode = inode->i_mode;
fs/f2fs/dir.c:	de->ino = cpu_to_le32(inode->i_ino);
fs/f2fs/dir.c:		if (S_ISDIR(inode->i_mode)) {
fs/f2fs/dir.c:		ipage = get_node_page(F2FS_SB(dir->i_sb), inode->i_ino);
fs/f2fs/dir.c:		if (S_ISDIR(inode->i_mode)) {
fs/f2fs/dir.c:	de->ino = cpu_to_le32(inode->i_ino);
fs/f2fs/dir.c:	if (inode && S_ISDIR(inode->i_mode)) {
fs/f2fs/dir.c:		inode->i_ctime = CURRENT_TIME;
fs/f2fs/dir.c:		if (S_ISDIR(inode->i_mode)) {
fs/f2fs/dir.c:		if (inode->i_nlink == 0)
fs/f2fs/dir.c:			add_orphan_inode(sbi, inode->i_ino);
fs/f2fs/dir.c:	de->ino = cpu_to_le32(inode->i_ino);
fs/f2fs/node.h:	if (S_ISDIR(inode->i_mode))
fs/f2fs/debug.c:	si->node_pages = sbi->node_inode->i_mapping->nrpages;
fs/f2fs/debug.c:	si->meta_pages = sbi->meta_inode->i_mapping->nrpages;
fs/f2fs/debug.c:	npages = sbi->node_inode->i_mapping->nrpages;
fs/f2fs/debug.c:	npages = sbi->meta_inode->i_mapping->nrpages;
fs/f2fs/debug.c:	return single_open(file, stat_show, inode->i_private);
fs/f2fs/recovery.c:		if (entry->inode->i_ino == ino)
fs/f2fs/recovery.c:	dir = f2fs_iget(inode->i_sb, le32_to_cpu(raw_inode->i_pino));
fs/f2fs/recovery.c:	dent.d_name.len = le32_to_cpu(raw_inode->i_namelen);
fs/f2fs/recovery.c:	dent.d_name.name = raw_inode->i_name;
fs/f2fs/recovery.c:	inode->i_mode = le16_to_cpu(raw_inode->i_mode);
fs/f2fs/recovery.c:	i_size_write(inode, le64_to_cpu(raw_inode->i_size));
fs/f2fs/recovery.c:	inode->i_atime.tv_sec = le64_to_cpu(raw_inode->i_mtime);
fs/f2fs/recovery.c:	inode->i_ctime.tv_sec = le64_to_cpu(raw_inode->i_ctime);
fs/f2fs/recovery.c:	inode->i_mtime.tv_sec = le64_to_cpu(raw_inode->i_mtime);
fs/f2fs/recovery.c:	inode->i_atime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);
fs/f2fs/recovery.c:	inode->i_ctime.tv_nsec = le32_to_cpu(raw_inode->i_ctime_nsec);
fs/f2fs/recovery.c:	inode->i_mtime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);
fs/f2fs/segment.c:		if (S_ISDIR(inode->i_mode))
fs/f2fs/segment.c:		if (S_ISDIR(inode->i_mode))
fs/f2fs/segment.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/gc.c:		if (ie->inode->i_ino == ino)
fs/f2fs/gc.c:	if (page->mapping != inode->i_mapping)
fs/f2fs/gc.c:		struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/gc.c:			S_ISDIR(inode->i_mode)) {
fs/f2fs/data.c:	struct f2fs_sb_info *sbi = F2FS_SB(dn->inode->i_sb);
fs/f2fs/data.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/data.c:		unsigned int blkbits = inode->i_sb->s_blocksize_bits;
fs/f2fs/data.c:		map_bh(bh_result, inode->i_sb,
fs/f2fs/data.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/data.c:	struct address_space *mapping = inode->i_mapping;
fs/f2fs/data.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/data.c:	struct address_space *mapping = inode->i_mapping;
fs/f2fs/data.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/data.c:	struct address_space *mapping = inode->i_mapping;
fs/f2fs/data.c:	unsigned int blkbits = inode->i_sb->s_blocksize_bits;
fs/f2fs/data.c:		map_bh(bh_result, inode->i_sb, dn.data_blkaddr);
fs/f2fs/data.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/data.c:		rewrite_data_page(F2FS_SB(inode->i_sb), page,
fs/f2fs/data.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/data.c:		if (S_ISDIR(inode->i_mode)) {
fs/f2fs/data.c:	if (wbc->for_reclaim && !S_ISDIR(inode->i_mode) && !is_cold_data(page))
fs/f2fs/data.c:	if (S_ISDIR(inode->i_mode)) {
fs/f2fs/data.c:	if (!wbc->for_reclaim && !S_ISDIR(inode->i_mode))
fs/f2fs/data.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/data.c:	if (!S_ISDIR(inode->i_mode))
fs/f2fs/data.c:	if (!S_ISDIR(inode->i_mode))
fs/f2fs/data.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/data.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/data.c:	if (S_ISDIR(inode->i_mode) && PageDirty(page)) {
fs/f2fs/file.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/file.c:	sb_start_pagefault(inode->i_sb);
fs/f2fs/file.c:	if (page->mapping != inode->i_mapping ||
fs/f2fs/file.c:	sb_end_pagefault(inode->i_sb);
fs/f2fs/file.c:	pino = dentry->d_parent->d_inode->i_ino;
fs/f2fs/file.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/file.c:	if (inode->i_sb->s_flags & MS_RDONLY)
fs/f2fs/file.c:	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/f2fs/file.c:	mutex_lock(&inode->i_mutex);
fs/f2fs/file.c:	if (datasync && !(inode->i_state & I_DIRTY_DATASYNC))
fs/f2fs/file.c:					!(inode->i_state & I_DIRTY))
fs/f2fs/file.c:	if (!S_ISREG(inode->i_mode) || inode->i_nlink != 1)
fs/f2fs/file.c:		ret = f2fs_sync_fs(inode->i_sb, 1);
fs/f2fs/file.c:		while (!sync_node_pages(sbi, inode->i_ino, &wbc)) {
fs/f2fs/file.c:		filemap_fdatawait_range(sbi->node_inode->i_mapping,
fs/f2fs/file.c:	mutex_unlock(&inode->i_mutex);
fs/f2fs/file.c:	struct f2fs_sb_info *sbi = F2FS_SB(dn->inode->i_sb);
fs/f2fs/file.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/file.c:	unsigned int blocksize = inode->i_sb->s_blocksize;
fs/f2fs/file.c:	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
fs/f2fs/file.c:				S_ISLNK(inode->i_mode)))
fs/f2fs/file.c:		inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/f2fs/file.c:	f2fs_balance_fs(F2FS_SB(inode->i_sb));
fs/f2fs/file.c:		inode->i_uid = attr->ia_uid;
fs/f2fs/file.c:		inode->i_gid = attr->ia_gid;
fs/f2fs/file.c:		inode->i_atime = timespec_trunc(attr->ia_atime,
fs/f2fs/file.c:						inode->i_sb->s_time_gran);
fs/f2fs/file.c:		inode->i_mtime = timespec_trunc(attr->ia_mtime,
fs/f2fs/file.c:						inode->i_sb->s_time_gran);
fs/f2fs/file.c:		inode->i_ctime = timespec_trunc(attr->ia_ctime,
fs/f2fs/file.c:						inode->i_sb->s_time_gran);
fs/f2fs/file.c:		if (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))
fs/f2fs/file.c:			inode->i_mode = fi->i_acl_mode;
fs/f2fs/file.c:		struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/file.c:			struct address_space *mapping = inode->i_mapping;
fs/f2fs/file.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/file.c:		inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/f2fs/file.c:		flags = f2fs_mask_flags(inode->i_mode, flags);
fs/f2fs/file.c:		mutex_lock(&inode->i_mutex);
fs/f2fs/file.c:				mutex_unlock(&inode->i_mutex);
fs/f2fs/file.c:		mutex_unlock(&inode->i_mutex);
fs/f2fs/file.c:		inode->i_ctime = CURRENT_TIME;
fs/f2fs/acl.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/acl.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/acl.c:	if (S_ISLNK(inode->i_mode))
fs/f2fs/acl.c:			error = posix_acl_equiv_mode(acl, &inode->i_mode);
fs/f2fs/acl.c:			set_acl_inode(fi, inode->i_mode);
fs/f2fs/acl.c:		if (!S_ISDIR(inode->i_mode))
fs/f2fs/acl.c:	if (!S_ISLNK(inode->i_mode)) {
fs/f2fs/acl.c:			inode->i_mode &= ~current_umask();
fs/f2fs/acl.c:		if (S_ISDIR(inode->i_mode)) {
fs/f2fs/acl.c:		error = posix_acl_create(&acl, GFP_KERNEL, &inode->i_mode);
fs/f2fs/acl.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/f2fs.h:		return (inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS + 1);
fs/f2fs/f2fs.h:		return (inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS);
fs/f2fs/f2fs.h:	inode->i_blocks += count;
fs/f2fs/f2fs.h:	BUG_ON(inode->i_blocks < count);
fs/f2fs/f2fs.h:	inode->i_blocks -= count;
fs/f2fs/f2fs.h:		inode->i_blocks += count;
fs/f2fs/f2fs.h:	BUG_ON(inode->i_blocks < count);
fs/f2fs/f2fs.h:	inode->i_blocks -= count;
fs/f2fs/namei.c:	inode->i_uid = current_fsuid();
fs/f2fs/namei.c:		inode->i_gid = dir->i_gid;
fs/f2fs/namei.c:		inode->i_gid = current_fsgid();
fs/f2fs/namei.c:	inode->i_ino = ino;
fs/f2fs/namei.c:	inode->i_mode = mode;
fs/f2fs/namei.c:	inode->i_blocks = 0;
fs/f2fs/namei.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
fs/f2fs/namei.c:	inode->i_generation = sbi->s_next_generation++;
fs/f2fs/namei.c:	inode->i_op = &f2fs_file_inode_operations;
fs/f2fs/namei.c:	inode->i_fop = &f2fs_file_operations;
fs/f2fs/namei.c:	inode->i_mapping->a_ops = &f2fs_dblock_aops;
fs/f2fs/namei.c:	ino = inode->i_ino;
fs/f2fs/namei.c:	inode->i_ctime = CURRENT_TIME;
fs/f2fs/namei.c:	atomic_inc(&inode->i_count);
fs/f2fs/namei.c:	return d_obtain_alias(f2fs_iget(child->d_inode->i_sb, ino));
fs/f2fs/namei.c:	inode->i_op = &f2fs_symlink_inode_operations;
fs/f2fs/namei.c:	inode->i_mapping->a_ops = &f2fs_dblock_aops;
fs/f2fs/namei.c:	alloc_nid_done(sbi, inode->i_ino);
fs/f2fs/namei.c:	alloc_nid_failed(sbi, inode->i_ino);
fs/f2fs/namei.c:	inode->i_op = &f2fs_dir_inode_operations;
fs/f2fs/namei.c:	inode->i_fop = &f2fs_dir_operations;
fs/f2fs/namei.c:	inode->i_mapping->a_ops = &f2fs_dblock_aops;
fs/f2fs/namei.c:	mapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);
fs/f2fs/namei.c:	alloc_nid_done(sbi, inode->i_ino);
fs/f2fs/namei.c:	alloc_nid_failed(sbi, inode->i_ino);
fs/f2fs/namei.c:	init_special_inode(inode, inode->i_mode, rdev);
fs/f2fs/namei.c:	inode->i_op = &f2fs_special_inode_operations;
fs/f2fs/namei.c:	alloc_nid_done(sbi, inode->i_ino);
fs/f2fs/namei.c:	alloc_nid_failed(sbi, inode->i_ino);
fs/f2fs/namei.c:	if (S_ISDIR(old_inode->i_mode)) {
fs/f2fs/namei.c:		new_inode->i_ctime = CURRENT_TIME;
fs/f2fs/namei.c:		if (!new_inode->i_nlink)
fs/f2fs/namei.c:			add_orphan_inode(sbi, new_inode->i_ino);
fs/f2fs/namei.c:	old_inode->i_ctime = CURRENT_TIME;
fs/f2fs/checkpoint.c:	struct address_space *mapping = sbi->meta_inode->i_mapping;
fs/f2fs/checkpoint.c:	struct address_space *mapping = sbi->meta_inode->i_mapping;
fs/f2fs/checkpoint.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/checkpoint.c:	struct address_space *mapping = sbi->meta_inode->i_mapping;
fs/f2fs/checkpoint.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/checkpoint.c:	if (!S_ISDIR(inode->i_mode))
fs/f2fs/checkpoint.c:	BUG_ON(!S_ISDIR(inode->i_mode));
fs/f2fs/checkpoint.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/checkpoint.c:	if (!S_ISDIR(inode->i_mode))
fs/f2fs/checkpoint.c:		filemap_flush(inode->i_mapping);
fs/f2fs/checkpoint.c:	filemap_fdatawait_range(sbi->node_inode->i_mapping, 0, LONG_MAX);
fs/f2fs/checkpoint.c:	filemap_fdatawait_range(sbi->meta_inode->i_mapping, 0, LONG_MAX);
fs/f2fs/xattr.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/xattr.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/xattr.c:	struct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);
fs/f2fs/xattr.c:		inode->i_mode = fi->i_acl_mode;
fs/f2fs/xattr.c:		inode->i_ctime = CURRENT_TIME;
fs/fat/inode.c:	struct super_block *sb = inode->i_sb;
fs/fat/inode.c:	struct super_block *sb = inode->i_sb;
fs/fat/inode.c:	unsigned long max_blocks = bh_result->b_size >> inode->i_blkbits;
fs/fat/inode.c:	if (to > inode->i_size) {
fs/fat/inode.c:		truncate_pagecache(inode, to, inode->i_size);
fs/fat/inode.c:		fat_truncate_blocks(inode, inode->i_size);
fs/fat/inode.c:		inode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;
fs/fat/inode.c:	struct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);
fs/fat/inode.c:	if (inode->i_ino != MSDOS_ROOT_INO) {
fs/fat/inode.c:	if (S_ISDIR(inode->i_mode) && sbi->options.nfs) {
fs/fat/inode.c:	struct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);
fs/fat/inode.c:	if (S_ISDIR(inode->i_mode) && sbi->options.nfs) {
fs/fat/inode.c:	struct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);
fs/fat/inode.c:	inode->i_size = 0;
fs/fat/inode.c:	inode->i_size = (fclus + 1) << sbi->cluster_bits;
fs/fat/inode.c:	struct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);
fs/fat/inode.c:	inode->i_uid = sbi->options.fs_uid;
fs/fat/inode.c:	inode->i_gid = sbi->options.fs_gid;
fs/fat/inode.c:	inode->i_version++;
fs/fat/inode.c:	inode->i_generation = get_seconds();
fs/fat/inode.c:		inode->i_generation &= ~1;
fs/fat/inode.c:		inode->i_mode = fat_make_mode(sbi, de->attr, S_IRWXUGO);
fs/fat/inode.c:		inode->i_op = sbi->dir_ops;
fs/fat/inode.c:		inode->i_fop = &fat_dir_operations;
fs/fat/inode.c:		MSDOS_I(inode)->mmu_private = inode->i_size;
fs/fat/inode.c:		inode->i_generation |= 1;
fs/fat/inode.c:		inode->i_mode = fat_make_mode(sbi, de->attr,
fs/fat/inode.c:		inode->i_size = le32_to_cpu(de->size);
fs/fat/inode.c:		inode->i_op = &fat_file_inode_operations;
fs/fat/inode.c:		inode->i_fop = &fat_file_operations;
fs/fat/inode.c:		inode->i_mapping->a_ops = &fat_aops;
fs/fat/inode.c:		MSDOS_I(inode)->mmu_private = inode->i_size;
fs/fat/inode.c:			inode->i_flags |= S_IMMUTABLE;
fs/fat/inode.c:	inode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))
fs/fat/inode.c:	fat_time_fat2unix(sbi, &inode->i_mtime, de->time, de->date, 0);
fs/fat/inode.c:		fat_time_fat2unix(sbi, &inode->i_ctime, de->ctime,
fs/fat/inode.c:		fat_time_fat2unix(sbi, &inode->i_atime, 0, de->adate, 0);
fs/fat/inode.c:		inode->i_ctime = inode->i_atime = inode->i_mtime;
fs/fat/inode.c:	inode->i_ino = iunique(sb, MSDOS_ROOT_INO);
fs/fat/inode.c:	inode->i_version = 1;
fs/fat/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/fat/inode.c:	if (!inode->i_nlink) {
fs/fat/inode.c:		inode->i_size = 0;
fs/fat/inode.c:	call_rcu(&inode->i_rcu, fat_i_callback);
fs/fat/inode.c:	struct super_block *sb = inode->i_sb;
fs/fat/inode.c:	if (inode->i_ino == MSDOS_ROOT_INO)
fs/fat/inode.c:	if (S_ISDIR(inode->i_mode))
fs/fat/inode.c:		raw_entry->size = cpu_to_le32(inode->i_size);
fs/fat/inode.c:	fat_time_unix2fat(sbi, &inode->i_mtime, &raw_entry->time,
fs/fat/inode.c:		fat_time_unix2fat(sbi, &inode->i_ctime, &raw_entry->ctime,
fs/fat/inode.c:		fat_time_unix2fat(sbi, &inode->i_atime, &atime,
fs/fat/inode.c:	if (inode->i_ino == MSDOS_FSINFO_INO) {
fs/fat/inode.c:		struct super_block *sb = inode->i_sb;
fs/fat/inode.c:	struct super_block *sb = inode->i_sb;
fs/fat/inode.c:	inode->i_uid = sbi->options.fs_uid;
fs/fat/inode.c:	inode->i_gid = sbi->options.fs_gid;
fs/fat/inode.c:	inode->i_version++;
fs/fat/inode.c:	inode->i_generation = 0;
fs/fat/inode.c:	inode->i_mode = fat_make_mode(sbi, ATTR_DIR, S_IRWXUGO);
fs/fat/inode.c:	inode->i_op = sbi->dir_ops;
fs/fat/inode.c:	inode->i_fop = &fat_dir_operations;
fs/fat/inode.c:		inode->i_size = sbi->dir_entries * sizeof(struct msdos_dir_entry);
fs/fat/inode.c:	inode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))
fs/fat/inode.c:	MSDOS_I(inode)->mmu_private = inode->i_size;
fs/fat/inode.c:	inode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec = 0;
fs/fat/inode.c:	inode->i_mtime.tv_nsec = inode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = 0;
fs/fat/inode.c:	fsinfo_inode->i_ino = MSDOS_FSINFO_INO;
fs/fat/inode.c:	root_inode->i_ino = MSDOS_ROOT_INO;
fs/fat/inode.c:	root_inode->i_version = 1;
fs/fat/inode.c:		ret = filemap_fdatawrite(inode->i_mapping);
fs/fat/inode.c:		struct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;
fs/fat/misc.c:	struct super_block *sb = inode->i_sb;
fs/fat/misc.c:		if (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode)) {
fs/fat/misc.c:	if (new_fclus != (inode->i_blocks >> (sbi->cluster_bits - 9))) {
fs/fat/misc.c:			     (llu)(inode->i_blocks >> (sbi->cluster_bits - 9)));
fs/fat/misc.c:	inode->i_blocks += nr_cluster << (sbi->cluster_bits - 9);
fs/fat/nfs.c:	if (inode && generation && (inode->i_generation != generation)) {
fs/fat/nfs.c: * On entry, the caller holds child_dir->d_inode->i_mutex.
fs/fat/fatent.c:	struct super_block *sb = inode->i_sb;
fs/fat/fatent.c:	struct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);
fs/fat/fatent.c:	struct super_block *sb = inode->i_sb;
fs/fat/fatent.c:	struct super_block *sb = inode->i_sb;
fs/fat/fatent.c:	struct super_block *sb = inode->i_sb;
fs/fat/cache.c:	struct super_block *sb = inode->i_sb;
fs/fat/cache.c:	struct super_block *sb = inode->i_sb;
fs/fat/cache.c:	struct super_block *sb = inode->i_sb;
fs/fat/cache.c:	if ((sbi->fat_bits != 32) && (inode->i_ino == MSDOS_ROOT_INO)) {
fs/fat/dir.c:	struct super_block *sb = inode->i_sb;
fs/fat/dir.c:	struct super_block *sb = inode->i_sb;
fs/fat/dir.c:	if (inode->i_ino == MSDOS_ROOT_INO) {
fs/fat/dir.c:		inum = inode->i_ino;
fs/fat/dir.c:	mutex_lock(&inode->i_mutex);
fs/fat/dir.c:	mutex_unlock(&inode->i_mutex);
fs/fat/namei_msdos.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = ts;
fs/fat/namei_msdos.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/fat/namei_msdos.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = ts;
fs/fat/namei_msdos.c:	struct super_block *sb = inode->i_sb;
fs/fat/namei_msdos.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/fat/namei_msdos.c:	is_dir = S_ISDIR(old_inode->i_mode);
fs/fat/namei_msdos.c:		new_inode->i_ctime = ts;
fs/fat/namei_vfat.c:	if (dentry->d_time != dentry->d_parent->d_inode->i_version)
fs/fat/namei_vfat.c:		if (!S_ISDIR(inode->i_mode))
fs/fat/namei_vfat.c:	dentry->d_time = dentry->d_parent->d_inode->i_version;
fs/fat/namei_vfat.c:		dentry->d_time = dentry->d_parent->d_inode->i_version;
fs/fat/namei_vfat.c:	inode->i_version++;
fs/fat/namei_vfat.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = ts;
fs/fat/namei_vfat.c:	dentry->d_time = dentry->d_parent->d_inode->i_version;
fs/fat/namei_vfat.c:	inode->i_mtime = inode->i_atime = CURRENT_TIME_SEC;
fs/fat/namei_vfat.c:	inode->i_mtime = inode->i_atime = CURRENT_TIME_SEC;
fs/fat/namei_vfat.c:	inode->i_version++;
fs/fat/namei_vfat.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = ts;
fs/fat/namei_vfat.c:	dentry->d_time = dentry->d_parent->d_inode->i_version;
fs/fat/namei_vfat.c:	is_dir = S_ISDIR(old_inode->i_mode);
fs/fat/namei_vfat.c:		new_inode->i_ctime = ts;
fs/fat/file.c:	mutex_lock(&inode->i_mutex);
fs/fat/file.c:	mutex_unlock(&inode->i_mutex);
fs/fat/file.c:	struct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);
fs/fat/file.c:	int is_dir = S_ISDIR(inode->i_mode);
fs/fat/file.c:	mutex_lock(&inode->i_mutex);
fs/fat/file.c:	ia.ia_ctime = current_fs_time(inode->i_sb);
fs/fat/file.c:			S_IRUGO | S_IWUGO | (inode->i_mode & S_IXUGO));
fs/fat/file.c:	if (inode->i_ino == MSDOS_ROOT_INO && attr != ATTR_DIR) {
fs/fat/file.c:			inode->i_flags |= S_IMMUTABLE;
fs/fat/file.c:			inode->i_flags &= ~S_IMMUTABLE;
fs/fat/file.c:	mutex_unlock(&inode->i_mutex);
fs/fat/file.c:	     MSDOS_SB(inode->i_sb)->options.flush) {
fs/fat/file.c:		fat_flush_inodes(inode->i_sb, inode, NULL);
fs/fat/file.c:	err = sync_mapping_buffers(MSDOS_SB(inode->i_sb)->fat_inode->i_mapping);
fs/fat/file.c:	struct address_space *mapping = inode->i_mapping;
fs/fat/file.c:	loff_t start = inode->i_size, count = size - inode->i_size;
fs/fat/file.c:	inode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;
fs/fat/file.c:	struct super_block *sb = inode->i_sb;
fs/fat/file.c:	inode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;
fs/fat/file.c:	inode->i_blocks = skip << (MSDOS_SB(sb)->cluster_bits - 9);
fs/fat/file.c:	struct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);
fs/fat/file.c:	fat_flush_inodes(inode->i_sb, inode, NULL);
fs/fat/file.c:	stat->blksize = MSDOS_SB(inode->i_sb)->cluster_size;
fs/fat/file.c:	if (S_ISREG(inode->i_mode))
fs/fat/file.c:	if ((perm & (S_IRUGO | S_IXUGO)) != (inode->i_mode & (S_IRUGO|S_IXUGO)))
fs/fat/file.c:	if (!uid_eq(current_fsuid(), inode->i_uid)) {
fs/fat/file.c:		if (in_group_p(inode->i_gid))
fs/fat/file.c:		if (attr->ia_size > inode->i_size) {
fs/fat/fat.h:	struct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);
fs/fat/fat.h:	if (S_ISDIR(inode->i_mode)) {
fs/fat/fat.h:	if (S_ISDIR(inode->i_mode))
fs/fat/fat.h:	if (fat_mode_can_hold_ro(inode) && !(inode->i_mode & S_IWUGO))
fs/nfsd/nfs3acl.c:			acl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);
fs/nfsd/nfs4state.c:	for (flpp = &inode->i_flock; *flpp != NULL; flpp = &(*flpp)->fl_next) {
fs/nfsd/nfs4recover.c:	mutex_lock(&dir->d_inode->i_mutex);
fs/nfsd/nfs4recover.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/nfsd/nfs4recover.c:	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
fs/nfsd/nfs4recover.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/nfsd/nfs4recover.c:	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
fs/nfsd/nfs4recover.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/nfsd/nfs4recover.c:	if (S_ISDIR(path.dentry->d_inode->i_mode)) {
fs/nfsd/nfs4recover.c:		status = S_ISDIR(path.dentry->d_inode->i_mode);
fs/nfsd/nfs4proc.c:	umode_t mode = fh->fh_dentry->d_inode->i_mode;
fs/nfsd/nfs4proc.c:                  (S_ISDIR(cstate->save_fh.fh_dentry->d_inode->i_mode) &&
fs/nfsd/nfs4proc.c:                   S_ISDIR(cstate->current_fh.fh_dentry->d_inode->i_mode)))
fs/nfsd/vfs.c:	if (!S_ISREG(inode->i_mode))
fs/nfsd/vfs.c:	const struct export_operations *export_ops = inode->i_sb->s_export_op;
fs/nfsd/vfs.c:	if (S_ISLNK(inode->i_mode))
fs/nfsd/vfs.c:		if (iap->ia_size < inode->i_size) {
fs/nfsd/vfs.c:		iap->ia_mode |= (inode->i_mode & ~S_IALLUGO);
fs/nfsd/vfs.c:	if (!S_ISDIR(inode->i_mode) &&
fs/nfsd/vfs.c:	    (((iap->ia_valid & ATTR_UID) && iap->ia_uid != inode->i_uid) ||
fs/nfsd/vfs.c:	     ((iap->ia_valid & ATTR_GID) && iap->ia_gid != inode->i_gid))) {
fs/nfsd/vfs.c:	if (!check_guard || guardtime == inode->i_ctime.tv_sec) {
fs/nfsd/vfs.c:	if (S_ISDIR(inode->i_mode))
fs/nfsd/vfs.c:	if (S_ISDIR(inode->i_mode))
fs/nfsd/vfs.c:		pacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);
fs/nfsd/vfs.c:	if (S_ISDIR(inode->i_mode)) {
fs/nfsd/vfs.c:	if (inode->i_mode & S_IXUGO)
fs/nfsd/vfs.c:	if (!(inode->i_mode & S_ISVTX))
fs/nfsd/vfs.c:	if (S_ISREG(dentry->d_inode->i_mode))
fs/nfsd/vfs.c:	else if (S_ISDIR(dentry->d_inode->i_mode))
fs/nfsd/vfs.c:	if (!inode->i_fop)
fs/nfsd/vfs.c:	mutex_lock(&dentry->d_inode->i_mutex);
fs/nfsd/vfs.c:	mutex_unlock(&dentry->d_inode->i_mutex);
fs/nfsd/vfs.c:	if (atomic_read(&inode->i_writecount) > 1
fs/nfsd/vfs.c:	    || (last_ino == inode->i_ino && last_dev == inode->i_sb->s_dev)) {
fs/nfsd/vfs.c:	if (inode->i_state & I_DIRTY) {
fs/nfsd/vfs.c:	last_ino = inode->i_ino;
fs/nfsd/vfs.c:	last_dev = inode->i_sb->s_dev;
fs/nfsd/vfs.c:	if (inode->i_mode & (S_ISUID | S_ISGID))
fs/nfsd/vfs.c:	ra = nfsd_get_raparms(inode->i_sb->s_dev, inode->i_ino);
fs/nfsd/vfs.c:			if (! S_ISREG(dchild->d_inode->i_mode))
fs/nfsd/vfs.c:			if (   dchild->d_inode->i_mtime.tv_sec == v_mtime
fs/nfsd/vfs.c:			    && dchild->d_inode->i_atime.tv_sec == v_atime
fs/nfsd/vfs.c:			    && dchild->d_inode->i_size  == 0 ) {
fs/nfsd/vfs.c:			if (   dchild->d_inode->i_mtime.tv_sec == v_mtime
fs/nfsd/vfs.c:			    && dchild->d_inode->i_atime.tv_sec == v_atime
fs/nfsd/vfs.c:			    && dchild->d_inode->i_size  == 0 ) {
fs/nfsd/vfs.c:	if (!inode->i_op->readlink)
fs/nfsd/vfs.c:	host_err = inode->i_op->readlink(path.dentry, (char __user *)buf, *lenp);
fs/nfsd/vfs.c:	if (S_ISDIR(tfhp->fh_dentry->d_inode->i_mode))
fs/nfsd/vfs.c:		type = rdentry->d_inode->i_mode & S_IFMT;
fs/nfsd/vfs.c:		host_err = mutex_lock_killable(&dir_inode->i_mutex);
fs/nfsd/vfs.c:		mutex_unlock(&dir_inode->i_mutex);
fs/nfsd/vfs.c:		inode->i_mode,
fs/nfsd/vfs.c:		inode->i_uid, inode->i_gid, current_fsuid(), current_fsgid());
fs/nfsd/vfs.c:	    inode->i_uid == current_fsuid())
fs/nfsd/vfs.c:	if (err == -EACCES && S_ISREG(inode->i_mode) &&
fs/nfsd/vfs.c:	    !inode->i_op->setxattr || !inode->i_op->removexattr)
fs/nfsd/vfs.c:		if (!S_ISDIR(inode->i_mode) && type == ACL_TYPE_DEFAULT)
fs/nfsd/nfsproc.c:				type = inode->i_mode & S_IFMT;
fs/nfsd/nfsproc.c:					rdev = inode->i_rdev;
fs/nfsd/nfsproc.c:		type = inode->i_mode & S_IFMT;
fs/nfsd/nfsproc.c:		mode = inode->i_mode & ~S_IFMT;
fs/nfsd/nfsproc.c:		if (inode && type != (inode->i_mode & S_IFMT))
fs/nfsd/nfs3xdr.c:				     (fhp->fh_dentry->d_inode->i_sb->s_dev));
fs/nfsd/nfs3xdr.c:	fhp->fh_post_change = fhp->fh_dentry->d_inode->i_version;
fs/nfsd/nfs3xdr.c:		fhp->fh_post_attr.ctime = fhp->fh_dentry->d_inode->i_ctime;
fs/nfsd/nfsfh.c:	if (unlikely(!S_ISDIR(dentry->d_inode->i_mode) &&
fs/nfsd/nfsfh.c:		     !S_ISLNK(dentry->d_inode->i_mode)))
fs/nfsd/nfsfh.c:	if (S_ISDIR(dentry->d_inode->i_mode) &&
fs/nfsd/nfsfh.c:	error = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);
fs/nfsd/nfsfh.c:	fh->ofh_ino = ino_t_to_u32(dentry->d_inode->i_ino);
fs/nfsd/nfsfh.c:	fh->ofh_generation = dentry->d_inode->i_generation;
fs/nfsd/nfsfh.c:	if (S_ISDIR(dentry->d_inode->i_mode) ||
fs/nfsd/nfsfh.c:	return exp->ex_path.dentry->d_inode->i_sb;
fs/nfsd/nfsfh.c:		(long) exp->ex_path.dentry->d_inode->i_ino,
fs/nfsd/nfsfh.c:		(inode ? inode->i_ino : 0));
fs/nfsd/nfsfh.c:			ino_t_to_u32(exp->ex_path.dentry->d_inode->i_ino);
fs/nfsd/nfsfh.c:			exp->ex_path.dentry->d_inode->i_ino,
fs/nfsd/nfs4xdr.c:		write64(p, inode->i_version);
fs/nfsd/nfs4xdr.c:	       read->rd_fhp->fh_dentry->d_inode->i_size);
fs/nfsd/nfsctl.c:	ino_t ino =  file->f_path.dentry->d_inode->i_ino;
fs/nfsd/fault_inject.c:		nfsd_inject_get(file->f_dentry->d_inode->i_private, &val);
fs/nfsd/fault_inject.c:		nfsd_inject_set_client(file->f_dentry->d_inode->i_private, &sa, size);
fs/nfsd/fault_inject.c:		nfsd_inject_set(file->f_dentry->d_inode->i_private, val);
fs/nfsd/nfs3proc.c:		resp->eof = (argp->offset + resp->count) >= inode->i_size;
fs/nfsd/nfs3proc.c:		struct super_block *sb = argp->fh.fh_dentry->d_inode->i_sb;
fs/nfsd/nfs3proc.c:		struct super_block *sb = argp->fh.fh_dentry->d_inode->i_sb;
fs/nfsd/export.c:	if (!S_ISDIR(inode->i_mode) &&
fs/nfsd/export.c:	    !S_ISLNK(inode->i_mode) &&
fs/nfsd/export.c:	    !S_ISREG(inode->i_mode))
fs/nfsd/export.c:	if (!(inode->i_sb->s_type->fs_flags & FS_REQUIRES_DEV) &&
fs/nfsd/export.c:	if (!inode->i_sb->s_export_op ||
fs/nfsd/export.c:	    !inode->i_sb->s_export_op->fh_to_dentry) {
fs/nfsd/export.c:		 inode->i_sb->s_id, inode->i_ino);
fs/nfsd/nfs2acl.c:			acl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);
fs/nfsd/nfsfh.h:		fhp->fh_pre_mtime = inode->i_mtime;
fs/nfsd/nfsfh.h:		fhp->fh_pre_ctime = inode->i_ctime;
fs/nfsd/nfsfh.h:		fhp->fh_pre_size  = inode->i_size;
fs/nfsd/nfsfh.h:		fhp->fh_pre_change = inode->i_version;
fs/nfsd/nfsfh.h:	mutex_lock_nested(&inode->i_mutex, subclass);
fs/nfsd/nfsfh.h:		mutex_unlock(&fhp->fh_dentry->d_inode->i_mutex);
fs/mpage.c:		if (inode->i_blkbits == PAGE_CACHE_SHIFT && 
fs/mpage.c:		create_empty_buffers(page, 1 << inode->i_blkbits, 0);
fs/mpage.c:	const unsigned blkbits = inode->i_blkbits;
fs/mpage.c:	const unsigned blkbits = inode->i_blkbits;
fs/fifo.c:		pipe_wait(inode->i_pipe);
fs/fifo.c:	wake_up_interruptible(&inode->i_pipe->wait);
fs/fifo.c:	mutex_lock(&inode->i_mutex);
fs/fifo.c:	pipe = inode->i_pipe;
fs/fifo.c:		inode->i_pipe = pipe;
fs/fifo.c:	mutex_unlock(&inode->i_mutex);
fs/fifo.c:	mutex_unlock(&inode->i_mutex);
fs/ecryptfs/mmap.c:	struct page *page = read_mapping_page(inode->i_mapping, index, NULL);
fs/ecryptfs/mmap.c:	if (!lower_inode->i_op->getxattr || !lower_inode->i_op->setxattr) {
fs/ecryptfs/mmap.c:	mutex_lock(&lower_inode->i_mutex);
fs/ecryptfs/mmap.c:	size = lower_inode->i_op->getxattr(lower_dentry, ECRYPTFS_XATTR_NAME,
fs/ecryptfs/mmap.c:	rc = lower_inode->i_op->setxattr(lower_dentry, ECRYPTFS_XATTR_NAME,
fs/ecryptfs/mmap.c:	mutex_unlock(&lower_inode->i_mutex);
fs/ecryptfs/mmap.c:	if (lower_inode->i_mapping->a_ops->bmap)
fs/ecryptfs/mmap.c:		rc = lower_inode->i_mapping->a_ops->bmap(lower_inode->i_mapping,
fs/ecryptfs/inode.c:	mutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);
fs/ecryptfs/inode.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/ecryptfs/inode.c:	inode->i_ino = lower_inode->i_ino;
fs/ecryptfs/inode.c:	inode->i_version++;
fs/ecryptfs/inode.c:	inode->i_mapping->a_ops = &ecryptfs_aops;
fs/ecryptfs/inode.c:	inode->i_mapping->backing_dev_info = inode->i_sb->s_bdi;
fs/ecryptfs/inode.c:	if (S_ISLNK(inode->i_mode))
fs/ecryptfs/inode.c:		inode->i_op = &ecryptfs_symlink_iops;
fs/ecryptfs/inode.c:	else if (S_ISDIR(inode->i_mode))
fs/ecryptfs/inode.c:		inode->i_op = &ecryptfs_dir_iops;
fs/ecryptfs/inode.c:		inode->i_op = &ecryptfs_main_iops;
fs/ecryptfs/inode.c:	if (S_ISDIR(inode->i_mode))
fs/ecryptfs/inode.c:		inode->i_fop = &ecryptfs_dir_fops;
fs/ecryptfs/inode.c:	else if (special_file(inode->i_mode))
fs/ecryptfs/inode.c:		init_special_inode(inode, inode->i_mode, inode->i_rdev);
fs/ecryptfs/inode.c:		inode->i_fop = &ecryptfs_main_fops;
fs/ecryptfs/inode.c:	if (lower_inode->i_sb != ecryptfs_superblock_to_lower(sb))
fs/ecryptfs/inode.c:	if (!(inode->i_state & I_NEW))
fs/ecryptfs/inode.c:	if (!IS_ERR(inode) && (inode->i_state & I_NEW))
fs/ecryptfs/inode.c:	inode->i_ctime = dir->i_ctime;
fs/ecryptfs/inode.c:				     directory_inode->i_sb);
fs/ecryptfs/inode.c:	if (S_ISDIR(ecryptfs_inode->i_mode)) {
fs/ecryptfs/inode.c:	inode = __ecryptfs_get_inode(lower_inode, dir_inode->i_sb);
fs/ecryptfs/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/ecryptfs/inode.c:	if (inode->i_state & I_NEW)
fs/ecryptfs/inode.c:	mutex_lock(&lower_dir_dentry->d_inode->i_mutex);
fs/ecryptfs/inode.c:	mutex_unlock(&lower_dir_dentry->d_inode->i_mutex);
fs/ecryptfs/inode.c:	mutex_lock(&lower_dir_dentry->d_inode->i_mutex);
fs/ecryptfs/inode.c:	mutex_unlock(&lower_dir_dentry->d_inode->i_mutex);
fs/ecryptfs/inode.c:	set_nlink(dir, lower_dir_dentry->d_inode->i_nlink);
fs/ecryptfs/inode.c:	set_nlink(dir, lower_dir_dentry->d_inode->i_nlink);
fs/ecryptfs/inode.c:	rc = lower_dentry->d_inode->i_op->readlink(lower_dentry,
fs/ecryptfs/inode.c:		mutex_lock(&lower_dentry->d_inode->i_mutex);
fs/ecryptfs/inode.c:		mutex_unlock(&lower_dentry->d_inode->i_mutex);
fs/ecryptfs/inode.c:	if (S_ISDIR(dentry->d_inode->i_mode))
fs/ecryptfs/inode.c:	else if (S_ISREG(dentry->d_inode->i_mode)
fs/ecryptfs/inode.c:	mutex_lock(&lower_dentry->d_inode->i_mutex);
fs/ecryptfs/inode.c:	mutex_unlock(&lower_dentry->d_inode->i_mutex);
fs/ecryptfs/inode.c:	if (!lower_dentry->d_inode->i_op->setxattr) {
fs/ecryptfs/inode.c:	if (!lower_dentry->d_inode->i_op->getxattr) {
fs/ecryptfs/inode.c:	mutex_lock(&lower_dentry->d_inode->i_mutex);
fs/ecryptfs/inode.c:	rc = lower_dentry->d_inode->i_op->getxattr(lower_dentry, name, value,
fs/ecryptfs/inode.c:	mutex_unlock(&lower_dentry->d_inode->i_mutex);
fs/ecryptfs/inode.c:	if (!lower_dentry->d_inode->i_op->listxattr) {
fs/ecryptfs/inode.c:	mutex_lock(&lower_dentry->d_inode->i_mutex);
fs/ecryptfs/inode.c:	rc = lower_dentry->d_inode->i_op->listxattr(lower_dentry, list, size);
fs/ecryptfs/inode.c:	mutex_unlock(&lower_dentry->d_inode->i_mutex);
fs/ecryptfs/inode.c:	if (!lower_dentry->d_inode->i_op->removexattr) {
fs/ecryptfs/inode.c:	mutex_lock(&lower_dentry->d_inode->i_mutex);
fs/ecryptfs/inode.c:	rc = lower_dentry->d_inode->i_op->removexattr(lower_dentry, name);
fs/ecryptfs/inode.c:	mutex_unlock(&lower_dentry->d_inode->i_mutex);
fs/ecryptfs/crypto.c:		    ecryptfs_inode->i_sb)->mount_crypt_stat;
fs/ecryptfs/crypto.c:		&ecryptfs_superblock_to_private(inode->i_sb)->mount_crypt_stat;
fs/ecryptfs/crypto.c:				ecryptfs_inode->i_ino);
fs/ecryptfs/crypto.c:				ecryptfs_inode->i_ino);
fs/ecryptfs/crypto.c:				ecryptfs_inode->i_ino);
fs/ecryptfs/super.c:	call_rcu(&inode->i_rcu, ecryptfs_i_callback);
fs/ecryptfs/super.c:	truncate_inode_pages(&inode->i_data, 0);
fs/ecryptfs/file.c:						inode->i_sb)->mount_crypt_stat;
fs/ecryptfs/file.c:	if (S_ISDIR(ecryptfs_dentry->d_inode->i_mode)) {
fs/ecryptfs/file.c:			"[0x%.16lx] size: [0x%.16llx]\n", inode, inode->i_ino,
fs/ecryptfs/main.c:		filemap_write_and_wait(inode->i_mapping);
fs/ecryptfs/main.c:	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
fs/qnx4/inode.c:	QNX4DEBUG((KERN_INFO "qnx4: qnx4_get_block inode=[%ld] iblock=[%ld]\n",inode->i_ino,iblock));
fs/qnx4/inode.c:		map_bh(bh, inode->i_sb, phys);
fs/qnx4/inode.c:	u16 nxtnt = le16_to_cpu(qnx4_inode->di_num_xtnts);
fs/qnx4/inode.c:	u32 block = try_extent(&qnx4_inode->di_first_xtnt, &offset);
fs/qnx4/inode.c:		i_xblk = le32_to_cpu(qnx4_inode->di_xblk);
fs/qnx4/inode.c:				bh = sb_bread(inode->i_sb, i_xblk - 1);
fs/qnx4/inode.c:					QNX4DEBUG((KERN_ERR "qnx4: block at %ld is not a valid xtnt\n", qnx4_inode->i_xblk));
fs/qnx4/inode.c:	QNX4DEBUG((KERN_INFO "qnx4: mapping block %ld of inode %ld = %ld\n",iblock,inode->i_ino,block));
fs/qnx4/inode.c:	if (!(inode->i_state & I_NEW))
fs/qnx4/inode.c:	inode->i_mode = 0;
fs/qnx4/inode.c:	inode->i_mode    = le16_to_cpu(raw_inode->di_mode);
fs/qnx4/inode.c:	i_uid_write(inode, (uid_t)le16_to_cpu(raw_inode->di_uid));
fs/qnx4/inode.c:	i_gid_write(inode, (gid_t)le16_to_cpu(raw_inode->di_gid));
fs/qnx4/inode.c:	set_nlink(inode, le16_to_cpu(raw_inode->di_nlink));
fs/qnx4/inode.c:	inode->i_size    = le32_to_cpu(raw_inode->di_size);
fs/qnx4/inode.c:	inode->i_mtime.tv_sec   = le32_to_cpu(raw_inode->di_mtime);
fs/qnx4/inode.c:	inode->i_mtime.tv_nsec = 0;
fs/qnx4/inode.c:	inode->i_atime.tv_sec   = le32_to_cpu(raw_inode->di_atime);
fs/qnx4/inode.c:	inode->i_atime.tv_nsec = 0;
fs/qnx4/inode.c:	inode->i_ctime.tv_sec   = le32_to_cpu(raw_inode->di_ctime);
fs/qnx4/inode.c:	inode->i_ctime.tv_nsec = 0;
fs/qnx4/inode.c:	inode->i_blocks  = le32_to_cpu(raw_inode->di_first_xtnt.xtnt_size);
fs/qnx4/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/qnx4/inode.c:		inode->i_fop = &generic_ro_fops;
fs/qnx4/inode.c:		inode->i_mapping->a_ops = &qnx4_aops;
fs/qnx4/inode.c:		qnx4_i(inode)->mmu_private = inode->i_size;
fs/qnx4/inode.c:	} else if (S_ISDIR(inode->i_mode)) {
fs/qnx4/inode.c:		inode->i_op = &qnx4_dir_inode_operations;
fs/qnx4/inode.c:		inode->i_fop = &qnx4_dir_operations;
fs/qnx4/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/qnx4/inode.c:		inode->i_op = &page_symlink_inode_operations;
fs/qnx4/inode.c:		inode->i_mapping->a_ops = &qnx4_aops;
fs/qnx4/inode.c:		qnx4_i(inode)->mmu_private = inode->i_size;
fs/qnx4/inode.c:	call_rcu(&inode->i_rcu, qnx4_i_callback);
fs/qnx4/dir.c:	QNX4DEBUG((KERN_INFO "qnx4_readdir:i_size = %ld\n", (long) inode->i_size));
fs/qnx4/dir.c:	while (filp->f_pos < inode->i_size) {
fs/qnx4/dir.c:		bh = sb_bread(inode->i_sb, blknum);
fs/proc/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/proc/inode.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
fs/proc/inode.c:	call_rcu(&inode->i_rcu, proc_i_callback);
fs/proc/inode.c:		inode->i_ino = de->low_ino;
fs/proc/inode.c:		inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
fs/proc/inode.c:			inode->i_mode = de->mode;
fs/proc/inode.c:			inode->i_uid = de->uid;
fs/proc/inode.c:			inode->i_gid = de->gid;
fs/proc/inode.c:			inode->i_size = de->size;
fs/proc/inode.c:			inode->i_op = de->proc_iops;
fs/proc/inode.c:			if (S_ISREG(inode->i_mode)) {
fs/proc/inode.c:					inode->i_fop =
fs/proc/inode.c:					inode->i_fop = &proc_reg_file_ops;
fs/proc/inode.c:				inode->i_fop = de->proc_fops;
fs/proc/array.c:	pid = pid_nr_ns(v, inode->i_sb->s_fs_info);
fs/proc/task_mmu.c:		dev = inode->i_sb->s_dev;
fs/proc/task_mmu.c:		ino = inode->i_ino;
fs/proc/fd.c:					inode->i_uid = cred->euid;
fs/proc/fd.c:					inode->i_gid = cred->egid;
fs/proc/fd.c:					inode->i_uid = GLOBAL_ROOT_UID;
fs/proc/fd.c:					inode->i_gid = GLOBAL_ROOT_GID;
fs/proc/fd.c:				if (S_ISLNK(inode->i_mode)) {
fs/proc/fd.c:					inode->i_mode = i_mode;
fs/proc/fd.c:	inode->i_mode = S_IFLNK;
fs/proc/fd.c:	inode->i_op = &proc_pid_link_inode_operations;
fs/proc/fd.c:	inode->i_size = 64;
fs/proc/fd.c:			if (filldir(dirent, ".", 1, 0, inode->i_ino, DT_DIR) < 0)
fs/proc/fd.c:	inode->i_mode = S_IFREG | S_IRUSR;
fs/proc/fd.c:	inode->i_fop = &proc_fdinfo_file_operations;
fs/proc/generic.c:	de->uid = inode->i_uid;
fs/proc/generic.c:	de->gid = inode->i_gid;
fs/proc/generic.c:	de->mode = inode->i_mode;
fs/proc/generic.c:	ino = inode->i_ino;
fs/proc/nommu.c:		dev = inode->i_sb->s_dev;
fs/proc/nommu.c:		ino = inode->i_ino;
fs/proc/namespaces.c:		ns_ops->name, inode->i_ino);
fs/proc/namespaces.c:	if (inode->i_state & I_NEW) {
fs/proc/namespaces.c:		inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
fs/proc/namespaces.c:		inode->i_op = &ns_inode_operations;
fs/proc/namespaces.c:		inode->i_mode = S_IFREG | S_IRUGO;
fs/proc/namespaces.c:		inode->i_fop = &ns_file_operations;
fs/proc/namespaces.c:	struct super_block *sb = inode->i_sb;
fs/proc/namespaces.c:	inode->i_mode = S_IFLNK|S_IRWXUGO;
fs/proc/namespaces.c:	inode->i_op = &proc_ns_link_inode_operations;
fs/proc/namespaces.c:		ino = inode->i_ino;
fs/proc/namespaces.c:	return inode->i_fop == &ns_file_operations;
fs/proc/base.c:	struct pid_namespace *pid = inode->i_sb->s_fs_info;
fs/proc/base.c:	ns = inode->i_sb->s_fs_info;
fs/proc/base.c:	inode->i_ino = get_next_ino();
fs/proc/base.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
fs/proc/base.c:	inode->i_op = &proc_def_inode_operations;
fs/proc/base.c:		inode->i_uid = cred->euid;
fs/proc/base.c:		inode->i_gid = cred->egid;
fs/proc/base.c:		if ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||
fs/proc/base.c:		if ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||
fs/proc/base.c:			inode->i_uid = cred->euid;
fs/proc/base.c:			inode->i_gid = cred->egid;
fs/proc/base.c:			inode->i_uid = GLOBAL_ROOT_UID;
fs/proc/base.c:			inode->i_gid = GLOBAL_ROOT_GID;
fs/proc/base.c:		inode->i_mode &= ~(S_ISUID | S_ISGID);
fs/proc/base.c:		ino = inode->i_ino;
fs/proc/base.c:		type = inode->i_mode >> 12;
fs/proc/base.c:			inode->i_uid = cred->euid;
fs/proc/base.c:			inode->i_gid = cred->egid;
fs/proc/base.c:			inode->i_uid = GLOBAL_ROOT_UID;
fs/proc/base.c:			inode->i_gid = GLOBAL_ROOT_GID;
fs/proc/base.c:	inode->i_op = &proc_pid_link_inode_operations;
fs/proc/base.c:	inode->i_size = 64;
fs/proc/base.c:	inode->i_mode = S_IFLNK;
fs/proc/base.c:		inode->i_mode |= S_IRUSR;
fs/proc/base.c:		inode->i_mode |= S_IWUSR;
fs/proc/base.c:		ino = inode->i_ino;
fs/proc/base.c:	inode->i_mode = p->mode;
fs/proc/base.c:	if (S_ISDIR(inode->i_mode))
fs/proc/base.c:		inode->i_op = p->iop;
fs/proc/base.c:		inode->i_fop = p->fop;
fs/proc/base.c:		ino = inode->i_ino;
fs/proc/base.c:	inode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;
fs/proc/base.c:	inode->i_op = &proc_tgid_base_inode_operations;
fs/proc/base.c:	inode->i_fop = &proc_tgid_base_operations;
fs/proc/base.c:	inode->i_flags|=S_IMMUTABLE;
fs/proc/base.c:	inode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;
fs/proc/base.c:	inode->i_op = &proc_tid_base_inode_operations;
fs/proc/base.c:	inode->i_fop = &proc_tid_base_operations;
fs/proc/base.c:	inode->i_flags|=S_IMMUTABLE;
fs/proc/base.c:		ino = inode->i_ino;
fs/proc/task_nommu.c:		dev = inode->i_sb->s_dev;
fs/proc/task_nommu.c:		ino = inode->i_ino;
fs/proc/proc_sysctl.c:	inode->i_ino = get_next_ino();
fs/proc/proc_sysctl.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
fs/proc/proc_sysctl.c:	inode->i_mode = table->mode;
fs/proc/proc_sysctl.c:		inode->i_mode |= S_IFREG;
fs/proc/proc_sysctl.c:		inode->i_op = &proc_sys_inode_operations;
fs/proc/proc_sysctl.c:		inode->i_fop = &proc_sys_file_operations;
fs/proc/proc_sysctl.c:		inode->i_mode |= S_IFDIR;
fs/proc/proc_sysctl.c:		inode->i_op = &proc_sys_dir_operations;
fs/proc/proc_sysctl.c:		inode->i_fop = &proc_sys_dir_file_operations;
fs/proc/proc_sysctl.c:	ino  = inode->i_ino;
fs/proc/proc_sysctl.c:	type = inode->i_mode >> 12;
fs/proc/proc_sysctl.c:				inode->i_ino, DT_DIR) < 0)
fs/proc/proc_sysctl.c:	if ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))
fs/proc/kcore.c:		mutex_lock(&inode->i_mutex);
fs/proc/kcore.c:		mutex_unlock(&inode->i_mutex);
fs/quota/dquot.c: * inode-subsystem with added complexity of the diskquota system.
fs/quota/dquot.c: * also guards consistency of dquot->dq_dqb with inode->i_blocks, i_bytes.
fs/quota/dquot.c:		return !inode->i_dquot[type];
fs/quota/dquot.c:		if (!inode->i_dquot[cnt])
fs/quota/dquot.c:		spin_lock(&inode->i_lock);
fs/quota/dquot.c:		if ((inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) ||
fs/quota/dquot.c:		    !atomic_read(&inode->i_writecount) ||
fs/quota/dquot.c:			spin_unlock(&inode->i_lock);
fs/quota/dquot.c:		spin_unlock(&inode->i_lock);
fs/quota/dquot.c:	struct dquot *dquot = inode->i_dquot[type];
fs/quota/dquot.c:	inode->i_dquot[type] = NULL;
fs/quota/dquot.c:				quota_error(inode->i_sb, "Adding dquot with "
fs/quota/dquot.c:	struct super_block *sb = inode->i_sb;
fs/quota/dquot.c:	struct super_block *sb = inode->i_sb;
fs/quota/dquot.c:			qid = make_kqid_uid(inode->i_uid);
fs/quota/dquot.c:			qid = make_kqid_gid(inode->i_gid);
fs/quota/dquot.c:		if (!inode->i_dquot[cnt]) {
fs/quota/dquot.c:			inode->i_dquot[cnt] = got[cnt];
fs/quota/dquot.c:				dquot_resv_space(inode->i_dquot[cnt], rsv);
fs/quota/dquot.c:	down_write(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:		put[cnt] = inode->i_dquot[cnt];
fs/quota/dquot.c:		inode->i_dquot[cnt] = NULL;
fs/quota/dquot.c:	up_write(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:		if (inode->i_dquot[cnt])
fs/quota/dquot.c:	BUG_ON(!inode->i_sb->dq_op->get_reserved_space);
fs/quota/dquot.c:	return inode->i_sb->dq_op->get_reserved_space(inode);
fs/quota/dquot.c:	spin_lock(&inode->i_lock);
fs/quota/dquot.c:	spin_unlock(&inode->i_lock);
fs/quota/dquot.c:	spin_lock(&inode->i_lock);
fs/quota/dquot.c:	spin_unlock(&inode->i_lock);
fs/quota/dquot.c:	spin_lock(&inode->i_lock);
fs/quota/dquot.c:	spin_unlock(&inode->i_lock);
fs/quota/dquot.c:	if (!inode->i_sb->dq_op->get_reserved_space)
fs/quota/dquot.c:	spin_lock(&inode->i_lock);
fs/quota/dquot.c:	spin_unlock(&inode->i_lock);
fs/quota/dquot.c:	struct dquot **dquots = inode->i_dquot;
fs/quota/dquot.c:	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:	struct dquot * const *dquots = inode->i_dquot;
fs/quota/dquot.c:	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:		if (inode->i_dquot[cnt])
fs/quota/dquot.c:			dquot_claim_reserved_space(inode->i_dquot[cnt],
fs/quota/dquot.c:	mark_all_dquot_dirty(inode->i_dquot);
fs/quota/dquot.c:	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:	struct dquot **dquots = inode->i_dquot;
fs/quota/dquot.c:	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:	struct dquot * const *dquots = inode->i_dquot;
fs/quota/dquot.c:	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:	down_write(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:		up_write(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:		if (!sb_has_quota_active(inode->i_sb, cnt))
fs/quota/dquot.c:		transfer_from[cnt] = inode->i_dquot[cnt];
fs/quota/dquot.c:		inode->i_dquot[cnt] = transfer_to[cnt];
fs/quota/dquot.c:	up_write(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:	up_write(&sb_dqopt(inode->i_sb)->dqptr_sem);
fs/quota/dquot.c:	struct super_block *sb = inode->i_sb;
fs/quota/dquot.c:	if (iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid))
fs/quota/dquot.c:	if (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid))
fs/quota/dquot.c:	struct super_block *sb = inode->i_sb;
fs/quota/dquot.c:	if (!S_ISREG(inode->i_mode)) {
fs/quota/dquot.c:		mutex_lock(&inode->i_mutex);
fs/quota/dquot.c:		oldflags = inode->i_flags & (S_NOATIME | S_IMMUTABLE |
fs/quota/dquot.c:		inode->i_flags |= S_NOQUOTA | S_NOATIME | S_IMMUTABLE;
fs/quota/dquot.c:		mutex_unlock(&inode->i_mutex);
fs/quota/dquot.c:		mutex_lock(&inode->i_mutex);
fs/quota/dquot.c:		inode->i_flags &= ~(S_NOATIME | S_NOQUOTA | S_IMMUTABLE);
fs/quota/dquot.c:		inode->i_flags |= oldflags;
fs/quota/dquot.c:		mutex_unlock(&inode->i_mutex);
fs/quota/dquot.c:	struct super_block *sb = inode->i_sb;
fs/quota/dquot.c:	mutex_lock(&sb->s_root->d_inode->i_mutex);
fs/quota/dquot.c:	mutex_unlock(&sb->s_root->d_inode->i_mutex);
fs/hostfs/hostfs_kern.c:	truncate_inode_pages(&inode->i_data, 0);
fs/hostfs/hostfs_kern.c:	call_rcu(&inode->i_rcu, hostfs_i_callback);
fs/hostfs/hostfs_kern.c:	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/hostfs/hostfs_kern.c:	mutex_lock(&inode->i_mutex);
fs/hostfs/hostfs_kern.c:	mutex_unlock(&inode->i_mutex);
fs/hostfs/hostfs_kern.c:	int end_index = inode->i_size >> PAGE_CACHE_SHIFT;
fs/hostfs/hostfs_kern.c:		count = inode->i_size & (PAGE_CACHE_SIZE-1);
fs/hostfs/hostfs_kern.c:	if (base > inode->i_size)
fs/hostfs/hostfs_kern.c:		inode->i_size = base;
fs/hostfs/hostfs_kern.c:	if (err > 0 && (pos > inode->i_size))
fs/hostfs/hostfs_kern.c:		inode->i_size = pos;
fs/hostfs/hostfs_kern.c:	if (S_ISLNK(root_inode->i_mode)) {
fs/stat.c:	stat->dev = inode->i_sb->s_dev;
fs/stat.c:	stat->ino = inode->i_ino;
fs/stat.c:	stat->mode = inode->i_mode;
fs/stat.c:	stat->nlink = inode->i_nlink;
fs/stat.c:	stat->uid = inode->i_uid;
fs/stat.c:	stat->gid = inode->i_gid;
fs/stat.c:	stat->rdev = inode->i_rdev;
fs/stat.c:	stat->atime = inode->i_atime;
fs/stat.c:	stat->mtime = inode->i_mtime;
fs/stat.c:	stat->ctime = inode->i_ctime;
fs/stat.c:	stat->blksize = (1 << inode->i_blkbits);
fs/stat.c:	stat->blocks = inode->i_blocks;
fs/stat.c:	if (inode->i_op->getattr)
fs/stat.c:		return inode->i_op->getattr(mnt, dentry, stat);
fs/stat.c:		if (inode->i_op->readlink) {
fs/stat.c:				error = inode->i_op->readlink(path.dentry,
fs/stat.c:/* Caller is here responsible for sufficient locking (ie. inode->i_lock) */
fs/stat.c:	inode->i_blocks += bytes >> 9;
fs/stat.c:	inode->i_bytes += bytes;
fs/stat.c:	if (inode->i_bytes >= 512) {
fs/stat.c:		inode->i_blocks++;
fs/stat.c:		inode->i_bytes -= 512;
fs/stat.c:	spin_lock(&inode->i_lock);
fs/stat.c:	spin_unlock(&inode->i_lock);
fs/stat.c:	spin_lock(&inode->i_lock);
fs/stat.c:	inode->i_blocks -= bytes >> 9;
fs/stat.c:	if (inode->i_bytes < bytes) {
fs/stat.c:		inode->i_blocks--;
fs/stat.c:		inode->i_bytes += 512;
fs/stat.c:	inode->i_bytes -= bytes;
fs/stat.c:	spin_unlock(&inode->i_lock);
fs/stat.c:	spin_lock(&inode->i_lock);
fs/stat.c:	ret = (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;
fs/stat.c:	spin_unlock(&inode->i_lock);
fs/stat.c:	 * (ie. inode->i_lock) */
fs/stat.c:	inode->i_blocks = bytes >> 9;
fs/stat.c:	inode->i_bytes = bytes & 511;
fs/udf/inode.c:	if (!inode->i_nlink && !is_bad_inode(inode)) {
fs/udf/inode.c:		truncate_inode_pages(&inode->i_data, 0);
fs/udf/inode.c:	    inode->i_size != iinfo->i_lenExtents) {
fs/udf/inode.c:		udf_warn(inode->i_sb, "Inode %lu (mode %o) has inode size %llu different from extent length %llu. Filesystem need not be standards compliant.\n",
fs/udf/inode.c:			 inode->i_ino, inode->i_mode,
fs/udf/inode.c:			 (unsigned long long)inode->i_size,
fs/udf/inode.c:	loff_t isize = inode->i_size;
fs/udf/inode.c:		if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))
fs/udf/inode.c:		inode->i_data.a_ops = &udf_aops;
fs/udf/inode.c:	page = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);
fs/udf/inode.c:	if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))
fs/udf/inode.c:	inode->i_data.a_ops = &udf_aops;
fs/udf/inode.c:	err = inode->i_data.a_ops->writepage(page, &udf_wbc);
fs/udf/inode.c:		       inode->i_size);
fs/udf/inode.c:		inode->i_data.a_ops = &udf_adinicb_aops;
fs/udf/inode.c:	int size = udf_ext0_offset(inode) + inode->i_size;
fs/udf/inode.c:	if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))
fs/udf/inode.c:	if (!inode->i_size) {
fs/udf/inode.c:	*block = udf_new_block(inode->i_sb, inode,
fs/udf/inode.c:	newblock = udf_get_pblock(inode->i_sb, *block,
fs/udf/inode.c:	dbh = udf_tgetblk(inode->i_sb, newblock);
fs/udf/inode.c:	memset(dbh->b_data, 0x00, inode->i_sb->s_blocksize);
fs/udf/inode.c:			f_pos & (inode->i_sb->s_blocksize - 1);
fs/udf/inode.c:	iinfo->i_lenExtents = inode->i_size;
fs/udf/inode.c:	udf_add_aext(inode, &epos, &eloc, inode->i_size, 0);
fs/udf/inode.c:			map_bh(bh_result, inode->i_sb, phys);
fs/udf/inode.c:	map_bh(bh_result, inode->i_sb, phys);
fs/udf/inode.c:		bh = sb_getblk(inode->i_sb, dummy.b_blocknr);
fs/udf/inode.c:			memset(bh->b_data, 0x00, inode->i_sb->s_blocksize);
fs/udf/inode.c:	struct super_block *sb = inode->i_sb;
fs/udf/inode.c:	struct super_block *sb = inode->i_sb;
fs/udf/inode.c:	b_off = (loff_t)block << inode->i_sb->s_blocksize_bits;
fs/udf/inode.c:				((elen + inode->i_sb->s_blocksize - 1) >>
fs/udf/inode.c:				 inode->i_sb->s_blocksize_bits);
fs/udf/inode.c:	offset = b_off >> inode->i_sb->s_blocksize_bits;
fs/udf/inode.c:		if (elen & (inode->i_sb->s_blocksize - 1)) {
fs/udf/inode.c:				((elen + inode->i_sb->s_blocksize - 1) &
fs/udf/inode.c:				 ~(inode->i_sb->s_blocksize - 1));
fs/udf/inode.c:		newblock = udf_get_lb_pblock(inode->i_sb, &eloc, offset);
fs/udf/inode.c:				inode->i_sb->s_blocksize;
fs/udf/inode.c:		newblocknum = udf_new_block(inode->i_sb, inode,
fs/udf/inode.c:			iinfo->i_lenExtents += inode->i_sb->s_blocksize;
fs/udf/inode.c:	if (S_ISREG(inode->i_mode))
fs/udf/inode.c:	newblock = udf_get_pblock(inode->i_sb, newblocknum,
fs/udf/inode.c:	inode->i_ctime = current_fs_time(inode->i_sb);
fs/udf/inode.c:	unsigned long blocksize = inode->i_sb->s_blocksize;
fs/udf/inode.c:	unsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;
fs/udf/inode.c:				udf_free_blocks(inode->i_sb, inode,
fs/udf/inode.c:				inode->i_sb->s_blocksize - 1) >>
fs/udf/inode.c:				inode->i_sb->s_blocksize_bits);
fs/udf/inode.c:				    inode->i_sb->s_blocksize - 1) >>
fs/udf/inode.c:				    inode->i_sb->s_blocksize_bits);
fs/udf/inode.c:			  inode->i_sb->s_blocksize - 1) >>
fs/udf/inode.c:			  inode->i_sb->s_blocksize_bits);
fs/udf/inode.c:		int numalloc = udf_prealloc_blocks(inode->i_sb, inode,
fs/udf/inode.c:					 inode->i_sb->s_blocksize_bits);
fs/udf/inode.c:					 inode->i_sb->s_blocksize_bits);
fs/udf/inode.c:					    inode->i_sb->s_blocksize - 1) >>
fs/udf/inode.c:					    inode->i_sb->s_blocksize_bits;
fs/udf/inode.c:						 inode->i_sb->s_blocksize_bits);
fs/udf/inode.c:				numalloc << inode->i_sb->s_blocksize_bits;
fs/udf/inode.c:	unsigned long blocksize = inode->i_sb->s_blocksize;
fs/udf/inode.c:	unsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;
fs/udf/inode.c:			udf_free_blocks(inode->i_sb, inode, &li->extLocation, 0,
fs/udf/inode.c:			udf_free_blocks(inode->i_sb, inode,
fs/udf/inode.c:	int bsize = 1 << inode->i_blkbits;
fs/udf/inode.c:	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
fs/udf/inode.c:	      S_ISLNK(inode->i_mode)))
fs/udf/inode.c:	if (newsize > inode->i_size) {
fs/udf/inode.c:		err = block_truncate_page(inode->i_mapping, newsize,
fs/udf/inode.c:	inode->i_mtime = inode->i_ctime = current_fs_time(inode->i_sb);
fs/udf/inode.c:	bh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 0, &ident);
fs/udf/inode.c:		udf_err(inode->i_sb, "(ino %ld) failed !bh\n", inode->i_ino);
fs/udf/inode.c:		udf_err(inode->i_sb, "(ino %ld) failed ident=%d\n",
fs/udf/inode.c:			inode->i_ino, ident);
fs/udf/inode.c:		ibh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 1,
fs/udf/inode.c:				(nbh = udf_read_ptagged(inode->i_sb, &loc, 0,
fs/udf/inode.c:		udf_err(inode->i_sb, "unsupported strategy type: %d\n",
fs/udf/inode.c:	struct udf_sb_info *sbi = UDF_SB(inode->i_sb);
fs/udf/inode.c:		if (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -
fs/udf/inode.c:		       inode->i_sb->s_blocksize -
fs/udf/inode.c:		if (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -
fs/udf/inode.c:		       inode->i_sb->s_blocksize - sizeof(struct fileEntry));
fs/udf/inode.c:		if (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -
fs/udf/inode.c:		       inode->i_sb->s_blocksize -
fs/udf/inode.c:	if (!uid_valid(inode->i_uid) ||
fs/udf/inode.c:	    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||
fs/udf/inode.c:	    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))
fs/udf/inode.c:		inode->i_uid = UDF_SB(inode->i_sb)->s_uid;
fs/udf/inode.c:	if (!gid_valid(inode->i_gid) ||
fs/udf/inode.c:	    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||
fs/udf/inode.c:	    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))
fs/udf/inode.c:		inode->i_gid = UDF_SB(inode->i_sb)->s_gid;
fs/udf/inode.c:		inode->i_mode = sbi->s_fmode;
fs/udf/inode.c:		inode->i_mode = sbi->s_dmode;
fs/udf/inode.c:		inode->i_mode = udf_convert_permissions(fe);
fs/udf/inode.c:	inode->i_mode &= ~sbi->s_umask;
fs/udf/inode.c:	inode->i_size = le64_to_cpu(fe->informationLength);
fs/udf/inode.c:	iinfo->i_lenExtents = inode->i_size;
fs/udf/inode.c:		inode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<
fs/udf/inode.c:			(inode->i_sb->s_blocksize_bits - 9);
fs/udf/inode.c:		if (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))
fs/udf/inode.c:			inode->i_atime = sbi->s_record_time;
fs/udf/inode.c:		if (!udf_disk_stamp_to_time(&inode->i_mtime,
fs/udf/inode.c:			inode->i_mtime = sbi->s_record_time;
fs/udf/inode.c:		if (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))
fs/udf/inode.c:			inode->i_ctime = sbi->s_record_time;
fs/udf/inode.c:		inode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<
fs/udf/inode.c:		    (inode->i_sb->s_blocksize_bits - 9);
fs/udf/inode.c:		if (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))
fs/udf/inode.c:			inode->i_atime = sbi->s_record_time;
fs/udf/inode.c:		if (!udf_disk_stamp_to_time(&inode->i_mtime,
fs/udf/inode.c:			inode->i_mtime = sbi->s_record_time;
fs/udf/inode.c:		if (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))
fs/udf/inode.c:			inode->i_ctime = sbi->s_record_time;
fs/udf/inode.c:		inode->i_op = &udf_dir_inode_operations;
fs/udf/inode.c:		inode->i_fop = &udf_dir_operations;
fs/udf/inode.c:		inode->i_mode |= S_IFDIR;
fs/udf/inode.c:			inode->i_data.a_ops = &udf_adinicb_aops;
fs/udf/inode.c:			inode->i_data.a_ops = &udf_aops;
fs/udf/inode.c:		inode->i_op = &udf_file_inode_operations;
fs/udf/inode.c:		inode->i_fop = &udf_file_operations;
fs/udf/inode.c:		inode->i_mode |= S_IFREG;
fs/udf/inode.c:		inode->i_mode |= S_IFBLK;
fs/udf/inode.c:		inode->i_mode |= S_IFCHR;
fs/udf/inode.c:		init_special_inode(inode, inode->i_mode | S_IFIFO, 0);
fs/udf/inode.c:		init_special_inode(inode, inode->i_mode | S_IFSOCK, 0);
fs/udf/inode.c:		inode->i_data.a_ops = &udf_symlink_aops;
fs/udf/inode.c:		inode->i_op = &udf_symlink_inode_operations;
fs/udf/inode.c:		inode->i_mode = S_IFLNK | S_IRWXUGO;
fs/udf/inode.c:		udf_err(inode->i_sb, "(ino %ld) failed unknown file type=%d\n",
fs/udf/inode.c:			inode->i_ino, fe->icbTag.fileType);
fs/udf/inode.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {
fs/udf/inode.c:			init_special_inode(inode, inode->i_mode,
fs/udf/inode.c:		udf_err(inode->i_sb, "(ino %ld) no free memory\n",
fs/udf/inode.c:			inode->i_ino);
fs/udf/inode.c:	struct udf_sb_info *sbi = UDF_SB(inode->i_sb);
fs/udf/inode.c:	unsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;
fs/udf/inode.c:	bh = udf_tgetblk(inode->i_sb,
fs/udf/inode.c:			udf_get_lb_pblock(inode->i_sb, &iinfo->i_location, 0));
fs/udf/inode.c:	memset(bh->b_data, 0, inode->i_sb->s_blocksize);
fs/udf/inode.c:		       iinfo->i_ext.i_data, inode->i_sb->s_blocksize -
fs/udf/inode.c:	if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_FORGET))
fs/udf/inode.c:	if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_FORGET))
fs/udf/inode.c:	udfperms = ((inode->i_mode & S_IRWXO)) |
fs/udf/inode.c:		   ((inode->i_mode & S_IRWXG) << 2) |
fs/udf/inode.c:		   ((inode->i_mode & S_IRWXU) << 4);
fs/udf/inode.c:	if (S_ISDIR(inode->i_mode))
fs/udf/inode.c:		fe->fileLinkCount = cpu_to_le16(inode->i_nlink - 1);
fs/udf/inode.c:		fe->fileLinkCount = cpu_to_le16(inode->i_nlink);
fs/udf/inode.c:	fe->informationLength = cpu_to_le64(inode->i_size);
fs/udf/inode.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {
fs/udf/inode.c:			(inode->i_blocks + (1 << (blocksize_bits - 9)) - 1) >>
fs/udf/inode.c:		       inode->i_sb->s_blocksize - sizeof(struct fileEntry));
fs/udf/inode.c:		udf_time_to_disk_stamp(&fe->accessTime, inode->i_atime);
fs/udf/inode.c:		udf_time_to_disk_stamp(&fe->modificationTime, inode->i_mtime);
fs/udf/inode.c:		udf_time_to_disk_stamp(&fe->attrTime, inode->i_ctime);
fs/udf/inode.c:		       inode->i_sb->s_blocksize -
fs/udf/inode.c:		efe->objectSize = cpu_to_le64(inode->i_size);
fs/udf/inode.c:		if (iinfo->i_crtime.tv_sec > inode->i_atime.tv_sec ||
fs/udf/inode.c:		    (iinfo->i_crtime.tv_sec == inode->i_atime.tv_sec &&
fs/udf/inode.c:		     iinfo->i_crtime.tv_nsec > inode->i_atime.tv_nsec))
fs/udf/inode.c:			iinfo->i_crtime = inode->i_atime;
fs/udf/inode.c:		if (iinfo->i_crtime.tv_sec > inode->i_mtime.tv_sec ||
fs/udf/inode.c:		    (iinfo->i_crtime.tv_sec == inode->i_mtime.tv_sec &&
fs/udf/inode.c:		     iinfo->i_crtime.tv_nsec > inode->i_mtime.tv_nsec))
fs/udf/inode.c:			iinfo->i_crtime = inode->i_mtime;
fs/udf/inode.c:		if (iinfo->i_crtime.tv_sec > inode->i_ctime.tv_sec ||
fs/udf/inode.c:		    (iinfo->i_crtime.tv_sec == inode->i_ctime.tv_sec &&
fs/udf/inode.c:		     iinfo->i_crtime.tv_nsec > inode->i_ctime.tv_nsec))
fs/udf/inode.c:			iinfo->i_crtime = inode->i_ctime;
fs/udf/inode.c:		udf_time_to_disk_stamp(&efe->accessTime, inode->i_atime);
fs/udf/inode.c:		udf_time_to_disk_stamp(&efe->modificationTime, inode->i_mtime);
fs/udf/inode.c:		udf_time_to_disk_stamp(&efe->attrTime, inode->i_ctime);
fs/udf/inode.c:	if (S_ISDIR(inode->i_mode))
fs/udf/inode.c:	else if (S_ISREG(inode->i_mode))
fs/udf/inode.c:	else if (S_ISLNK(inode->i_mode))
fs/udf/inode.c:	else if (S_ISBLK(inode->i_mode))
fs/udf/inode.c:	else if (S_ISCHR(inode->i_mode))
fs/udf/inode.c:	else if (S_ISFIFO(inode->i_mode))
fs/udf/inode.c:	else if (S_ISSOCK(inode->i_mode))
fs/udf/inode.c:			((inode->i_mode & S_ISUID) ? ICBTAG_FLAG_SETUID : 0) |
fs/udf/inode.c:			((inode->i_mode & S_ISGID) ? ICBTAG_FLAG_SETGID : 0) |
fs/udf/inode.c:			((inode->i_mode & S_ISVTX) ? ICBTAG_FLAG_STICKY : 0) |
fs/udf/inode.c:			udf_warn(inode->i_sb, "IO error syncing udf inode [%08lx]\n",
fs/udf/inode.c:				 inode->i_ino);
fs/udf/inode.c:	if (inode->i_state & I_NEW) {
fs/udf/inode.c:	if (epos->offset + (2 * adsize) > inode->i_sb->s_blocksize) {
fs/udf/inode.c:		epos->block.logicalBlockNum = udf_new_block(inode->i_sb, NULL,
fs/udf/inode.c:		nbh = udf_tgetblk(inode->i_sb, udf_get_lb_pblock(inode->i_sb,
fs/udf/inode.c:		memset(nbh->b_data, 0x00, inode->i_sb->s_blocksize);
fs/udf/inode.c:		if (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))
fs/udf/inode.c:		if (epos->offset + adsize > inode->i_sb->s_blocksize) {
fs/udf/inode.c:		if (UDF_SB(inode->i_sb)->s_udfrev >= 0x0200)
fs/udf/inode.c:						     inode->i_sb->s_blocksize);
fs/udf/inode.c:						     inode->i_sb->s_blocksize);
fs/udf/inode.c:			if (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||
fs/udf/inode.c:			    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)
fs/udf/inode.c:		if (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||
fs/udf/inode.c:				UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)
fs/udf/inode.c:		if (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||
fs/udf/inode.c:		    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {
fs/udf/inode.c:		block = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);
fs/udf/inode.c:		epos->bh = udf_tread(inode->i_sb, block);
fs/udf/inode.c:		udf_free_blocks(inode->i_sb, inode, &epos.block, 0, 1);
fs/udf/inode.c:			if (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||
fs/udf/inode.c:			    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)
fs/udf/inode.c:			if (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||
fs/udf/inode.c:			    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)
fs/udf/inode.c:	unsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;
fs/udf/inode.c:		ret = udf_get_lb_pblock(inode->i_sb, &eloc, offset);
fs/udf/inode.c:	if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_VARCONV))
fs/udf/misc.c:	offset = inode->i_sb->s_blocksize - udf_file_entry_alloc_offset(inode) -
fs/udf/misc.c:			struct udf_sb_info *sbi = UDF_SB(inode->i_sb);
fs/udf/super.c:	call_rcu(&inode->i_rcu, udf_i_callback);
fs/udf/super.c:	sector_t blocks = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;
fs/udf/super.c:			(sbi->s_vat_inode->i_size - 36) >> 2;
fs/udf/super.c:			(sbi->s_vat_inode->i_size -
fs/udf/super.c:	    sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits)
fs/udf/super.c:		if (last[i] >= sb->s_bdev->bd_inode->i_size >>
fs/udf/truncate.c:	int last_block = (elen + inode->i_sb->s_blocksize - 1) >>
fs/udf/truncate.c:		inode->i_sb->s_blocksize_bits;
fs/udf/truncate.c:	int first_block = (nelen + inode->i_sb->s_blocksize - 1) >>
fs/udf/truncate.c:		inode->i_sb->s_blocksize_bits;
fs/udf/truncate.c:			udf_free_blocks(inode->i_sb, inode, eloc, 0,
fs/udf/truncate.c:				udf_free_blocks(inode->i_sb, inode, eloc,
fs/udf/truncate.c:	    inode->i_size == iinfo->i_lenExtents)
fs/udf/truncate.c:	if (inode->i_nlink == 0)
fs/udf/truncate.c:		if (lbcount > inode->i_size) {
fs/udf/truncate.c:			if (lbcount - inode->i_size >= inode->i_sb->s_blocksize)
fs/udf/truncate.c:				udf_warn(inode->i_sb,
fs/udf/truncate.c:					 (unsigned)inode->i_ino,
fs/udf/truncate.c:					 (long long)inode->i_size,
fs/udf/truncate.c:			nelen = elen - (lbcount - inode->i_size);
fs/udf/truncate.c:				udf_err(inode->i_sb,
fs/udf/truncate.c:					(unsigned)inode->i_ino);
fs/udf/truncate.c:	iinfo->i_lenExtents = inode->i_size;
fs/udf/truncate.c:	    inode->i_size == iinfo->i_lenExtents)
fs/udf/truncate.c:			if (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||
fs/udf/truncate.c:			    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)
fs/udf/truncate.c:	struct super_block *sb = inode->i_sb;
fs/udf/truncate.c: * Truncate extents of inode to inode->i_size. This function can be used only
fs/udf/truncate.c:	struct super_block *sb = inode->i_sb;
fs/udf/truncate.c:	sector_t first_block = inode->i_size >> sb->s_blocksize_bits, offset;
fs/udf/truncate.c:		(inode->i_size & (sb->s_blocksize - 1));
fs/udf/truncate.c:	iinfo->i_lenExtents = inode->i_size;
fs/udf/symlink.c:		bh = sb_bread(inode->i_sb, pos);
fs/udf/symlink.c:	udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);
fs/udf/lowlevel.c:		lblock = bdev->bd_inode->i_size >> sb->s_blocksize_bits;
fs/udf/file.c:	memcpy(kaddr, iinfo->i_ext.i_data + iinfo->i_lenEAttr, inode->i_size);
fs/udf/file.c:	memset(kaddr + inode->i_size, 0, PAGE_CACHE_SIZE - inode->i_size);
fs/udf/file.c:	memcpy(iinfo->i_ext.i_data + iinfo->i_lenEAttr, kaddr, inode->i_size);
fs/udf/file.c:			pos = inode->i_size;
fs/udf/file.c:		if (inode->i_sb->s_blocksize <
fs/udf/file.c:			if (pos + count > inode->i_size)
fs/udf/file.c:				iinfo->i_lenAlloc = inode->i_size;
fs/udf/file.c:		udf_debug("no permission to access inode %lu\n", inode->i_ino);
fs/udf/file.c:				 UDF_SB(inode->i_sb)->s_volume_ident, 32))
fs/udf/file.c:		result = udf_relocate_blocks(inode->i_sb,
fs/udf/partition.c:	struct super_block *sb = inode->i_sb;
fs/udf/namei.c:	if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))
fs/udf/namei.c:		inode->i_data.a_ops = &udf_adinicb_aops;
fs/udf/namei.c:		inode->i_data.a_ops = &udf_aops;
fs/udf/namei.c:	inode->i_op = &udf_file_inode_operations;
fs/udf/namei.c:	inode->i_fop = &udf_file_operations;
fs/udf/namei.c:	cfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);
fs/udf/namei.c:	cfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);
fs/udf/namei.c:	inode->i_op = &udf_dir_inode_operations;
fs/udf/namei.c:	inode->i_fop = &udf_dir_operations;
fs/udf/namei.c:	cfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);
fs/udf/namei.c:	cfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);
fs/udf/namei.c:	if (udf_get_lb_pblock(dir->i_sb, &tloc, 0) != inode->i_ino)
fs/udf/namei.c:	if (inode->i_nlink != 2)
fs/udf/namei.c:		udf_warn(inode->i_sb, "empty directory has nlink != 2 (%d)\n",
fs/udf/namei.c:			 inode->i_nlink);
fs/udf/namei.c:	inode->i_size = 0;
fs/udf/namei.c:	inode->i_ctime = dir->i_ctime = dir->i_mtime =
fs/udf/namei.c:	if (udf_get_lb_pblock(dir->i_sb, &tloc, 0) != inode->i_ino)
fs/udf/namei.c:	if (!inode->i_nlink) {
fs/udf/namei.c:			  inode->i_ino, inode->i_nlink);
fs/udf/namei.c:	inode->i_ctime = dir->i_ctime;
fs/udf/namei.c:	inode->i_data.a_ops = &udf_symlink_aops;
fs/udf/namei.c:	inode->i_op = &udf_symlink_inode_operations;
fs/udf/namei.c:	inode->i_size = elen;
fs/udf/namei.c:		iinfo->i_lenAlloc = inode->i_size;
fs/udf/namei.c:	if (UDF_SB(inode->i_sb)->s_lvid_bh) {
fs/udf/namei.c:	cfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);
fs/udf/namei.c:	if (UDF_SB(inode->i_sb)->s_lvid_bh) {
fs/udf/namei.c:			cpu_to_le32(lvid_get_unique_id(inode->i_sb));
fs/udf/namei.c:	inode->i_ctime = current_fs_time(inode->i_sb);
fs/udf/namei.c:	    != old_inode->i_ino)
fs/udf/namei.c:	if (S_ISDIR(old_inode->i_mode)) {
fs/udf/namei.c:					old_inode->i_sb->s_blocksize, &offset);
fs/udf/namei.c:					old_inode->i_sb->s_blocksize, &offset);
fs/udf/namei.c:		if (udf_get_lb_pblock(old_inode->i_sb, &tloc, 0) !=
fs/udf/namei.c:	old_inode->i_ctime = current_fs_time(old_inode->i_sb);
fs/udf/namei.c:		new_inode->i_ctime = current_fs_time(new_inode->i_sb);
fs/udf/namei.c:	inode = udf_iget(child->d_inode->i_sb, &tloc);
fs/udf/namei.c:	if (generation && inode->i_generation != generation) {
fs/udf/namei.c:	fid->udf.generation = inode->i_generation;
fs/udf/namei.c:		fid->udf.parent_generation = inode->i_generation;
fs/udf/ialloc.c:	struct super_block *sb = inode->i_sb;
fs/udf/ialloc.c:		if (S_ISDIR(inode->i_mode))
fs/udf/ialloc.c:	if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_EXTENDED_FE)) {
fs/udf/ialloc.c:		iinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -
fs/udf/ialloc.c:		iinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -
fs/udf/ialloc.c:	inode->i_ino = udf_get_lb_pblock(sb, &iinfo->i_location, 0);
fs/udf/ialloc.c:	inode->i_blocks = 0;
fs/udf/ialloc.c:	if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_AD_IN_ICB))
fs/udf/ialloc.c:	else if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))
fs/udf/ialloc.c:	inode->i_mtime = inode->i_atime = inode->i_ctime =
fs/udf/ialloc.c:		iinfo->i_crtime = current_fs_time(inode->i_sb);
fs/gfs2/inode.c:		    inode->i_state & (I_FREEING|I_CLEAR|I_WILL_FREE)) {
fs/gfs2/inode.c:	inode->i_ino = (unsigned long)(data->no_addr);
fs/gfs2/inode.c:	umode_t mode = inode->i_mode;
fs/gfs2/inode.c:		inode->i_op = &gfs2_file_iops;
fs/gfs2/inode.c:			inode->i_fop = &gfs2_file_fops_nolock;
fs/gfs2/inode.c:			inode->i_fop = &gfs2_file_fops;
fs/gfs2/inode.c:		inode->i_op = &gfs2_dir_iops;
fs/gfs2/inode.c:			inode->i_fop = &gfs2_dir_fops_nolock;
fs/gfs2/inode.c:			inode->i_fop = &gfs2_dir_fops;
fs/gfs2/inode.c:		inode->i_op = &gfs2_symlink_iops;
fs/gfs2/inode.c:		inode->i_op = &gfs2_file_iops;
fs/gfs2/inode.c:		init_special_inode(inode, inode->i_mode, inode->i_rdev);
fs/gfs2/inode.c:	if (inode->i_state & I_NEW) {
fs/gfs2/inode.c:			inode->i_mode = DT2IF(type);
fs/gfs2/inode.c:		if (S_ISDIR(inode->i_mode))
fs/gfs2/inode.c:			inode->i_mode |= S_ISUID;
fs/gfs2/inode.c:			inode->i_mode &= ~07111;
fs/gfs2/inode.c:		inode->i_uid = dip->i_inode.i_uid;
fs/gfs2/inode.c:		inode->i_uid = current_fsuid();
fs/gfs2/inode.c:		if (S_ISDIR(inode->i_mode))
fs/gfs2/inode.c:			inode->i_mode |= S_ISGID;
fs/gfs2/inode.c:		inode->i_gid = dip->i_inode.i_gid;
fs/gfs2/inode.c:		inode->i_gid = current_fsgid();
fs/gfs2/inode.c:	error = gfs2_quota_lock(dip, inode->i_uid, inode->i_gid);
fs/gfs2/inode.c:	error = gfs2_quota_check(dip, inode->i_uid, inode->i_gid);
fs/gfs2/inode.c:	gfs2_quota_change(dip, +1, inode->i_uid, inode->i_gid);
fs/gfs2/inode.c:	inode->i_mode = mode;
fs/gfs2/inode.c:	inode->i_rdev = dev;
fs/gfs2/inode.c:	inode->i_size = size;
fs/gfs2/inode.c:	if (S_ISDIR(inode->i_mode))
fs/gfs2/inode.c:	if (inode->i_nlink == 0)
fs/gfs2/inode.c:	inode->i_ctime = CURRENT_TIME;
fs/gfs2/inode.c:	if (S_ISDIR(inode->i_mode))
fs/gfs2/inode.c:	if (inode->i_nlink == 0)
fs/gfs2/inode.c:	if (inode->i_nlink == 0)
fs/gfs2/inode.c:	if (S_ISDIR(inode->i_mode)) {
fs/gfs2/inode.c:		if (ip->i_entries > 2 || inode->i_nlink > 2)
fs/gfs2/inode.c:	ouid = inode->i_uid;
fs/gfs2/inode.c:	ogid = inode->i_gid;
fs/gfs2/inode.c:	mutex_lock(&inode->i_mutex);
fs/gfs2/inode.c:		u64 phys = ip->i_no_addr << inode->i_blkbits;
fs/gfs2/inode.c:	mutex_unlock(&inode->i_mutex);
fs/gfs2/ops_fstype.c:	lockdep_set_class(&sdp->sd_quota_inode->i_mutex,
fs/gfs2/ops_fstype.c:		 path.dentry->d_inode->i_sb->s_bdev);
fs/gfs2/glops.c:	if ((inode->i_nlink != nlink) && (inode->i_nlink != 0)) {
fs/gfs2/super.c:	struct super_block *sb = dentry->d_inode->i_sb;
fs/gfs2/super.c:	if (inode->i_nlink) {
fs/gfs2/super.c:	truncate_inode_pages(&inode->i_data, 0);
fs/gfs2/super.c:	struct super_block *sb = inode->i_sb;
fs/gfs2/super.c:	if (inode->i_nlink || (sb->s_flags & MS_RDONLY))
fs/gfs2/super.c:	if (S_ISDIR(inode->i_mode) &&
fs/gfs2/super.c:	truncate_inode_pages(&inode->i_data, 0);
fs/gfs2/super.c:	truncate_inode_pages(&inode->i_data, 0);
fs/gfs2/super.c:	call_rcu(&inode->i_rcu, gfs2_i_callback);
fs/gfs2/dentry.c:	if (inode && S_ISDIR(inode->i_mode)) {
fs/gfs2/dentry.c:	if (!ginode->i_iopen_gh.gh_gl)
fs/gfs2/dentry.c:	if (test_bit(GLF_DEMOTE, &ginode->i_iopen_gh.gh_gl->gl_flags))
fs/gfs2/inode.h:	inode->i_blocks = blocks <<
fs/gfs2/inode.h:	return inode->i_blocks >>
fs/gfs2/inode.h:	gfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));
fs/gfs2/inode.h:	inode->i_blocks += change;
fs/gfs2/inode.h:	if (size & ((1 << inode->i_blkbits) - 1))
fs/gfs2/aops.c:		create_empty_buffers(page, inode->i_sb->s_blocksize,
fs/gfs2/aops.c:	gfs2_page_add_databufs(ip, page, 0, inode->i_sb->s_blocksize-1);
fs/gfs2/aops.c:			create_empty_buffers(page, inode->i_sb->s_blocksize,
fs/gfs2/aops.c:	unsigned nrblocks = nr_pages * (PAGE_CACHE_SIZE/inode->i_sb->s_blocksize);
fs/gfs2/aops.c:	struct gfs2_sbd *sdp = inode->i_sb->s_fs_info;
fs/gfs2/aops.c:		if (inode->i_size < to)
fs/gfs2/aops.c:	rv = __blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev, iov,
fs/gfs2/aops.c:		inode->i_mapping->a_ops = &gfs2_writeback_aops;
fs/gfs2/aops.c:		inode->i_mapping->a_ops = &gfs2_ordered_aops;
fs/gfs2/aops.c:		inode->i_mapping->a_ops = &gfs2_jdata_aops;
fs/gfs2/incore.h:	return inode->i_sb->s_fs_info;
fs/gfs2/quota.c:	struct address_space *mapping = inode->i_mapping;
fs/gfs2/quota.c:	blocksize = inode->i_sb->s_blocksize;
fs/gfs2/quota.c:	iblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);
fs/gfs2/quota.c:	if (size > inode->i_size)
fs/gfs2/quota.c:	inode->i_mtime = inode->i_atime = CURRENT_TIME;
fs/gfs2/quota.c:		fqs->qs_uquota.qfs_nblks = sdp->sd_quota_inode->i_blocks;
fs/gfs2/dir.c:	spin_lock(&inode->i_lock);
fs/gfs2/dir.c:	spin_unlock(&inode->i_lock);
fs/gfs2/dir.c:	if (S_ISDIR(dentry->d_inode->i_mode))
fs/gfs2/file.c:	case SEEK_END: /* These reference inode->i_size */
fs/gfs2/file.c:	if (!S_ISDIR(inode->i_mode) && ip->i_diskflags & GFS2_DIF_JDATA)
fs/gfs2/file.c:	unsigned int flags = inode->i_flags;
fs/gfs2/file.c:	if ((ip->i_eattr == 0) && !is_sxid(inode->i_mode))
fs/gfs2/file.c:		inode->i_flags |= S_NOSEC;
fs/gfs2/file.c:	inode->i_flags = flags;
fs/gfs2/file.c:		error = filemap_fdatawrite(inode->i_mapping);
fs/gfs2/file.c:		error = filemap_fdatawait(inode->i_mapping);
fs/gfs2/file.c:	if (!S_ISDIR(inode->i_mode)) {
fs/gfs2/file.c:	u64 lblock = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/gfs2/file.c:		lblock += (bh.b_size >> inode->i_blkbits);
fs/gfs2/file.c:	sb_start_pagefault(inode->i_sb);
fs/gfs2/file.c:		if (!PageUptodate(page) || page->mapping != inode->i_mapping) {
fs/gfs2/file.c:	if (!PageUptodate(page) || page->mapping != inode->i_mapping)
fs/gfs2/file.c:	sb_end_pagefault(inode->i_sb);
fs/gfs2/file.c:	    (atomic_read(&inode->i_writecount) == 1))
fs/gfs2/file.c:	int sync_state = inode->i_state & (I_DIRTY_SYNC|I_DIRTY_DATASYNC);
fs/gfs2/file.c:	sector_t lblock = offset >> inode->i_blkbits;
fs/gfs2/file.c:		nr_blks = bh_map.b_size >> inode->i_blkbits;
fs/gfs2/file.c:	if (offset + size > inode->i_size && !(mode & FALLOC_FL_KEEP_SIZE))
fs/gfs2/bmap.c:		page = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);
fs/gfs2/bmap.c:		create_empty_buffers(page, 1 << inode->i_blkbits,
fs/gfs2/bmap.c:		map_bh(bh, inode->i_sb, block);
fs/gfs2/bmap.c:	map_bh(bh_map, inode->i_sb, dblock);
fs/gfs2/bmap.c:	bh_map->b_size = dblks << inode->i_blkbits;
fs/gfs2/bmap.c:	const unsigned int maxlen = bh_map->b_size >> inode->i_blkbits;
fs/gfs2/bmap.c:	map_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));
fs/gfs2/bmap.c:	bh_map->b_size = (len << inode->i_blkbits);
fs/gfs2/bmap.c:	bh.b_size = 1 << (inode->i_blkbits + (create ? 0 : 5));
fs/gfs2/bmap.c:	*extlen = bh.b_size >> inode->i_blkbits;
fs/gfs2/bmap.c:	blocksize = inode->i_sb->s_blocksize;
fs/gfs2/bmap.c:	iblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);
fs/gfs2/bmap.c:	struct address_space *mapping = inode->i_mapping;
fs/gfs2/bmap.c:	u64 size = inode->i_size;
fs/gfs2/bmap.c:	BUG_ON(!S_ISREG(inode->i_mode));
fs/gfs2/bmap.c:	oldsize = inode->i_size;
fs/gfs2/acl.c:	if (mode != inode->i_mode) {
fs/gfs2/acl.c:		inode->i_mode = mode;
fs/gfs2/acl.c:	umode_t mode = inode->i_mode;
fs/gfs2/acl.c:	if (S_ISLNK(inode->i_mode))
fs/gfs2/acl.c:	if (S_ISDIR(inode->i_mode)) {
fs/gfs2/acl.c:	if (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))
fs/gfs2/acl.c:	if ((current_fsuid() != inode->i_uid) && !capable(CAP_FOWNER))
fs/gfs2/acl.c:	if (S_ISLNK(inode->i_mode))
fs/gfs2/acl.c:		umode_t mode = inode->i_mode;
fs/gfs2/export.c:	struct super_block *sb = inode->i_sb;
fs/gfs2/meta_io.h:		return inode->i_sb->s_fs_info;
fs/gfs2/glock.c:		gi->sdp = inode->i_private;
fs/gfs2/glock.c:		gi->sdp = inode->i_private;
fs/gfs2/glock.c:		gi->sdp = inode->i_private;
fs/namespace.c:	if (!(file->f_mode & FMODE_WRITE) || special_file(inode->i_mode))
fs/namespace.c:	if (S_ISLNK(path->dentry->d_inode->i_mode))
fs/namespace.c:	if (path->dentry->d_inode->i_mode & S_ISVTX) {
fs/namespace.c:		if (current_uid() != path->dentry->d_inode->i_uid)
fs/namespace.c:	mutex_lock(&path->dentry->d_inode->i_mutex);
fs/namespace.c:		mutex_unlock(&path->dentry->d_inode->i_mutex);
fs/namespace.c:	mutex_unlock(&path->dentry->d_inode->i_mutex);
fs/namespace.c:	mutex_unlock(&path->dentry->d_inode->i_mutex);
fs/namespace.c:	if (S_ISDIR(path->dentry->d_inode->i_mode) !=
fs/namespace.c:	      S_ISDIR(mnt->mnt.mnt_root->d_inode->i_mode))
fs/namespace.c:	if (S_ISDIR(path->dentry->d_inode->i_mode) !=
fs/namespace.c:	      S_ISDIR(old_path.dentry->d_inode->i_mode))
fs/namespace.c:	if (S_ISLNK(newmnt->mnt.mnt_root->d_inode->i_mode))
fs/debugfs/inode.c:		inode->i_ino = get_next_ino();
fs/debugfs/inode.c:		inode->i_mode = mode;
fs/debugfs/inode.c:		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/debugfs/inode.c:			inode->i_fop = fops ? fops : &debugfs_file_operations;
fs/debugfs/inode.c:			inode->i_private = data;
fs/debugfs/inode.c:			inode->i_op = &debugfs_link_operations;
fs/debugfs/inode.c:			inode->i_private = data;
fs/debugfs/inode.c:			inode->i_op = &simple_dir_inode_operations;
fs/debugfs/inode.c:			inode->i_fop = &simple_dir_operations;
fs/debugfs/inode.c:	inode->i_mode &= ~S_IALLUGO;
fs/debugfs/inode.c:	inode->i_mode |= opts->mode;
fs/debugfs/inode.c:	inode->i_uid = opts->uid;
fs/debugfs/inode.c:	inode->i_gid = opts->gid;
fs/debugfs/inode.c:	mutex_lock(&parent->d_inode->i_mutex);
fs/debugfs/inode.c:	mutex_unlock(&parent->d_inode->i_mutex);
fs/debugfs/inode.c:			switch (dentry->d_inode->i_mode & S_IFMT) {
fs/debugfs/inode.c:				kfree(dentry->d_inode->i_private);
fs/debugfs/inode.c:	mutex_lock(&parent->d_inode->i_mutex);
fs/debugfs/inode.c:	mutex_unlock(&parent->d_inode->i_mutex);
fs/debugfs/inode.c:	mutex_lock(&parent->d_inode->i_mutex);
fs/debugfs/inode.c:			mutex_unlock(&parent->d_inode->i_mutex);
fs/debugfs/inode.c:			mutex_lock(&parent->d_inode->i_mutex);
fs/debugfs/inode.c:			mutex_unlock(&parent->d_inode->i_mutex);
fs/debugfs/inode.c:			mutex_lock(&parent->d_inode->i_mutex);
fs/debugfs/inode.c:			mutex_unlock(&parent->d_inode->i_mutex);
fs/debugfs/inode.c:	mutex_lock(&parent->d_inode->i_mutex);
fs/debugfs/inode.c:	mutex_unlock(&parent->d_inode->i_mutex);
fs/debugfs/inode.c:		S_ISDIR(old_dentry->d_inode->i_mode),
fs/debugfs/file.c:	nd_set_link(nd, dentry->d_inode->i_private);
fs/debugfs/file.c:	struct array_data *data = inode->i_private;
fs/debugfs/file.c:	return single_open(file, debugfs_show_regset32, inode->i_private);
fs/bad_inode.c:	inode->i_mode = S_IFREG;
fs/bad_inode.c:	inode->i_atime = inode->i_mtime = inode->i_ctime =
fs/bad_inode.c:		current_fs_time(inode->i_sb);
fs/bad_inode.c:	inode->i_op = &bad_inode_ops;	
fs/bad_inode.c:	inode->i_fop = &bad_file_ops;	
fs/bad_inode.c:	return (inode->i_op == &bad_inode_ops);	
fs/afs/inode.c:		inode->i_mode	= S_IFREG | vnode->status.mode;
fs/afs/inode.c:		inode->i_op	= &afs_file_inode_operations;
fs/afs/inode.c:		inode->i_fop	= &afs_file_operations;
fs/afs/inode.c:		inode->i_mode	= S_IFDIR | vnode->status.mode;
fs/afs/inode.c:		inode->i_op	= &afs_dir_inode_operations;
fs/afs/inode.c:		inode->i_fop	= &afs_dir_file_operations;
fs/afs/inode.c:		inode->i_mode	= S_IFLNK | vnode->status.mode;
fs/afs/inode.c:		inode->i_op	= &page_symlink_inode_operations;
fs/afs/inode.c:	if (vnode->status.size != inode->i_size)
fs/afs/inode.c:	inode->i_uid		= vnode->status.owner;
fs/afs/inode.c:	inode->i_gid		= 0;
fs/afs/inode.c:	inode->i_size		= vnode->status.size;
fs/afs/inode.c:	inode->i_ctime.tv_sec	= vnode->status.mtime_server;
fs/afs/inode.c:	inode->i_ctime.tv_nsec	= 0;
fs/afs/inode.c:	inode->i_atime		= inode->i_mtime = inode->i_ctime;
fs/afs/inode.c:	inode->i_blocks		= 0;
fs/afs/inode.c:	inode->i_generation	= vnode->fid.unique;
fs/afs/inode.c:	inode->i_version	= vnode->status.data_version;
fs/afs/inode.c:	inode->i_mapping->a_ops	= &afs_fs_aops;
fs/afs/inode.c:			inode->i_mode	= S_IFDIR | vnode->status.mode;
fs/afs/inode.c:			inode->i_op	= &afs_mntpt_inode_operations;
fs/afs/inode.c:			inode->i_fop	= &afs_mntpt_file_operations;
fs/afs/inode.c:	return inode->i_ino == data->fid.vnode &&
fs/afs/inode.c:		inode->i_generation == data->fid.unique;
fs/afs/inode.c:	inode->i_ino = data->fid.vnode;
fs/afs/inode.c:	inode->i_generation = data->fid.unique;
fs/afs/inode.c:	       inode, inode->i_ino, data.fid.vid, data.fid.vnode,
fs/afs/inode.c:	BUG_ON(!(inode->i_state & I_NEW));
fs/afs/inode.c:	inode->i_size		= 0;
fs/afs/inode.c:	inode->i_mode		= S_IFDIR | S_IRUGO | S_IXUGO;
fs/afs/inode.c:	inode->i_op		= &afs_autocell_inode_operations;
fs/afs/inode.c:	inode->i_uid		= 0;
fs/afs/inode.c:	inode->i_gid		= 0;
fs/afs/inode.c:	inode->i_ctime.tv_sec	= get_seconds();
fs/afs/inode.c:	inode->i_ctime.tv_nsec	= 0;
fs/afs/inode.c:	inode->i_atime		= inode->i_mtime = inode->i_ctime;
fs/afs/inode.c:	inode->i_blocks		= 0;
fs/afs/inode.c:	inode->i_version	= 0;
fs/afs/inode.c:	inode->i_generation	= 0;
fs/afs/inode.c:	inode->i_flags |= S_AUTOMOUNT | S_NOATIME;
fs/afs/inode.c:	if (!(inode->i_state & I_NEW)) {
fs/afs/inode.c:	inode->i_size = vnode->status.size;
fs/afs/inode.c:	inode->i_flags |= S_NOATIME;
fs/afs/inode.c:	_enter("{ ino=%lu v=%u }", inode->i_ino, inode->i_generation);
fs/afs/inode.c:	ASSERTCMP(inode->i_ino, ==, vnode->fid.vnode);
fs/afs/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/afs/super.c:	call_rcu(&inode->i_rcu, afs_i_callback);
fs/afs/dir.c:	_enter("{%lu}", inode->i_ino);
fs/afs/dir.c:	       file->f_pos, file->f_path.dentry->d_inode->i_ino);
fs/afs/dir.c:	       dentry->d_inode->i_ino,
fs/afs/dir.c:	       dentry->d_inode->i_generation);
fs/afs/dir.c:			       dentry->d_inode->i_generation);
fs/afs/write.c:	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/afs/write.c:	mutex_lock(&inode->i_mutex);
fs/afs/write.c:	mutex_unlock(&inode->i_mutex);
fs/afs/file.c:	_enter("{%x},{%lu},{%lu}", key_serial(key), inode->i_ino, page->index);
fs/afs/file.c:		key = afs_request_key(AFS_FS_S(inode->i_sb)->volume->cell);
fs/afs/mntpt.c:		page = read_mapping_page(mntpt->d_inode->i_mapping, 0, NULL);
fs/afs/security.c:	       mask, access, S_ISDIR(inode->i_mode) ? "dir" : "file");
fs/afs/security.c:	if (S_ISDIR(inode->i_mode)) {
fs/fuse/inode.c:	call_rcu(&inode->i_rcu, fuse_i_callback);
fs/fuse/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/fuse/inode.c:	if (inode->i_sb->s_flags & MS_ACTIVE) {
fs/fuse/inode.c:	inode->i_ino     = fuse_squash_ino(attr->ino);
fs/fuse/inode.c:	inode->i_mode    = (inode->i_mode & S_IFMT) | (attr->mode & 07777);
fs/fuse/inode.c:	inode->i_uid     = make_kuid(&init_user_ns, attr->uid);
fs/fuse/inode.c:	inode->i_gid     = make_kgid(&init_user_ns, attr->gid);
fs/fuse/inode.c:	inode->i_blocks  = attr->blocks;
fs/fuse/inode.c:	inode->i_atime.tv_sec   = attr->atime;
fs/fuse/inode.c:	inode->i_atime.tv_nsec  = attr->atimensec;
fs/fuse/inode.c:	inode->i_mtime.tv_sec   = attr->mtime;
fs/fuse/inode.c:	inode->i_mtime.tv_nsec  = attr->mtimensec;
fs/fuse/inode.c:	inode->i_ctime.tv_sec   = attr->ctime;
fs/fuse/inode.c:	inode->i_ctime.tv_nsec  = attr->ctimensec;
fs/fuse/inode.c:		inode->i_blkbits = ilog2(attr->blksize);
fs/fuse/inode.c:		inode->i_blkbits = inode->i_sb->s_blocksize_bits;
fs/fuse/inode.c:	fi->orig_i_mode = inode->i_mode;
fs/fuse/inode.c:		inode->i_mode &= ~S_ISVTX;
fs/fuse/inode.c:	old_mtime = inode->i_mtime;
fs/fuse/inode.c:	oldsize = inode->i_size;
fs/fuse/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/fuse/inode.c:			invalidate_inode_pages2(inode->i_mapping);
fs/fuse/inode.c:	inode->i_mode = attr->mode & S_IFMT;
fs/fuse/inode.c:	inode->i_size = attr->size;
fs/fuse/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/fuse/inode.c:	} else if (S_ISDIR(inode->i_mode))
fs/fuse/inode.c:	else if (S_ISLNK(inode->i_mode))
fs/fuse/inode.c:	else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||
fs/fuse/inode.c:		 S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {
fs/fuse/inode.c:		init_special_inode(inode, inode->i_mode,
fs/fuse/inode.c:	if ((inode->i_state & I_NEW)) {
fs/fuse/inode.c:		inode->i_flags |= S_NOATIME|S_NOCMTIME;
fs/fuse/inode.c:		inode->i_generation = generation;
fs/fuse/inode.c:		inode->i_data.backing_dev_info = &fc->bdi;
fs/fuse/inode.c:	} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {
fs/fuse/inode.c:		invalidate_inode_pages2_range(inode->i_mapping,
fs/fuse/inode.c:	if (inode->i_generation != handle->generation)
fs/fuse/inode.c:	generation = inode->i_generation;
fs/fuse/inode.c:	err = fuse_lookup_name(child_inode->i_sb, get_node_id(child_inode),
fs/fuse/fuse_i.h:	/** The sticky bit in inode->i_mode may have been removed, so
fs/fuse/fuse_i.h:	return get_fuse_conn_super(inode->i_sb);
fs/fuse/dev.c:	mapping = inode->i_mapping;
fs/fuse/dev.c:	struct address_space *mapping = inode->i_mapping;
fs/fuse/dir.c: * dentry->d_time and fuse_inode->i_time respectively.
fs/fuse/dir.c:		if (err || (outarg.attr.mode ^ inode->i_mode) & S_IFMT)
fs/fuse/dir.c:		if (!hlist_empty(&inode->i_dentry))
fs/fuse/dir.c:	if (inode && S_ISDIR(inode->i_mode)) {
fs/fuse/dir.c:	if (S_ISDIR(inode->i_mode)) {
fs/fuse/dir.c:		if (inode->i_nlink > 0)
fs/fuse/dir.c:	err = create_new_entry(fc, req, newdir, newent, inode->i_mode);
fs/fuse/dir.c:	stat->dev = inode->i_sb->s_dev;
fs/fuse/dir.c:	stat->mode = (inode->i_mode & S_IFMT) | (attr->mode & 07777);
fs/fuse/dir.c:	stat->rdev = inode->i_rdev;
fs/fuse/dir.c:		blkbits = inode->i_sb->s_blocksize_bits;
fs/fuse/dir.c:	if (file && S_ISREG(inode->i_mode)) {
fs/fuse/dir.c:		if ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
fs/fuse/dir.c:		mutex_lock(&entry->d_inode->i_mutex);
fs/fuse/dir.c:		if (S_ISDIR(entry->d_inode->i_mode)) {
fs/fuse/dir.c:			entry->d_inode->i_flags |= S_DEAD;
fs/fuse/dir.c:		mutex_unlock(&entry->d_inode->i_mutex);
fs/fuse/dir.c:	    ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))) {
fs/fuse/dir.c:	} else if ((mask & MAY_EXEC) && S_ISREG(inode->i_mode)) {
fs/fuse/dir.c:		if (!(inode->i_mode & S_IXUGO)) {
fs/fuse/dir.c:			if (!err && !(inode->i_mode & S_IXUGO))
fs/fuse/dir.c:	BUG_ON(!mutex_is_locked(&inode->i_mutex));
fs/fuse/dir.c:	if ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
fs/fuse/dir.c:	oldsize = inode->i_size;
fs/fuse/dir.c:	if (S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {
fs/fuse/dir.c:		invalidate_inode_pages2(inode->i_mapping);
fs/fuse/dir.c:	inode->i_op = &fuse_common_inode_operations;
fs/fuse/dir.c:	inode->i_op = &fuse_dir_inode_operations;
fs/fuse/dir.c:	inode->i_fop = &fuse_dir_operations;
fs/fuse/dir.c:	inode->i_op = &fuse_symlink_inode_operations;
fs/fuse/cuse.c:	dev_t devt = inode->i_cdev->dev;
fs/fuse/file.c:		invalidate_inode_pages2(inode->i_mapping);
fs/fuse/file.c:	err = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/fuse/file.c:	mutex_lock(&inode->i_mutex);
fs/fuse/file.c:	mutex_unlock(&inode->i_mutex);
fs/fuse/file.c:	if (attr_ver == fi->attr_version && size < inode->i_size) {
fs/fuse/file.c:	if (pos > inode->i_size)
fs/fuse/file.c:	sb_start_write(inode->i_sb);
fs/fuse/file.c:	mutex_lock(&inode->i_mutex);
fs/fuse/file.c:	err = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));
fs/fuse/file.c:	mutex_unlock(&inode->i_mutex);
fs/fuse/file.c:	sb_end_write(inode->i_sb);
fs/fuse/file.c:	mutex_lock(&inode->i_mutex);
fs/fuse/file.c:	mutex_unlock(&inode->i_mutex);
fs/fuse/file.c:	struct backing_dev_info *bdi = inode->i_mapping->backing_dev_info;
fs/fuse/file.c:	mapping_set_error(inode->i_mapping, req->out.h.error);
fs/fuse/file.c:	if (!inode->i_sb->s_bdev || fc->no_bmap)
fs/fuse/file.c:	inarg.blocksize = inode->i_sb->s_blocksize;
fs/fuse/file.c:	mutex_lock(&inode->i_mutex);
fs/fuse/file.c:	mutex_unlock(&inode->i_mutex);
fs/fuse/file.c:	inode->i_fop = &fuse_file_operations;
fs/fuse/file.c:	inode->i_data.a_ops = &fuse_file_aops;
fs/fuse/control.c:	fc = file->f_path.dentry->d_inode->i_private;
fs/fuse/control.c:	inode->i_ino = get_next_ino();
fs/fuse/control.c:	inode->i_mode = mode;
fs/fuse/control.c:	inode->i_uid = fc->user_id;
fs/fuse/control.c:	inode->i_gid = fc->group_id;
fs/fuse/control.c:	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/fuse/control.c:		inode->i_op = iop;
fs/fuse/control.c:	inode->i_fop = fop;
fs/fuse/control.c:	inode->i_private = fc;
fs/fuse/control.c:		dentry->d_inode->i_private = NULL;
fs/cachefiles/rdwr.c:	struct address_space *bmapping = object->backer->d_inode->i_mapping;
fs/cachefiles/rdwr.c:	       object->backer->d_inode->i_ino,
fs/cachefiles/rdwr.c:	_enter("{ino=%lu}", object->backer->d_inode->i_ino);
fs/cachefiles/rdwr.c:	bmapping = object->backer->d_inode->i_mapping;
fs/cachefiles/rdwr.c:	ASSERT(S_ISREG(inode->i_mode));
fs/cachefiles/rdwr.c:	ASSERT(inode->i_mapping->a_ops->bmap);
fs/cachefiles/rdwr.c:	ASSERT(inode->i_mapping->a_ops->readpages);
fs/cachefiles/rdwr.c:	if (inode->i_sb->s_blocksize > PAGE_SIZE)
fs/cachefiles/rdwr.c:	shift = PAGE_SHIFT - inode->i_sb->s_blocksize_bits;
fs/cachefiles/rdwr.c:	block = inode->i_mapping->a_ops->bmap(inode->i_mapping, block0);
fs/cachefiles/rdwr.c:	struct address_space *bmapping = object->backer->d_inode->i_mapping;
fs/cachefiles/rdwr.c:	ASSERT(S_ISREG(inode->i_mode));
fs/cachefiles/rdwr.c:	ASSERT(inode->i_mapping->a_ops->bmap);
fs/cachefiles/rdwr.c:	ASSERT(inode->i_mapping->a_ops->readpages);
fs/cachefiles/rdwr.c:	if (inode->i_sb->s_blocksize > PAGE_SIZE)
fs/cachefiles/rdwr.c:	shift = PAGE_SHIFT - inode->i_sb->s_blocksize_bits;
fs/cachefiles/rdwr.c:		block = inode->i_mapping->a_ops->bmap(inode->i_mapping,
fs/cachefiles/rdwr.c:	ASSERT(S_ISREG(object->backer->d_inode->i_mode));
fs/cachefiles/bind.c:	    !root->d_inode->i_op ||
fs/cachefiles/bind.c:	    !root->d_inode->i_op->lookup ||
fs/cachefiles/bind.c:	    !root->d_inode->i_op->mkdir ||
fs/cachefiles/bind.c:	    !root->d_inode->i_op->setxattr ||
fs/cachefiles/bind.c:	    !root->d_inode->i_op->getxattr ||
fs/cachefiles/daemon.c:	if (!S_ISDIR(path.dentry->d_inode->i_mode))
fs/cachefiles/daemon.c:	if (!S_ISDIR(path.dentry->d_inode->i_mode))
fs/cachefiles/namei.c:	if (!S_ISDIR(rep->d_inode->i_mode)) {
fs/cachefiles/namei.c:		mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:	if (!S_ISDIR(cache->graveyard->d_inode->i_mode)) {
fs/cachefiles/namei.c:	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
fs/cachefiles/namei.c:		mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:			mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:	if (!(S_ISDIR(parent->dentry->d_inode->i_mode))) {
fs/cachefiles/namei.c:	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
fs/cachefiles/namei.c:			       next, next->d_inode, next->d_inode->i_ino);
fs/cachefiles/namei.c:		} else if (!S_ISDIR(next->d_inode->i_mode)) {
fs/cachefiles/namei.c:			       next->d_inode->i_ino);
fs/cachefiles/namei.c:			       next, next->d_inode, next->d_inode->i_ino);
fs/cachefiles/namei.c:		} else if (!S_ISDIR(next->d_inode->i_mode) &&
fs/cachefiles/namei.c:			   !S_ISREG(next->d_inode->i_mode)
fs/cachefiles/namei.c:			       next->d_inode->i_ino);
fs/cachefiles/namei.c:		mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:		if (S_ISREG(object->dentry->d_inode->i_mode)) {
fs/cachefiles/namei.c:			aops = object->dentry->d_inode->i_mapping->a_ops;
fs/cachefiles/namei.c:	_leave(" = 0 [%lu]", object->dentry->d_inode->i_ino);
fs/cachefiles/namei.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:	mutex_lock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:		       subdir->d_inode->i_ino);
fs/cachefiles/namei.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:	if (!S_ISDIR(subdir->d_inode->i_mode)) {
fs/cachefiles/namei.c:	if (!subdir->d_inode->i_op ||
fs/cachefiles/namei.c:	    !subdir->d_inode->i_op->setxattr ||
fs/cachefiles/namei.c:	    !subdir->d_inode->i_op->getxattr ||
fs/cachefiles/namei.c:	    !subdir->d_inode->i_op->lookup ||
fs/cachefiles/namei.c:	    !subdir->d_inode->i_op->mkdir ||
fs/cachefiles/namei.c:	    !subdir->d_inode->i_op->create ||
fs/cachefiles/namei.c:	    !subdir->d_inode->i_op->rename ||
fs/cachefiles/namei.c:	    !subdir->d_inode->i_op->rmdir ||
fs/cachefiles/namei.c:	    !subdir->d_inode->i_op->unlink)
fs/cachefiles/namei.c:	_leave(" = [%lu]", subdir->d_inode->i_ino);
fs/cachefiles/namei.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:	mutex_lock_nested(&dir->d_inode->i_mutex, 1);
fs/cachefiles/namei.c:		mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/namei.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/cachefiles/interface.c:	ASSERT(S_ISREG(object->backer->d_inode->i_mode));
fs/cachefiles/interface.c:	mutex_lock(&object->backer->d_inode->i_mutex);
fs/cachefiles/interface.c:	mutex_unlock(&object->backer->d_inode->i_mutex);
fs/cachefiles/interface.c:		ASSERT(S_ISREG(object->backer->d_inode->i_mode));
fs/cachefiles/xattr.c:		       dentry->d_name.name, dentry->d_inode->i_ino,
fs/cachefiles/xattr.c:		       dentry->d_name.name, dentry->d_inode->i_ino,
fs/cachefiles/xattr.c:	       dentry->d_inode->i_ino);
fs/cachefiles/xattr.c:	       dentry->d_name.name, dentry->d_inode->i_ino,
fs/cachefiles/xattr.c:					dentry->d_inode->i_ino, -ret);
fs/cachefiles/xattr.c:						dentry->d_inode->i_ino, -ret);
fs/cachefiles/xattr.c:	       dentry->d_inode->i_ino);
fs/cachefiles/xattr.c:					    dentry->d_inode->i_ino, -ret);
fs/efs/inode.c:	if (!(inode->i_state & I_NEW))
fs/efs/inode.c:	inode_index = inode->i_ino /
fs/efs/inode.c:	offset = (inode->i_ino %
fs/efs/inode.c:	bh = sb_bread(inode->i_sb, block);
fs/efs/inode.c:	inode->i_mode  = be16_to_cpu(efs_inode->di_mode);
fs/efs/inode.c:	set_nlink(inode, be16_to_cpu(efs_inode->di_nlink));
fs/efs/inode.c:	i_uid_write(inode, (uid_t)be16_to_cpu(efs_inode->di_uid));
fs/efs/inode.c:	i_gid_write(inode, (gid_t)be16_to_cpu(efs_inode->di_gid));
fs/efs/inode.c:	inode->i_size  = be32_to_cpu(efs_inode->di_size);
fs/efs/inode.c:	inode->i_atime.tv_sec = be32_to_cpu(efs_inode->di_atime);
fs/efs/inode.c:	inode->i_mtime.tv_sec = be32_to_cpu(efs_inode->di_mtime);
fs/efs/inode.c:	inode->i_ctime.tv_sec = be32_to_cpu(efs_inode->di_ctime);
fs/efs/inode.c:	inode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;
fs/efs/inode.c:	if (inode->i_size == 0) {
fs/efs/inode.c:		inode->i_blocks = 0;
fs/efs/inode.c:		inode->i_blocks = ((inode->i_size - 1) >> EFS_BLOCKSIZE_BITS) + 1;
fs/efs/inode.c:	rdev = be16_to_cpu(efs_inode->di_u.di_dev.odev);
fs/efs/inode.c:		rdev = be32_to_cpu(efs_inode->di_u.di_dev.ndev);
fs/efs/inode.c:	in->numextents = be16_to_cpu(efs_inode->di_numextents);
fs/efs/inode.c:		extent_copy(&(efs_inode->di_u.di_extents[i]), &(in->extents[i]));
fs/efs/inode.c:			printk(KERN_WARNING "EFS: extent %d has bad magic number in inode %lu\n", i, inode->i_ino);
fs/efs/inode.c:		inode->i_ino, in->numextents, inode->i_mode);
fs/efs/inode.c:	switch (inode->i_mode & S_IFMT) {
fs/efs/inode.c:			inode->i_op = &efs_dir_inode_operations; 
fs/efs/inode.c:			inode->i_fop = &efs_dir_operations; 
fs/efs/inode.c:			inode->i_fop = &generic_ro_fops;
fs/efs/inode.c:			inode->i_data.a_ops = &efs_aops;
fs/efs/inode.c:			inode->i_op = &page_symlink_inode_operations;
fs/efs/inode.c:			inode->i_data.a_ops = &efs_symlink_aops;
fs/efs/inode.c:			init_special_inode(inode, inode->i_mode, device);
fs/efs/inode.c:			printk(KERN_WARNING "EFS: unsupported inode mode %o\n", inode->i_mode);
fs/efs/inode.c:	printk(KERN_WARNING "EFS: failed to read inode %lu\n", inode->i_ino);
fs/efs/inode.c:	struct efs_sb_info    *sb = SUPER_INFO(inode->i_sb);
fs/efs/inode.c:			bh = sb_bread(inode->i_sb, iblock);
fs/efs/super.c:	call_rcu(&inode->i_rcu, efs_i_callback);
fs/efs/dir.c:	if (inode->i_size & (EFS_DIRBSIZE-1))
fs/efs/dir.c:	while (block < inode->i_blocks) {
fs/efs/dir.c:		bh = sb_bread(inode->i_sb, efs_bmap(inode, block));
fs/efs/symlink.c:	efs_block_t size = inode->i_size;
fs/efs/symlink.c:	bh = sb_bread(inode->i_sb, efs_bmap(inode, 0));
fs/efs/symlink.c:		bh = sb_bread(inode->i_sb, efs_bmap(inode, 1));
fs/efs/file.c:	if (iblock >= inode->i_blocks) {
fs/efs/file.c:			inode->i_blocks,
fs/efs/file.c:			inode->i_size);
fs/efs/file.c:		map_bh(bh_result, inode->i_sb, phys);
fs/efs/file.c:	if (!(block < inode->i_blocks)) {
fs/efs/file.c:			inode->i_blocks,
fs/efs/file.c:			inode->i_size);
fs/efs/namei.c:	if (inode->i_size & (EFS_DIRBSIZE-1))
fs/efs/namei.c:	for(block = 0; block < inode->i_blocks; block++) {
fs/efs/namei.c:		bh = sb_bread(inode->i_sb, efs_bmap(inode, block));
fs/efs/namei.c:	if (generation && inode->i_generation != generation) {
fs/efs/namei.c:		parent = d_obtain_alias(efs_iget(child->d_inode->i_sb, ino));
fs/attr.c:	    (!uid_eq(current_fsuid(), inode->i_uid) ||
fs/attr.c:	     !uid_eq(attr->ia_uid, inode->i_uid)) &&
fs/attr.c:	    (!uid_eq(current_fsuid(), inode->i_uid) ||
fs/attr.c:	    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&
fs/attr.c:				inode->i_gid) &&
fs/attr.c:	if (inode->i_size < offset) {
fs/attr.c:		if (offset > inode->i_sb->s_maxbytes)
fs/attr.c:		inode->i_uid = attr->ia_uid;
fs/attr.c:		inode->i_gid = attr->ia_gid;
fs/attr.c:		inode->i_atime = timespec_trunc(attr->ia_atime,
fs/attr.c:						inode->i_sb->s_time_gran);
fs/attr.c:		inode->i_mtime = timespec_trunc(attr->ia_mtime,
fs/attr.c:						inode->i_sb->s_time_gran);
fs/attr.c:		inode->i_ctime = timespec_trunc(attr->ia_ctime,
fs/attr.c:						inode->i_sb->s_time_gran);
fs/attr.c:		if (!in_group_p(inode->i_gid) &&
fs/attr.c:		inode->i_mode = mode;
fs/attr.c:	umode_t mode = inode->i_mode;
fs/attr.c:	WARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));
fs/attr.c:		if (attr->ia_size != inode->i_size)
fs/attr.c:			inode->i_flags &= ~S_NOSEC;
fs/attr.c:	now = current_fs_time(inode->i_sb);
fs/attr.c:			attr->ia_mode = (inode->i_mode & ~S_ISUID);
fs/attr.c:				attr->ia_mode = inode->i_mode;
fs/attr.c:	if (inode->i_op->setattr)
fs/attr.c:		error = inode->i_op->setattr(dentry, attr);
fs/locks.c:	for (lockp = &inode->i_flock; *lockp != NULL; lockp = &(*lockp)->fl_next)
fs/locks.c: * Protects the two list heads above, plus the inode->i_flock list
fs/locks.c:	for (cfl = filp->f_path.dentry->d_inode->i_flock; cfl; cfl = cfl->fl_next) {
fs/locks.c:	before = &inode->i_flock;
fs/locks.c:	for (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {
fs/locks.c:	before = &inode->i_flock;
fs/locks.c:	flock = inode->i_flock;
fs/locks.c:		for (flock = inode->i_flock; flock && IS_LEASE(flock);
fs/locks.c:	struct file_lock *flock = inode->i_flock;
fs/locks.c:		*time = current_fs_time(inode->i_sb);
fs/locks.c:		*time = inode->i_mtime;
fs/locks.c:	for (fl = filp->f_path.dentry->d_inode->i_flock; fl && IS_LEASE(fl);
fs/locks.c:	if ((arg == F_RDLCK) && (atomic_read(&inode->i_writecount) > 0))
fs/locks.c:		|| (atomic_read(&inode->i_count) > 1)))
fs/locks.c:	for (before = &inode->i_flock;
fs/locks.c:	for (before = &inode->i_flock;
fs/locks.c:	if ((!uid_eq(current_fsuid(), inode->i_uid)) && !capable(CAP_LEASE))
fs/locks.c:	if (!S_ISREG(inode->i_mode))
fs/locks.c:	 * update of inode->i_flock and check for it done in close().
fs/locks.c:	if (!filp->f_path.dentry->d_inode->i_flock)
fs/locks.c:	if (!inode->i_flock)
fs/locks.c:	before = &inode->i_flock;
fs/locks.c:				inode->i_sb->s_id, inode->i_ino);
fs/locks.c:				MAJOR(inode->i_sb->s_dev),
fs/locks.c:				MINOR(inode->i_sb->s_dev), inode->i_ino);
fs/locks.c:	for (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {
fs/locks.c:	for (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {
fs/generic_acl.c:	if (S_ISLNK(inode->i_mode))
fs/generic_acl.c:			error = posix_acl_equiv_mode(acl, &inode->i_mode);
fs/generic_acl.c:			inode->i_ctime = CURRENT_TIME;
fs/generic_acl.c:			if (!S_ISDIR(inode->i_mode)) {
fs/generic_acl.c:	if (!S_ISLNK(inode->i_mode))
fs/generic_acl.c:		if (S_ISDIR(inode->i_mode))
fs/generic_acl.c:		error = posix_acl_create(&acl, GFP_KERNEL, &inode->i_mode);
fs/generic_acl.c:		inode->i_mode &= ~current_umask();
fs/generic_acl.c:	if (S_ISLNK(inode->i_mode))
fs/generic_acl.c:		error = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
fs/ufs/inode.c:	struct ufs_sb_private_info *uspi = UFS_SB(inode->i_sb)->s_uspi;
fs/ufs/inode.c:		ufs_warning(inode->i_sb, "ufs_block_to_path", "block > big");
fs/ufs/inode.c:	struct super_block *sb = inode->i_sb;
fs/ufs/inode.c:	struct super_block *sb = inode->i_sb;
fs/ufs/inode.c:	     "metadata %d\n", inode->i_ino, (unsigned long long)fragment,
fs/ufs/inode.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/ufs/inode.c:	struct super_block *sb = inode->i_sb;
fs/ufs/inode.c:	     inode->i_ino, (unsigned long long)fragment,
fs/ufs/inode.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/ufs/inode.c:	struct super_block * sb = inode->i_sb;
fs/ufs/inode.c:	UFSD("ENTER, ino %lu, fragment %llu\n", inode->i_ino, (unsigned long long)fragment);
fs/ufs/inode.c:	if (to > inode->i_size)
fs/ufs/inode.c:		truncate_pagecache(inode, to, inode->i_size);
fs/ufs/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/ufs/inode.c:		inode->i_op = &ufs_file_inode_operations;
fs/ufs/inode.c:		inode->i_fop = &ufs_file_operations;
fs/ufs/inode.c:		inode->i_mapping->a_ops = &ufs_aops;
fs/ufs/inode.c:	} else if (S_ISDIR(inode->i_mode)) {
fs/ufs/inode.c:		inode->i_op = &ufs_dir_inode_operations;
fs/ufs/inode.c:		inode->i_fop = &ufs_dir_operations;
fs/ufs/inode.c:		inode->i_mapping->a_ops = &ufs_aops;
fs/ufs/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/ufs/inode.c:		if (!inode->i_blocks)
fs/ufs/inode.c:			inode->i_op = &ufs_fast_symlink_inode_operations;
fs/ufs/inode.c:			inode->i_op = &ufs_symlink_inode_operations;
fs/ufs/inode.c:			inode->i_mapping->a_ops = &ufs_aops;
fs/ufs/inode.c:		init_special_inode(inode, inode->i_mode,
fs/ufs/inode.c:				   ufs_get_inode_dev(inode->i_sb, UFS_I(inode)));
fs/ufs/inode.c:	struct super_block *sb = inode->i_sb;
fs/ufs/inode.c:	inode->i_mode = mode = fs16_to_cpu(sb, ufs_inode->ui_mode);
fs/ufs/inode.c:	set_nlink(inode, fs16_to_cpu(sb, ufs_inode->ui_nlink));
fs/ufs/inode.c:	if (inode->i_nlink == 0) {
fs/ufs/inode.c:		ufs_error (sb, "ufs_read_inode", "inode %lu has zero nlink\n", inode->i_ino);
fs/ufs/inode.c:	inode->i_size = fs64_to_cpu(sb, ufs_inode->ui_size);
fs/ufs/inode.c:	inode->i_atime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_atime.tv_sec);
fs/ufs/inode.c:	inode->i_ctime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_ctime.tv_sec);
fs/ufs/inode.c:	inode->i_mtime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_mtime.tv_sec);
fs/ufs/inode.c:	inode->i_mtime.tv_nsec = 0;
fs/ufs/inode.c:	inode->i_atime.tv_nsec = 0;
fs/ufs/inode.c:	inode->i_ctime.tv_nsec = 0;
fs/ufs/inode.c:	inode->i_blocks = fs32_to_cpu(sb, ufs_inode->ui_blocks);
fs/ufs/inode.c:	inode->i_generation = fs32_to_cpu(sb, ufs_inode->ui_gen);
fs/ufs/inode.c:	ufsi->i_flags = fs32_to_cpu(sb, ufs_inode->ui_flags);
fs/ufs/inode.c:	ufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);
fs/ufs/inode.c:	ufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);
fs/ufs/inode.c:	if (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {
fs/ufs/inode.c:		memcpy(ufsi->i_u1.i_data, &ufs_inode->ui_u2.ui_addr,
fs/ufs/inode.c:		       sizeof(ufs_inode->ui_u2.ui_addr));
fs/ufs/inode.c:		memcpy(ufsi->i_u1.i_symlink, ufs_inode->ui_u2.ui_symlink,
fs/ufs/inode.c:		       sizeof(ufs_inode->ui_u2.ui_symlink) - 1);
fs/ufs/inode.c:		ufsi->i_u1.i_symlink[sizeof(ufs_inode->ui_u2.ui_symlink) - 1] = 0;
fs/ufs/inode.c:	struct super_block *sb = inode->i_sb;
fs/ufs/inode.c:	UFSD("Reading ufs2 inode, ino %lu\n", inode->i_ino);
fs/ufs/inode.c:	inode->i_mode = mode = fs16_to_cpu(sb, ufs2_inode->ui_mode);
fs/ufs/inode.c:	set_nlink(inode, fs16_to_cpu(sb, ufs2_inode->ui_nlink));
fs/ufs/inode.c:	if (inode->i_nlink == 0) {
fs/ufs/inode.c:		ufs_error (sb, "ufs_read_inode", "inode %lu has zero nlink\n", inode->i_ino);
fs/ufs/inode.c:	i_uid_write(inode, fs32_to_cpu(sb, ufs2_inode->ui_uid));
fs/ufs/inode.c:	i_gid_write(inode, fs32_to_cpu(sb, ufs2_inode->ui_gid));
fs/ufs/inode.c:	inode->i_size = fs64_to_cpu(sb, ufs2_inode->ui_size);
fs/ufs/inode.c:	inode->i_atime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_atime);
fs/ufs/inode.c:	inode->i_ctime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_ctime);
fs/ufs/inode.c:	inode->i_mtime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_mtime);
fs/ufs/inode.c:	inode->i_atime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_atimensec);
fs/ufs/inode.c:	inode->i_ctime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_ctimensec);
fs/ufs/inode.c:	inode->i_mtime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_mtimensec);
fs/ufs/inode.c:	inode->i_blocks = fs64_to_cpu(sb, ufs2_inode->ui_blocks);
fs/ufs/inode.c:	inode->i_generation = fs32_to_cpu(sb, ufs2_inode->ui_gen);
fs/ufs/inode.c:	ufsi->i_flags = fs32_to_cpu(sb, ufs2_inode->ui_flags);
fs/ufs/inode.c:	ufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);
fs/ufs/inode.c:	ufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);
fs/ufs/inode.c:	if (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {
fs/ufs/inode.c:		memcpy(ufsi->i_u1.u2_i_data, &ufs2_inode->ui_u2.ui_addr,
fs/ufs/inode.c:		       sizeof(ufs2_inode->ui_u2.ui_addr));
fs/ufs/inode.c:		memcpy(ufsi->i_u1.i_symlink, ufs2_inode->ui_u2.ui_symlink,
fs/ufs/inode.c:		       sizeof(ufs2_inode->ui_u2.ui_symlink) - 1);
fs/ufs/inode.c:		ufsi->i_u1.i_symlink[sizeof(ufs2_inode->ui_u2.ui_symlink) - 1] = 0;
fs/ufs/inode.c:	if (!(inode->i_state & I_NEW))
fs/ufs/inode.c:	bh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));
fs/ufs/inode.c:			    inode->i_ino);
fs/ufs/inode.c:				      ufs2_inode + ufs_inotofsbo(inode->i_ino));
fs/ufs/inode.c:				      ufs_inode + ufs_inotofsbo(inode->i_ino));
fs/ufs/inode.c:	inode->i_version++;
fs/ufs/inode.c:		(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;
fs/ufs/inode.c:	struct super_block *sb = inode->i_sb;
fs/ufs/inode.c:	ufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);
fs/ufs/inode.c:	ufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);
fs/ufs/inode.c:	ufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);
fs/ufs/inode.c:	ufs_inode->ui_atime.tv_sec = cpu_to_fs32(sb, inode->i_atime.tv_sec);
fs/ufs/inode.c:	ufs_inode->ui_atime.tv_usec = 0;
fs/ufs/inode.c:	ufs_inode->ui_ctime.tv_sec = cpu_to_fs32(sb, inode->i_ctime.tv_sec);
fs/ufs/inode.c:	ufs_inode->ui_ctime.tv_usec = 0;
fs/ufs/inode.c:	ufs_inode->ui_mtime.tv_sec = cpu_to_fs32(sb, inode->i_mtime.tv_sec);
fs/ufs/inode.c:	ufs_inode->ui_mtime.tv_usec = 0;
fs/ufs/inode.c:	ufs_inode->ui_blocks = cpu_to_fs32(sb, inode->i_blocks);
fs/ufs/inode.c:	ufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);
fs/ufs/inode.c:	ufs_inode->ui_gen = cpu_to_fs32(sb, inode->i_generation);
fs/ufs/inode.c:		ufs_inode->ui_u3.ui_sun.ui_shadow = cpu_to_fs32(sb, ufsi->i_shadow);
fs/ufs/inode.c:		ufs_inode->ui_u3.ui_sun.ui_oeftflag = cpu_to_fs32(sb, ufsi->i_oeftflag);
fs/ufs/inode.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {
fs/ufs/inode.c:		/* ufs_inode->ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode->i_rdev); */
fs/ufs/inode.c:		ufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.i_data[0];
fs/ufs/inode.c:	} else if (inode->i_blocks) {
fs/ufs/inode.c:		memcpy(&ufs_inode->ui_u2.ui_addr, ufsi->i_u1.i_data,
fs/ufs/inode.c:		       sizeof(ufs_inode->ui_u2.ui_addr));
fs/ufs/inode.c:		memcpy(&ufs_inode->ui_u2.ui_symlink, ufsi->i_u1.i_symlink,
fs/ufs/inode.c:		       sizeof(ufs_inode->ui_u2.ui_symlink));
fs/ufs/inode.c:	if (!inode->i_nlink)
fs/ufs/inode.c:	struct super_block *sb = inode->i_sb;
fs/ufs/inode.c:	ufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);
fs/ufs/inode.c:	ufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);
fs/ufs/inode.c:	ufs_inode->ui_uid = cpu_to_fs32(sb, i_uid_read(inode));
fs/ufs/inode.c:	ufs_inode->ui_gid = cpu_to_fs32(sb, i_gid_read(inode));
fs/ufs/inode.c:	ufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);
fs/ufs/inode.c:	ufs_inode->ui_atime = cpu_to_fs64(sb, inode->i_atime.tv_sec);
fs/ufs/inode.c:	ufs_inode->ui_atimensec = cpu_to_fs32(sb, inode->i_atime.tv_nsec);
fs/ufs/inode.c:	ufs_inode->ui_ctime = cpu_to_fs64(sb, inode->i_ctime.tv_sec);
fs/ufs/inode.c:	ufs_inode->ui_ctimensec = cpu_to_fs32(sb, inode->i_ctime.tv_nsec);
fs/ufs/inode.c:	ufs_inode->ui_mtime = cpu_to_fs64(sb, inode->i_mtime.tv_sec);
fs/ufs/inode.c:	ufs_inode->ui_mtimensec = cpu_to_fs32(sb, inode->i_mtime.tv_nsec);
fs/ufs/inode.c:	ufs_inode->ui_blocks = cpu_to_fs64(sb, inode->i_blocks);
fs/ufs/inode.c:	ufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);
fs/ufs/inode.c:	ufs_inode->ui_gen = cpu_to_fs32(sb, inode->i_generation);
fs/ufs/inode.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {
fs/ufs/inode.c:		/* ufs_inode->ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode->i_rdev); */
fs/ufs/inode.c:		ufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.u2_i_data[0];
fs/ufs/inode.c:	} else if (inode->i_blocks) {
fs/ufs/inode.c:		memcpy(&ufs_inode->ui_u2.ui_addr, ufsi->i_u1.u2_i_data,
fs/ufs/inode.c:		       sizeof(ufs_inode->ui_u2.ui_addr));
fs/ufs/inode.c:		memcpy(&ufs_inode->ui_u2.ui_symlink, ufsi->i_u1.i_symlink,
fs/ufs/inode.c:		       sizeof(ufs_inode->ui_u2.ui_symlink));
fs/ufs/inode.c:	if (!inode->i_nlink)
fs/ufs/inode.c:	struct super_block *sb = inode->i_sb;
fs/ufs/inode.c:	UFSD("ENTER, ino %lu\n", inode->i_ino);
fs/ufs/inode.c:	if (inode->i_ino < UFS_ROOTINO ||
fs/ufs/inode.c:	    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {
fs/ufs/inode.c:		ufs_warning (sb, "ufs_read_inode", "bad inode number (%lu)\n", inode->i_ino);
fs/ufs/inode.c:	bh = sb_bread(sb, ufs_inotofsba(inode->i_ino));
fs/ufs/inode.c:		ufs_warning (sb, "ufs_read_inode", "unable to read inode %lu\n", inode->i_ino);
fs/ufs/inode.c:				  ufs2_inode + ufs_inotofsbo(inode->i_ino));
fs/ufs/inode.c:		ufs1_update_inode(inode, ufs_inode + ufs_inotofsbo(inode->i_ino));
fs/ufs/inode.c:	lock_ufs(inode->i_sb);
fs/ufs/inode.c:	unlock_ufs(inode->i_sb);
fs/ufs/inode.c:	if (!inode->i_nlink && !is_bad_inode(inode))
fs/ufs/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/ufs/inode.c:		lock_ufs(inode->i_sb);
fs/ufs/inode.c:		old_i_size = inode->i_size;
fs/ufs/inode.c:		inode->i_size = 0;
fs/ufs/inode.c:		if (inode->i_blocks && ufs_truncate(inode, old_i_size))
fs/ufs/inode.c:			ufs_warning(inode->i_sb, __func__, "ufs_truncate failed\n");
fs/ufs/inode.c:		unlock_ufs(inode->i_sb);
fs/ufs/inode.c:		lock_ufs(inode->i_sb);
fs/ufs/inode.c:		unlock_ufs(inode->i_sb);
fs/ufs/super.c:	if (generation && inode->i_generation != generation) {
fs/ufs/super.c:	return d_obtain_alias(ufs_iget(child->d_inode->i_sb, ino));
fs/ufs/super.c:	call_rcu(&inode->i_rcu, ufs_i_callback);
fs/ufs/truncate.c:#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)
fs/ufs/truncate.c:#define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)
fs/ufs/truncate.c:	UFSD("ENTER: ino %lu\n", inode->i_ino);
fs/ufs/truncate.c:	sb = inode->i_sb;
fs/ufs/truncate.c:	     " frag3 %llu, frag4 %llu\n", inode->i_ino,
fs/ufs/truncate.c:	UFSD("EXIT: ino %lu\n", inode->i_ino);
fs/ufs/truncate.c:	     inode->i_ino, (unsigned long long)offset, p);
fs/ufs/truncate.c:	sb = inode->i_sb;
fs/ufs/truncate.c:	UFSD("EXIT: ino %lu\n", inode->i_ino);
fs/ufs/truncate.c:	UFSD("ENTER: ino %lu\n", inode->i_ino);
fs/ufs/truncate.c:	sb = inode->i_sb;
fs/ufs/truncate.c:	UFSD("EXIT: ino %lu\n", inode->i_ino);
fs/ufs/truncate.c:	struct super_block *sb = inode->i_sb;
fs/ufs/truncate.c:	UFSD("ENTER: ino %lu\n", inode->i_ino);
fs/ufs/truncate.c:	UFSD("EXIT: ino %lu\n", inode->i_ino);
fs/ufs/truncate.c:	struct super_block *sb = inode->i_sb;
fs/ufs/truncate.c:	struct address_space *mapping = inode->i_mapping;
fs/ufs/truncate.c:				       (PAGE_CACHE_SHIFT - inode->i_blkbits));
fs/ufs/truncate.c:       end = lastfrag & ((1 << (PAGE_CACHE_SHIFT - inode->i_blkbits)) - 1);
fs/ufs/truncate.c:	struct super_block *sb = inode->i_sb;
fs/ufs/truncate.c:	     inode->i_ino, (unsigned long long)i_size_read(inode),
fs/ufs/truncate.c:	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
fs/ufs/truncate.c:	      S_ISLNK(inode->i_mode)))
fs/ufs/truncate.c:	block_truncate_page(inode->i_mapping, inode->i_size, ufs_getfrag_block);
fs/ufs/truncate.c:		if (IS_SYNC(inode) && (inode->i_state & I_DIRTY))
fs/ufs/truncate.c:	inode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;
fs/ufs/truncate.c:	if (ia_valid & ATTR_SIZE && attr->ia_size != inode->i_size) {
fs/ufs/truncate.c:		loff_t old_i_size = inode->i_size;
fs/ufs/truncate.c:		lock_ufs(inode->i_sb);
fs/ufs/truncate.c:		unlock_ufs(inode->i_sb);
fs/ufs/util.h:		return fs32_to_cpu(sb, inode->ui_u3.ui_44.ui_uid);
fs/ufs/util.h:		if (inode->ui_u1.oldids.ui_suid == 0xFFFF)
fs/ufs/util.h:			return fs32_to_cpu(sb, inode->ui_u3.ui_sun.ui_uid);
fs/ufs/util.h:		return fs16_to_cpu(sb, inode->ui_u1.oldids.ui_suid);
fs/ufs/util.h:		inode->ui_u3.ui_44.ui_uid = cpu_to_fs32(sb, value);
fs/ufs/util.h:		inode->ui_u1.oldids.ui_suid = cpu_to_fs16(sb, value);
fs/ufs/util.h:		inode->ui_u3.ui_sun.ui_uid = cpu_to_fs32(sb, value);
fs/ufs/util.h:		inode->ui_u1.oldids.ui_suid = cpu_to_fs16(sb, value);
fs/ufs/util.h:		return fs32_to_cpu(sb, inode->ui_u3.ui_44.ui_gid);
fs/ufs/util.h:		if (inode->ui_u1.oldids.ui_suid == 0xFFFF)
fs/ufs/util.h:			return fs32_to_cpu(sb, inode->ui_u3.ui_sun.ui_gid);
fs/ufs/util.h:		return fs16_to_cpu(sb, inode->ui_u1.oldids.ui_sgid);
fs/ufs/util.h:		inode->ui_u3.ui_44.ui_gid = cpu_to_fs32(sb, value);
fs/ufs/util.h:		inode->ui_u1.oldids.ui_sgid =  cpu_to_fs16(sb, value);
fs/ufs/util.h:		inode->ui_u3.ui_sun.ui_gid = cpu_to_fs32(sb, value);
fs/ufs/util.h:		inode->ui_u1.oldids.ui_sgid =  cpu_to_fs16(sb, value);
fs/ufs/dir.c:	return (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;
fs/ufs/dir.c:	de->d_ino = cpu_to_fs32(dir->i_sb, inode->i_ino);
fs/ufs/dir.c:	ufs_set_de_type(dir->i_sb, de, inode->i_mode);
fs/ufs/dir.c:	unsigned last_byte = inode->i_size;
fs/ufs/dir.c:	de->d_ino = cpu_to_fs32(sb, inode->i_ino);
fs/ufs/dir.c:	ufs_set_de_type(sb, de, inode->i_mode);
fs/ufs/dir.c:	struct super_block *sb = inode->i_sb;
fs/ufs/dir.c:	int need_revalidate = filp->f_version != inode->i_version;
fs/ufs/dir.c:	if (pos > inode->i_size - UFS_DIR_REC_LEN(1))
fs/ufs/dir.c:				  inode->i_ino);
fs/ufs/dir.c:			filp->f_version = inode->i_version;
fs/ufs/dir.c:	struct super_block *sb = inode->i_sb;
fs/ufs/dir.c:			ufs_error(inode->i_sb, __func__,
fs/ufs/dir.c:	inode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;
fs/ufs/dir.c:	struct address_space *mapping = inode->i_mapping;
fs/ufs/dir.c:	de->d_ino = cpu_to_fs32(sb, inode->i_ino);
fs/ufs/dir.c:	ufs_set_de_type(sb, de, inode->i_mode);
fs/ufs/dir.c:	struct super_block *sb = inode->i_sb;
fs/ufs/dir.c:				ufs_error(inode->i_sb, __func__,
fs/ufs/dir.c:					if (inode->i_ino !=
fs/ufs/balloc.c:	sb = inode->i_sb;
fs/ufs/balloc.c:	sb = inode->i_sb;
fs/ufs/balloc.c:		1 << (PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/ufs/balloc.c:	struct address_space * const mapping = inode->i_mapping;
fs/ufs/balloc.c:	      inode->i_ino, count,
fs/ufs/balloc.c:	last_index = end >> (PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/ufs/balloc.c:		index = i >> (PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/ufs/balloc.c:				ufs_error(inode->i_sb, __func__,
fs/ufs/balloc.c:					map_bh(bh, inode->i_sb, oldb + pos);
fs/ufs/balloc.c:					ufs_error(inode->i_sb, __func__,
fs/ufs/balloc.c:		bh = sb_getblk(inode->i_sb, beg);
fs/ufs/balloc.c:		memset(bh->b_data, 0, inode->i_sb->s_blocksize);
fs/ufs/balloc.c:	     inode->i_ino, (unsigned long long)fragment,
fs/ufs/balloc.c:	sb = inode->i_sb;
fs/ufs/balloc.c:		cgno = ufs_inotocg (inode->i_ino);
fs/ufs/balloc.c:	sb = inode->i_sb;
fs/ufs/balloc.c:	     inode->i_ino, cgno, (unsigned long long)goal, count);
fs/ufs/balloc.c:	sb = inode->i_sb;
fs/ufs/balloc.c:	sb = inode->i_sb;
fs/ufs/ufs_fs.h:	__fs32	fs_iblkno;	/* offset of inode-blocks in filesys */
fs/ufs/ufs_fs.h:	__u32	s_iblkno;	/* offset of inode-blocks in filesys */
fs/ufs/namei.c:		inode->i_op = &ufs_file_inode_operations;
fs/ufs/namei.c:		inode->i_fop = &ufs_file_operations;
fs/ufs/namei.c:		inode->i_mapping->a_ops = &ufs_aops;
fs/ufs/namei.c:		ufs_set_inode_dev(inode->i_sb, UFS_I(inode), rdev);
fs/ufs/namei.c:		inode->i_op = &ufs_symlink_inode_operations;
fs/ufs/namei.c:		inode->i_mapping->a_ops = &ufs_aops;
fs/ufs/namei.c:		inode->i_op = &ufs_fast_symlink_inode_operations;
fs/ufs/namei.c:		inode->i_size = l-1;
fs/ufs/namei.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/ufs/namei.c:	inode->i_op = &ufs_dir_inode_operations;
fs/ufs/namei.c:	inode->i_fop = &ufs_dir_operations;
fs/ufs/namei.c:	inode->i_mapping->a_ops = &ufs_aops;
fs/ufs/namei.c:	inode->i_ctime = dir->i_ctime;
fs/ufs/namei.c:			inode->i_size = 0;
fs/ufs/namei.c:	if (S_ISDIR(old_inode->i_mode)) {
fs/ufs/namei.c:		new_inode->i_ctime = CURRENT_TIME_SEC;
fs/ufs/namei.c:	old_inode->i_ctime = CURRENT_TIME_SEC;
fs/ufs/ialloc.c:	UFSD("ENTER, ino %lu\n", inode->i_ino);
fs/ufs/ialloc.c:	sb = inode->i_sb;
fs/ufs/ialloc.c:	ino = inode->i_ino;
fs/ufs/ialloc.c:	is_directory = S_ISDIR(inode->i_mode);
fs/ufs/ialloc.c:	inode->i_ino = cg * uspi->s_ipg + bit;
fs/ufs/ialloc.c:	inode->i_blocks = 0;
fs/ufs/ialloc.c:	inode->i_generation = 0;
fs/ufs/ialloc.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
fs/ufs/ialloc.c:		bh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));
fs/ufs/ialloc.c:				    inode->i_ino);
fs/ufs/ialloc.c:		ufs2_inode += ufs_inotofsbo(inode->i_ino);
fs/ufs/ialloc.c:		ufs2_inode->ui_birthtime = cpu_to_fs64(sb, CURRENT_TIME.tv_sec);
fs/ufs/ialloc.c:		ufs2_inode->ui_birthnsec = cpu_to_fs32(sb, CURRENT_TIME.tv_nsec);
fs/ufs/ialloc.c:	UFSD("allocating inode %lu\n", inode->i_ino);
fs/affs/amigaffs.c:	spin_lock(&inode->i_lock);
fs/affs/amigaffs.c:	hlist_for_each_entry(dentry, p, &inode->i_dentry, d_alias) {
fs/affs/amigaffs.c:			dentry->d_fsdata = (void *)inode->i_ino;
fs/affs/amigaffs.c:	spin_unlock(&inode->i_lock);
fs/affs/amigaffs.c:	struct super_block *sb = inode->i_sb;
fs/affs/amigaffs.c:	pr_debug("AFFS: remove_link(key=%ld)\n", inode->i_ino);
fs/affs/amigaffs.c:	bh = affs_bread(sb, inode->i_ino);
fs/affs/amigaffs.c:	if (inode->i_ino == link_ino) {
fs/affs/amigaffs.c:	struct super_block *sb = inode->i_sb;
fs/affs/amigaffs.c:	bh = affs_bread(sb, inode->i_ino);
fs/affs/amigaffs.c:	pr_debug("AFFS: remove_header(key=%ld)\n", inode->i_ino);
fs/affs/amigaffs.c:	if (inode->i_nlink > 1)
fs/affs/amigaffs.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/affs/amigaffs.c:	umode_t mode = inode->i_mode;
fs/affs/inode.c:	if (!(inode->i_state & I_NEW))
fs/affs/inode.c:	pr_debug("AFFS: affs_iget(%lu)\n", inode->i_ino);
fs/affs/inode.c:	block = inode->i_ino;
fs/affs/inode.c:	inode->i_size = 0;
fs/affs/inode.c:	inode->i_mode = 0;
fs/affs/inode.c:		inode->i_mode = sbi->s_mode;
fs/affs/inode.c:		inode->i_mode = prot_to_mode(prot);
fs/affs/inode.c:		inode->i_uid = sbi->s_uid;
fs/affs/inode.c:		inode->i_gid = sbi->s_gid;
fs/affs/inode.c:		inode->i_uid = sbi->s_uid;
fs/affs/inode.c:		inode->i_gid = sbi->s_gid;
fs/affs/inode.c:			if (inode->i_mode & S_IRUSR)
fs/affs/inode.c:				inode->i_mode |= S_IXUSR;
fs/affs/inode.c:			if (inode->i_mode & S_IRGRP)
fs/affs/inode.c:				inode->i_mode |= S_IXGRP;
fs/affs/inode.c:			if (inode->i_mode & S_IROTH)
fs/affs/inode.c:				inode->i_mode |= S_IXOTH;
fs/affs/inode.c:			inode->i_mode |= S_IFDIR;
fs/affs/inode.c:			inode->i_mode = S_IRUGO | S_IXUGO | S_IWUSR | S_IFDIR;
fs/affs/inode.c:		//inode->i_mode |= S_ISVTX;
fs/affs/inode.c:		inode->i_op = &affs_dir_inode_operations;
fs/affs/inode.c:		inode->i_fop = &affs_dir_operations;
fs/affs/inode.c:		inode->i_mode |= S_IFDIR;
fs/affs/inode.c:		inode->i_mode |= S_IFREG;
fs/affs/inode.c:		AFFS_I(inode)->mmu_private = inode->i_size = size;
fs/affs/inode.c:		if (inode->i_size) {
fs/affs/inode.c:		inode->i_mapping->a_ops = (sbi->s_flags & SF_OFS) ? &affs_aops_ofs : &affs_aops;
fs/affs/inode.c:		inode->i_op = &affs_file_inode_operations;
fs/affs/inode.c:		inode->i_fop = &affs_file_operations;
fs/affs/inode.c:		inode->i_mode |= S_IFLNK;
fs/affs/inode.c:		inode->i_op = &affs_symlink_inode_operations;
fs/affs/inode.c:		inode->i_data.a_ops = &affs_symlink_aops;
fs/affs/inode.c:	inode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec
fs/affs/inode.c:	inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_atime.tv_nsec = 0;
fs/affs/inode.c:	struct super_block	*sb = inode->i_sb;
fs/affs/inode.c:	pr_debug("AFFS: write_inode(%lu)\n",inode->i_ino);
fs/affs/inode.c:	if (!inode->i_nlink)
fs/affs/inode.c:	bh = affs_bread(sb, inode->i_ino);
fs/affs/inode.c:		affs_error(sb,"write_inode","Cannot read block %lu",inode->i_ino);
fs/affs/inode.c:		secs_to_datestamp(inode->i_mtime.tv_sec,&AFFS_ROOT_TAIL(sb, bh)->root_change);
fs/affs/inode.c:		tail->size = cpu_to_be32(inode->i_size);
fs/affs/inode.c:		secs_to_datestamp(inode->i_mtime.tv_sec,&tail->change);
fs/affs/inode.c:		if (!(inode->i_ino == AFFS_SB(sb)->s_root_block)) {
fs/affs/inode.c:	pr_debug("AFFS: notify_change(%lu,0x%x)\n",inode->i_ino,attr->ia_valid);
fs/affs/inode.c:	if (((attr->ia_valid & ATTR_UID) && (AFFS_SB(inode->i_sb)->s_flags & SF_SETUID)) ||
fs/affs/inode.c:	    ((attr->ia_valid & ATTR_GID) && (AFFS_SB(inode->i_sb)->s_flags & SF_SETGID)) ||
fs/affs/inode.c:	     (AFFS_SB(inode->i_sb)->s_flags & (SF_SETMODE | SF_IMMUTABLE)))) {
fs/affs/inode.c:		if (!(AFFS_SB(inode->i_sb)->s_flags & SF_QUIET))
fs/affs/inode.c:	pr_debug("AFFS: evict_inode(ino=%lu, nlink=%u)\n", inode->i_ino, inode->i_nlink);
fs/affs/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/affs/inode.c:	if (!inode->i_nlink) {
fs/affs/inode.c:		inode->i_size = 0;
fs/affs/inode.c:	if (!inode->i_nlink)
fs/affs/inode.c:		affs_free_block(inode->i_sb, inode->i_ino);
fs/affs/inode.c:	inode->i_uid     = current_fsuid();
fs/affs/inode.c:	inode->i_gid     = current_fsgid();
fs/affs/inode.c:	inode->i_ino     = block;
fs/affs/inode.c:	inode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
fs/affs/inode.c:	         (u32)inode->i_ino, (int)dentry->d_name.len, dentry->d_name.name, type);
fs/affs/inode.c:	bh = affs_bread(sb, inode->i_ino);
fs/affs/inode.c:		AFFS_TAIL(sb, bh)->original = cpu_to_be32(inode->i_ino);
fs/affs/super.c:	call_rcu(&inode->i_rcu, affs_i_callback);
fs/affs/super.c:	size = sb->s_bdev->bd_inode->i_size >> 9;
fs/affs/dir.c:	struct super_block	*sb = inode->i_sb;
fs/affs/dir.c:	pr_debug("AFFS: readdir(ino=%lu,f_pos=%lx)\n",inode->i_ino,(unsigned long)filp->f_pos);
fs/affs/dir.c:		if (filldir(dirent, ".", 1, f_pos, inode->i_ino, DT_DIR) < 0)
fs/affs/dir.c:	dir_bh = affs_bread(sb, inode->i_ino);
fs/affs/dir.c:	if (ino && filp->f_version == inode->i_version) {
fs/affs/dir.c:	filp->f_version = inode->i_version;
fs/affs/symlink.c:	pr_debug("AFFS: follow_link(ino=%lu)\n",inode->i_ino);
fs/affs/symlink.c:	bh = affs_bread(inode->i_sb, inode->i_ino);
fs/affs/symlink.c:		struct affs_sb_info *sbi = AFFS_SB(inode->i_sb);
fs/affs/file.c:		 inode->i_ino, atomic_read(&AFFS_I(inode)->i_opencnt));
fs/affs/file.c:		 inode->i_ino, atomic_read(&AFFS_I(inode)->i_opencnt));
fs/affs/file.c:		mutex_lock(&inode->i_mutex);
fs/affs/file.c:		if (inode->i_size != AFFS_I(inode)->mmu_private)
fs/affs/file.c:		mutex_unlock(&inode->i_mutex);
fs/affs/file.c:	struct super_block	*sb = inode->i_sb;
fs/affs/file.c:			AFFS_I(inode)->i_lc[0] = inode->i_ino;
fs/affs/file.c:	struct super_block *sb = inode->i_sb;
fs/affs/file.c:	AFFS_TAIL(sb, new_bh)->parent = cpu_to_be32(inode->i_ino);
fs/affs/file.c:	struct super_block *sb = inode->i_sb;
fs/affs/file.c:		ext_key = inode->i_ino;
fs/affs/file.c:	struct super_block	*sb = inode->i_sb;
fs/affs/file.c:	pr_debug("AFFS: get_block(%u, %lu)\n", (u32)inode->i_ino, (unsigned long)block);
fs/affs/file.c:	affs_error(inode->i_sb,"get_block","strange block request %d", block);
fs/affs/file.c:	if (to > inode->i_size) {
fs/affs/file.c:		truncate_pagecache(inode, to, inode->i_size);
fs/affs/file.c:		bh = affs_bread(inode->i_sb, tmp_bh.b_blocknr);
fs/affs/file.c:		bh = affs_getzeroblk(inode->i_sb, tmp_bh.b_blocknr);
fs/affs/file.c:		bh = affs_getemptyblk(inode->i_sb, tmp_bh.b_blocknr);
fs/affs/file.c:	struct super_block *sb = inode->i_sb;
fs/affs/file.c:	pr_debug("AFFS: read_page(%u, %ld, %d, %d)\n", (u32)inode->i_ino, page->index, from, to);
fs/affs/file.c:	struct super_block *sb = inode->i_sb;
fs/affs/file.c:	pr_debug("AFFS: extent_file(%u, %d)\n", (u32)inode->i_ino, newsize);
fs/affs/file.c:		AFFS_DATA_HEAD(bh)->key = cpu_to_be32(inode->i_ino);
fs/affs/file.c:	inode->i_size = AFFS_I(inode)->mmu_private = newsize;
fs/affs/file.c:	inode->i_size = AFFS_I(inode)->mmu_private = newsize;
fs/affs/file.c:	pr_debug("AFFS: read_page(%u, %ld)\n", (u32)inode->i_ino, page->index);
fs/affs/file.c:	if (((page->index + 1) << PAGE_CACHE_SHIFT) > inode->i_size) {
fs/affs/file.c:		to = inode->i_size & ~PAGE_CACHE_MASK;
fs/affs/file.c:	pr_debug("AFFS: write_begin(%u, %llu, %llu)\n", (u32)inode->i_ino, (unsigned long long)pos, (unsigned long long)pos + len);
fs/affs/file.c:	struct super_block *sb = inode->i_sb;
fs/affs/file.c:	pr_debug("AFFS: write_begin(%u, %llu, %llu)\n", (u32)inode->i_ino, (unsigned long long)pos, (unsigned long long)pos + len);
fs/affs/file.c:			AFFS_DATA_HEAD(bh)->key = cpu_to_be32(inode->i_ino);
fs/affs/file.c:			AFFS_DATA_HEAD(bh)->key = cpu_to_be32(inode->i_ino);
fs/affs/file.c:	if (tmp > inode->i_size)
fs/affs/file.c:		inode->i_size = AFFS_I(inode)->mmu_private = tmp;
fs/affs/file.c:	struct super_block *sb = inode->i_sb;
fs/affs/file.c:	pr_debug("AFFS: free_prealloc(ino=%lu)\n", inode->i_ino);
fs/affs/file.c:	struct super_block *sb = inode->i_sb;
fs/affs/file.c:		 (u32)inode->i_ino, (u32)AFFS_I(inode)->mmu_private, (u32)inode->i_size);
fs/affs/file.c:	if (inode->i_size) {
fs/affs/file.c:		last_blk = ((u32)inode->i_size - 1) / AFFS_SB(sb)->s_data_blksize;
fs/affs/file.c:	if (inode->i_size > AFFS_I(inode)->mmu_private) {
fs/affs/file.c:		struct address_space *mapping = inode->i_mapping;
fs/affs/file.c:		u32 size = inode->i_size;
fs/affs/file.c:			inode->i_size = AFFS_I(inode)->mmu_private;
fs/affs/file.c:	} else if (inode->i_size == AFFS_I(inode)->mmu_private)
fs/affs/file.c:	if (inode->i_size) {
fs/affs/file.c:	if (inode->i_size) {
fs/affs/file.c:	AFFS_I(inode)->mmu_private = inode->i_size;
fs/affs/file.c:	err = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/affs/file.c:	mutex_lock(&inode->i_mutex);
fs/affs/file.c:	err = sync_blockdev(inode->i_sb->s_bdev);
fs/affs/file.c:	mutex_unlock(&inode->i_mutex);
fs/affs/bitmap.c:	sb = inode->i_sb;
fs/affs/bitmap.c:	pr_debug("AFFS: balloc(inode=%lu,goal=%u): ", inode->i_ino, goal);
fs/affs/namei.c:		 dentry->d_inode->i_ino,
fs/affs/namei.c:	inode->i_mode = mode;
fs/affs/namei.c:	inode->i_op = &affs_file_inode_operations;
fs/affs/namei.c:	inode->i_fop = &affs_file_operations;
fs/affs/namei.c:	inode->i_mapping->a_ops = (AFFS_SB(sb)->s_flags & SF_OFS) ? &affs_aops_ofs : &affs_aops;
fs/affs/namei.c:	inode->i_mode = S_IFDIR | mode;
fs/affs/namei.c:	inode->i_op = &affs_dir_inode_operations;
fs/affs/namei.c:	inode->i_fop = &affs_dir_operations;
fs/affs/namei.c:		 dentry->d_inode->i_ino,
fs/affs/namei.c:	inode->i_op = &affs_symlink_inode_operations;
fs/affs/namei.c:	inode->i_data.a_ops = &affs_symlink_aops;
fs/affs/namei.c:	inode->i_mode = S_IFLNK | 0777;
fs/affs/namei.c:	bh = affs_bread(sb, inode->i_ino);
fs/affs/namei.c:	pr_debug("AFFS: link(%u, %u, \"%.*s\")\n", (u32)inode->i_ino, (u32)dir->i_ino,
fs/affs/namei.c:	bh = affs_bread(sb, old_dentry->d_inode->i_ino);
fs/configfs/inode.c:						inode->i_sb->s_time_gran);
fs/configfs/inode.c:						inode->i_sb->s_time_gran);
fs/configfs/inode.c:						inode->i_sb->s_time_gran);
fs/configfs/inode.c:		if (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))
fs/configfs/inode.c:	inode->i_mode = mode;
fs/configfs/inode.c:	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/configfs/inode.c:	inode->i_mode = iattr->ia_mode;
fs/configfs/inode.c:	inode->i_uid = iattr->ia_uid;
fs/configfs/inode.c:	inode->i_gid = iattr->ia_gid;
fs/configfs/inode.c:	inode->i_atime = iattr->ia_atime;
fs/configfs/inode.c:	inode->i_mtime = iattr->ia_mtime;
fs/configfs/inode.c:	inode->i_ctime = iattr->ia_ctime;
fs/configfs/inode.c:		inode->i_ino = get_next_ino();
fs/configfs/inode.c:		inode->i_mapping->a_ops = &configfs_aops;
fs/configfs/inode.c:		inode->i_mapping->backing_dev_info = &configfs_backing_dev_info;
fs/configfs/inode.c:		inode->i_op = &configfs_inode_operations;
fs/configfs/inode.c:			lockdep_set_class(&inode->i_mutex,
fs/configfs/inode.c:	p_inode->i_mtime = p_inode->i_ctime = CURRENT_TIME;
fs/configfs/inode.c:	mutex_lock(&dir->d_inode->i_mutex);
fs/configfs/inode.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/configfs/dir.c:	inode->i_op = &configfs_dir_inode_operations;
fs/configfs/dir.c:	inode->i_fop = &configfs_dir_operations;
fs/configfs/dir.c:	inode->i_size = PAGE_SIZE;
fs/configfs/dir.c:	inode->i_fop = &configfs_file_operations;
fs/configfs/dir.c:	inode->i_op = &configfs_symlink_inode_operations;
fs/configfs/dir.c:					*wait_mutex = &sd->s_dentry->d_inode->i_mutex;
fs/configfs/dir.c:		mutex_lock(&child->d_inode->i_mutex);
fs/configfs/dir.c:		child->d_inode->i_flags |= S_DEAD;
fs/configfs/dir.c:		mutex_unlock(&child->d_inode->i_mutex);
fs/configfs/dir.c:			mutex_lock(&dentry->d_inode->i_mutex);
fs/configfs/dir.c:			dentry->d_inode->i_flags |= S_DEAD;
fs/configfs/dir.c:			mutex_unlock(&dentry->d_inode->i_mutex);
fs/configfs/dir.c:		mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);
fs/configfs/dir.c:			dentry->d_inode->i_flags |= S_DEAD;
fs/configfs/dir.c:		mutex_unlock(&dentry->d_inode->i_mutex);
fs/configfs/dir.c:	mutex_lock(&root->d_inode->i_mutex);
fs/configfs/dir.c:	mutex_unlock(&root->d_inode->i_mutex);
fs/configfs/dir.c:	mutex_lock(&parent->d_inode->i_mutex);
fs/configfs/dir.c:	mutex_unlock(&parent->d_inode->i_mutex);
fs/configfs/dir.c:	mutex_lock(&dentry->d_inode->i_mutex);
fs/configfs/dir.c:	mutex_unlock(&dentry->d_inode->i_mutex);
fs/configfs/dir.c:	mutex_lock(&dentry->d_inode->i_mutex);
fs/configfs/dir.c:	mutex_unlock(&dentry->d_inode->i_mutex);
fs/configfs/dir.c:			ino = dentry->d_inode->i_ino;
fs/configfs/dir.c:					ino = inode->i_ino;
fs/configfs/dir.c:	mutex_lock(&dentry->d_inode->i_mutex);
fs/configfs/dir.c:			mutex_unlock(&file->f_path.dentry->d_inode->i_mutex);
fs/configfs/dir.c:	mutex_unlock(&dentry->d_inode->i_mutex);
fs/configfs/dir.c:	mutex_lock_nested(&root->d_inode->i_mutex, I_MUTEX_PARENT);
fs/configfs/dir.c:	mutex_unlock(&root->d_inode->i_mutex);
fs/configfs/dir.c:	mutex_lock_nested(&root->d_inode->i_mutex,
fs/configfs/dir.c:	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);
fs/configfs/dir.c:	dentry->d_inode->i_flags |= S_DEAD;
fs/configfs/dir.c:	mutex_unlock(&dentry->d_inode->i_mutex);
fs/configfs/dir.c:	mutex_unlock(&root->d_inode->i_mutex);
fs/configfs/file.c:		if (!(inode->i_mode & S_IWUGO) || !ops->store_attribute)
fs/configfs/file.c:		if (!(inode->i_mode & S_IRUGO) || !ops->show_attribute)
fs/configfs/file.c:	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_NORMAL);
fs/configfs/file.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/configfs/mount.c:		inode->i_op = &configfs_root_inode_operations;
fs/configfs/mount.c:		inode->i_fop = &configfs_dir_operations;
fs/ioctl.c:	struct super_block *sb = inode->i_sb;
fs/ioctl.c:	if (!inode->i_op->fiemap)
fs/ioctl.c:		filemap_write_and_wait(inode->i_mapping);
fs/ioctl.c:	error = inode->i_op->fiemap(inode, &fieinfo, fiemap.fm_start, len);
fs/ioctl.c:	return (offset >> inode->i_blkbits);
fs/ioctl.c:	return (blk << inode->i_blkbits);
fs/ioctl.c: * If it is possible to have data blocks beyond a hole past @inode->i_size, then
fs/ioctl.c:	mutex_lock(&inode->i_mutex);
fs/ioctl.c:	mutex_unlock(&inode->i_mutex);
fs/ioctl.c:	struct super_block *sb = filp->f_path.dentry->d_inode->i_sb;
fs/ioctl.c:	struct super_block *sb = filp->f_path.dentry->d_inode->i_sb;
fs/ioctl.c:		if (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||
fs/ioctl.c:		    S_ISLNK(inode->i_mode)) {
fs/ioctl.c:		return put_user(inode->i_sb->s_blocksize, argp);
fs/ioctl.c:		if (S_ISREG(inode->i_mode))
fs/pstore/inode.c:	struct pstore_private *ps = inode->i_private;
fs/pstore/inode.c:	struct pstore_private *p = dentry->d_inode->i_private;
fs/pstore/inode.c:			      dentry->d_inode->i_ctime, p->psi);
fs/pstore/inode.c:	struct pstore_private	*p = inode->i_private;
fs/pstore/inode.c:		inode->i_ino = get_next_ino();
fs/pstore/inode.c:		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/pstore/inode.c:	inode->i_mode = S_IFREG | 0444;
fs/pstore/inode.c:	inode->i_fop = &pstore_file_operations;
fs/pstore/inode.c:	mutex_lock(&root->d_inode->i_mutex);
fs/pstore/inode.c:	inode->i_size = private->size = size;
fs/pstore/inode.c:	inode->i_private = private;
fs/pstore/inode.c:		inode->i_mtime = inode->i_ctime = time;
fs/pstore/inode.c:	mutex_unlock(&root->d_inode->i_mutex);
fs/pstore/inode.c:	mutex_unlock(&root->d_inode->i_mutex);
fs/pstore/inode.c:		inode->i_mode = S_IFDIR | 0755;
fs/pstore/inode.c:		inode->i_op = &pstore_dir_inode_operations;
fs/pstore/inode.c:		inode->i_fop = &simple_dir_operations;
fs/minix/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/minix/inode.c:	if (!inode->i_nlink) {
fs/minix/inode.c:		inode->i_size = 0;
fs/minix/inode.c:	if (!inode->i_nlink)
fs/minix/inode.c:	call_rcu(&inode->i_rcu, minix_i_callback);
fs/minix/inode.c:	if (to > inode->i_size) {
fs/minix/inode.c:		truncate_pagecache(inode, to, inode->i_size);
fs/minix/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/minix/inode.c:		inode->i_op = &minix_file_inode_operations;
fs/minix/inode.c:		inode->i_fop = &minix_file_operations;
fs/minix/inode.c:		inode->i_mapping->a_ops = &minix_aops;
fs/minix/inode.c:	} else if (S_ISDIR(inode->i_mode)) {
fs/minix/inode.c:		inode->i_op = &minix_dir_inode_operations;
fs/minix/inode.c:		inode->i_fop = &minix_dir_operations;
fs/minix/inode.c:		inode->i_mapping->a_ops = &minix_aops;
fs/minix/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/minix/inode.c:		inode->i_op = &minix_symlink_inode_operations;
fs/minix/inode.c:		inode->i_mapping->a_ops = &minix_aops;
fs/minix/inode.c:		init_special_inode(inode, inode->i_mode, rdev);
fs/minix/inode.c:	raw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);
fs/minix/inode.c:	inode->i_mode = raw_inode->i_mode;
fs/minix/inode.c:	i_uid_write(inode, raw_inode->i_uid);
fs/minix/inode.c:	i_gid_write(inode, raw_inode->i_gid);
fs/minix/inode.c:	set_nlink(inode, raw_inode->i_nlinks);
fs/minix/inode.c:	inode->i_size = raw_inode->i_size;
fs/minix/inode.c:	inode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec = raw_inode->i_time;
fs/minix/inode.c:	inode->i_mtime.tv_nsec = 0;
fs/minix/inode.c:	inode->i_atime.tv_nsec = 0;
fs/minix/inode.c:	inode->i_ctime.tv_nsec = 0;
fs/minix/inode.c:	inode->i_blocks = 0;
fs/minix/inode.c:		minix_inode->u.i1_data[i] = raw_inode->i_zone[i];
fs/minix/inode.c:	minix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));
fs/minix/inode.c:	raw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);
fs/minix/inode.c:	inode->i_mode = raw_inode->i_mode;
fs/minix/inode.c:	i_uid_write(inode, raw_inode->i_uid);
fs/minix/inode.c:	i_gid_write(inode, raw_inode->i_gid);
fs/minix/inode.c:	set_nlink(inode, raw_inode->i_nlinks);
fs/minix/inode.c:	inode->i_size = raw_inode->i_size;
fs/minix/inode.c:	inode->i_mtime.tv_sec = raw_inode->i_mtime;
fs/minix/inode.c:	inode->i_atime.tv_sec = raw_inode->i_atime;
fs/minix/inode.c:	inode->i_ctime.tv_sec = raw_inode->i_ctime;
fs/minix/inode.c:	inode->i_mtime.tv_nsec = 0;
fs/minix/inode.c:	inode->i_atime.tv_nsec = 0;
fs/minix/inode.c:	inode->i_ctime.tv_nsec = 0;
fs/minix/inode.c:	inode->i_blocks = 0;
fs/minix/inode.c:		minix_inode->u.i2_data[i] = raw_inode->i_zone[i];
fs/minix/inode.c:	minix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));
fs/minix/inode.c:	if (!(inode->i_state & I_NEW))
fs/minix/inode.c:	raw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);
fs/minix/inode.c:	raw_inode->i_mode = inode->i_mode;
fs/minix/inode.c:	raw_inode->i_uid = fs_high2lowuid(i_uid_read(inode));
fs/minix/inode.c:	raw_inode->i_gid = fs_high2lowgid(i_gid_read(inode));
fs/minix/inode.c:	raw_inode->i_nlinks = inode->i_nlink;
fs/minix/inode.c:	raw_inode->i_size = inode->i_size;
fs/minix/inode.c:	raw_inode->i_time = inode->i_mtime.tv_sec;
fs/minix/inode.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
fs/minix/inode.c:		raw_inode->i_zone[0] = old_encode_dev(inode->i_rdev);
fs/minix/inode.c:		raw_inode->i_zone[i] = minix_inode->u.i1_data[i];
fs/minix/inode.c:	raw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);
fs/minix/inode.c:	raw_inode->i_mode = inode->i_mode;
fs/minix/inode.c:	raw_inode->i_uid = fs_high2lowuid(i_uid_read(inode));
fs/minix/inode.c:	raw_inode->i_gid = fs_high2lowgid(i_gid_read(inode));
fs/minix/inode.c:	raw_inode->i_nlinks = inode->i_nlink;
fs/minix/inode.c:	raw_inode->i_size = inode->i_size;
fs/minix/inode.c:	raw_inode->i_mtime = inode->i_mtime.tv_sec;
fs/minix/inode.c:	raw_inode->i_atime = inode->i_atime.tv_sec;
fs/minix/inode.c:	raw_inode->i_ctime = inode->i_ctime.tv_sec;
fs/minix/inode.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
fs/minix/inode.c:		raw_inode->i_zone[0] = old_encode_dev(inode->i_rdev);
fs/minix/inode.c:		raw_inode->i_zone[i] = minix_inode->u.i2_data[i];
fs/minix/inode.c:				inode->i_sb->s_id, inode->i_ino);
fs/minix/inode.c:	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)))
fs/minix/minix.h:#define INODE_VERSION(inode)	minix_sb(inode->i_sb)->s_version
fs/minix/itree_v2.c:	struct super_block *sb = inode->i_sb;
fs/minix/dir.c:	if (page_nr == (inode->i_size >> PAGE_CACHE_SHIFT))
fs/minix/dir.c:		last_byte = inode->i_size & (PAGE_CACHE_SIZE - 1);
fs/minix/dir.c:	return (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;
fs/minix/dir.c:	struct super_block *sb = inode->i_sb;
fs/minix/dir.c:	if (pos >= inode->i_size)
fs/minix/dir.c:		de3->inode = inode->i_ino;
fs/minix/dir.c:		de->inode = inode->i_ino;
fs/minix/dir.c:	struct minix_sb_info *sbi = minix_sb(inode->i_sb);
fs/minix/dir.c:	inode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;
fs/minix/dir.c:	struct page *page = grab_cache_page(inode->i_mapping, 0);
fs/minix/dir.c:	struct minix_sb_info *sbi = minix_sb(inode->i_sb);
fs/minix/dir.c:		de3->inode = inode->i_ino;
fs/minix/dir.c:		de->inode = inode->i_ino;
fs/minix/dir.c:	struct minix_sb_info *sbi = minix_sb(inode->i_sb);
fs/minix/dir.c:					if (inumber != inode->i_ino)
fs/minix/dir.c:			((minix3_dirent *) de)->inode = inode->i_ino;
fs/minix/dir.c:			de->inode = inode->i_ino;
fs/minix/dir.c:		struct minix_sb_info *sbi = minix_sb(inode->i_sb);
fs/minix/itree_common.c:	struct super_block *sb = inode->i_sb;
fs/minix/itree_common.c:		bh = sb_getblk(inode->i_sb, parent);
fs/minix/itree_common.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/minix/itree_common.c:		map_bh(bh, inode->i_sb, block_to_cpu(chain[depth-1].key));
fs/minix/itree_common.c:			bh = sb_bread(inode->i_sb, nr);
fs/minix/itree_common.c:	struct super_block *sb = inode->i_sb;
fs/minix/itree_common.c:	iblock = (inode->i_size + sb->s_blocksize -1) >> sb->s_blocksize_bits;
fs/minix/itree_common.c:	block_truncate_page(inode->i_mapping, inode->i_size, get_block);
fs/minix/itree_common.c:	inode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;
fs/minix/bitmap.c:	struct super_block *sb = inode->i_sb;
fs/minix/bitmap.c:	struct minix_sb_info *sbi = minix_sb(inode->i_sb);
fs/minix/bitmap.c:	int bits_per_zone = 8 * inode->i_sb->s_blocksize;
fs/minix/bitmap.c:		raw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);
fs/minix/bitmap.c:			raw_inode->i_nlinks = 0;
fs/minix/bitmap.c:			raw_inode->i_mode = 0;
fs/minix/bitmap.c:		raw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);
fs/minix/bitmap.c:			raw_inode->i_nlinks = 0;
fs/minix/bitmap.c:			raw_inode->i_mode = 0;
fs/minix/bitmap.c:	struct super_block *sb = inode->i_sb;
fs/minix/bitmap.c:	struct minix_sb_info *sbi = minix_sb(inode->i_sb);
fs/minix/bitmap.c:	ino = inode->i_ino;
fs/minix/bitmap.c:	inode->i_ino = j;
fs/minix/bitmap.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
fs/minix/bitmap.c:	inode->i_blocks = 0;
fs/minix/itree_v1.c:			block, bdevname(inode->i_sb->s_bdev, b));
fs/minix/itree_v1.c:	} else if (block >= (minix_sb(inode->i_sb)->s_max_size/BLOCK_SIZE)) {
fs/minix/itree_v1.c:				block, bdevname(inode->i_sb->s_bdev, b));
fs/minix/namei.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/minix/namei.c:	inode->i_ctime = dir->i_ctime;
fs/minix/namei.c:	if (S_ISDIR(old_inode->i_mode)) {
fs/minix/namei.c:		new_inode->i_ctime = CURRENT_TIME_SEC;
fs/omfs/inode.c:	inode->i_ino = new_block;
fs/omfs/inode.c:	inode->i_mapping->a_ops = &omfs_aops;
fs/omfs/inode.c:	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/omfs/inode.c:		inode->i_op = &omfs_dir_inops;
fs/omfs/inode.c:		inode->i_fop = &omfs_dir_operations;
fs/omfs/inode.c:		inode->i_size = sbi->s_sys_blocksize;
fs/omfs/inode.c:		inode->i_op = &omfs_file_inops;
fs/omfs/inode.c:		inode->i_fop = &omfs_file_operations;
fs/omfs/inode.c:		inode->i_size = 0;
fs/omfs/inode.c:	struct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);
fs/omfs/inode.c:	bh = omfs_bread(inode->i_sb, inode->i_ino);
fs/omfs/inode.c:	oi->i_head.h_self = cpu_to_be64(inode->i_ino);
fs/omfs/inode.c:	if (S_ISDIR(inode->i_mode))
fs/omfs/inode.c:	else if (S_ISREG(inode->i_mode))
fs/omfs/inode.c:			inode->i_mode);
fs/omfs/inode.c:	oi->i_size = cpu_to_be64(inode->i_size);
fs/omfs/inode.c:	ctime = inode->i_ctime.tv_sec * 1000LL +
fs/omfs/inode.c:		((inode->i_ctime.tv_nsec + 999)/1000);
fs/omfs/inode.c:		bh2 = omfs_bread(inode->i_sb, inode->i_ino + i);
fs/omfs/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/omfs/inode.c:	if (inode->i_nlink)
fs/omfs/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/omfs/inode.c:		inode->i_size = 0;
fs/omfs/inode.c:	omfs_clear_range(inode->i_sb, inode->i_ino, 2);
fs/omfs/inode.c:	if (!(inode->i_state & I_NEW))
fs/omfs/inode.c:	bh = omfs_bread(inode->i_sb, ino);
fs/omfs/inode.c:	inode->i_uid = sbi->s_uid;
fs/omfs/inode.c:	inode->i_gid = sbi->s_gid;
fs/omfs/inode.c:	inode->i_atime.tv_sec = ctime;
fs/omfs/inode.c:	inode->i_mtime.tv_sec = ctime;
fs/omfs/inode.c:	inode->i_ctime.tv_sec = ctime;
fs/omfs/inode.c:	inode->i_atime.tv_nsec = nsecs;
fs/omfs/inode.c:	inode->i_mtime.tv_nsec = nsecs;
fs/omfs/inode.c:	inode->i_ctime.tv_nsec = nsecs;
fs/omfs/inode.c:	inode->i_mapping->a_ops = &omfs_aops;
fs/omfs/inode.c:		inode->i_mode = S_IFDIR | (S_IRWXUGO & ~sbi->s_dmask);
fs/omfs/inode.c:		inode->i_op = &omfs_dir_inops;
fs/omfs/inode.c:		inode->i_fop = &omfs_dir_operations;
fs/omfs/inode.c:		inode->i_size = sbi->s_sys_blocksize;
fs/omfs/inode.c:		inode->i_mode = S_IFREG | (S_IRWXUGO & ~sbi->s_fmask);
fs/omfs/inode.c:		inode->i_fop = &omfs_file_operations;
fs/omfs/inode.c:		inode->i_size = be64_to_cpu(oi->i_size);
fs/omfs/dir.c:	bh = omfs_bread(sb, inode->i_ino);
fs/omfs/dir.c:	if (S_ISDIR(inode->i_mode)) {
fs/omfs/dir.c:	oi->i_head.h_self = cpu_to_be64(inode->i_ino);
fs/omfs/dir.c:	*entry = cpu_to_be64(inode->i_ino);
fs/omfs/dir.c:	bh = omfs_bread(dir->i_sb, inode->i_ino);
fs/omfs/dir.c:	int nbuckets = (inode->i_size - OMFS_DIR_START) / 8;
fs/omfs/dir.c:	bh = omfs_bread(inode->i_sb, inode->i_ino);
fs/omfs/dir.c:	if (S_ISDIR(inode->i_mode) &&
fs/omfs/dir.c:	old_inode->i_ctime = CURRENT_TIME_SEC;
fs/omfs/file.c:	struct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);
fs/omfs/file.c:	 * than inode->i_size;
fs/omfs/file.c:	next = inode->i_ino;
fs/omfs/file.c:	if (inode->i_size != 0)
fs/omfs/file.c:	bh = omfs_bread(inode->i_sb, next);
fs/omfs/file.c:			omfs_clear_range(inode->i_sb, start, (int) count);
fs/omfs/file.c:		if (last != inode->i_ino)
fs/omfs/file.c:			omfs_clear_range(inode->i_sb, last, sbi->s_mirrors);
fs/omfs/file.c:		bh = omfs_bread(inode->i_sb, next);
fs/omfs/file.c:	struct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);
fs/omfs/file.c:		if (omfs_allocate_block(inode->i_sb, new_block)) {
fs/omfs/file.c:	ret = omfs_allocate_range(inode->i_sb, 1, sbi->s_clustersize,
fs/omfs/file.c:		int numblocks = clus_to_blk(OMFS_SB(inode->i_sb),
fs/omfs/file.c:			return clus_to_blk(OMFS_SB(inode->i_sb),
fs/omfs/file.c:	struct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);
fs/omfs/file.c:	int max_blocks = bh_result->b_size >> inode->i_blkbits;
fs/omfs/file.c:	bh = omfs_bread(inode->i_sb, inode->i_ino);
fs/omfs/file.c:	next = inode->i_ino;
fs/omfs/file.c:			map_bh(bh_result, inode->i_sb, offset);
fs/omfs/file.c:			bh_result->b_size = (remain << inode->i_blkbits);
fs/omfs/file.c:		bh = omfs_bread(inode->i_sb, next);
fs/omfs/file.c:			map_bh(bh_result, inode->i_sb,
fs/omfs/file.c:	if (to > inode->i_size) {
fs/omfs/file.c:		truncate_pagecache(inode, to, inode->i_size);
fs/exec.c:	if (!S_ISREG(file->f_path.dentry->d_inode->i_mode))
fs/exec.c:	if (!S_ISREG(file->f_path.dentry->d_inode->i_mode))
fs/exec.c:	mode = inode->i_mode;
fs/exec.c:	    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&
fs/exec.c:	    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {
fs/exec.c:			bprm->cred->euid = inode->i_uid;
fs/exec.c:			bprm->cred->egid = inode->i_gid;
fs/block_dev.c:	struct backing_dev_info *old = inode->i_data.backing_dev_info;
fs/block_dev.c:	spin_lock(&inode->i_lock);
fs/block_dev.c:	inode->i_data.backing_dev_info = dst;
fs/block_dev.c:	if (inode->i_state & I_DIRTY)
fs/block_dev.c:		list_move(&inode->i_wb_list, &dst->wb.b_dirty);
fs/block_dev.c:	spin_unlock(&inode->i_lock);
fs/block_dev.c:	struct address_space *mapping = bdev->bd_inode->i_mapping;
fs/block_dev.c:	struct address_space *mapping = bdev->bd_inode->i_mapping;
fs/block_dev.c:		bdev->bd_inode->i_blkbits = blksize_bits(size);
fs/block_dev.c:		return filemap_flush(bdev->bd_inode->i_mapping);
fs/block_dev.c:	return filemap_write_and_wait(bdev->bd_inode->i_mapping);
fs/block_dev.c: * for a block special file file->f_path.dentry->d_inode->i_size is zero
fs/block_dev.c:	mutex_lock(&bd_inode->i_mutex);
fs/block_dev.c:	mutex_unlock(&bd_inode->i_mutex);
fs/block_dev.c:	call_rcu(&inode->i_rcu, bdev_i_callback);
fs/block_dev.c:	list_del_init(&inode->i_devices);
fs/block_dev.c:	inode->i_bdev = NULL;
fs/block_dev.c:	inode->i_mapping = &inode->i_data;
fs/block_dev.c:	truncate_inode_pages(&inode->i_data, 0);
fs/block_dev.c:	if (inode->i_state & I_NEW) {
fs/block_dev.c:		bdev->bd_block_size = (1 << inode->i_blkbits);
fs/block_dev.c:		inode->i_mode = S_IFBLK;
fs/block_dev.c:		inode->i_rdev = dev;
fs/block_dev.c:		inode->i_bdev = bdev;
fs/block_dev.c:		inode->i_data.a_ops = &def_blk_aops;
fs/block_dev.c:		mapping_set_gfp_mask(&inode->i_data, GFP_USER);
fs/block_dev.c:		inode->i_data.backing_dev_info = &default_backing_dev_info;
fs/block_dev.c:		ret += bdev->bd_inode->i_mapping->nrpages;
fs/block_dev.c:	bdev = inode->i_bdev;
fs/block_dev.c:	bdev = bdget(inode->i_rdev);
fs/block_dev.c:		if (!inode->i_bdev) {
fs/block_dev.c:			inode->i_bdev = bdev;
fs/block_dev.c:			inode->i_mapping = bdev->bd_inode->i_mapping;
fs/block_dev.c:			list_add(&inode->i_devices, &bdev->bd_inodes);
fs/block_dev.c:	if (inode->i_bdev) {
fs/block_dev.c:		if (!sb_is_blkdev_sb(inode->i_sb))
fs/block_dev.c:			bdev = inode->i_bdev;
fs/block_dev.c:	mutex_lock(&bdev->bd_inode->i_mutex);
fs/block_dev.c:	mutex_unlock(&bdev->bd_inode->i_mutex);
fs/block_dev.c:	bdev->bd_inode->i_blkbits = blksize_bits(bsize);
fs/block_dev.c:				whole->bd_inode->i_data.backing_dev_info);
fs/block_dev.c:	filp->f_mapping = bdev->bd_inode->i_mapping;
fs/block_dev.c:	if (!S_ISBLK(inode->i_mode))
fs/block_dev.c:		struct address_space *mapping = inode->i_mapping;
fs/block_dev.c:		spin_lock(&inode->i_lock);
fs/block_dev.c:		if (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW) ||
fs/block_dev.c:			spin_unlock(&inode->i_lock);
fs/block_dev.c:		spin_unlock(&inode->i_lock);
fs/aio.c:		  (!S_ISFIFO(inode->i_mode) && !S_ISSOCK(inode->i_mode))));
fs/hppfs/hppfs.c:	mutex_lock(&parent->d_inode->i_mutex);
fs/hppfs/hppfs.c:	mutex_unlock(&parent->d_inode->i_mutex);
fs/hppfs/hppfs.c:	read = file->f_path.dentry->d_inode->i_fop->read;
fs/hppfs/hppfs.c:	write = proc_file->f_path.dentry->d_inode->i_fop->write;
fs/hppfs/hppfs.c:	path.mnt = inode->i_sb->s_fs_info;
fs/hppfs/hppfs.c:	path.mnt = inode->i_sb->s_fs_info;
fs/hppfs/hppfs.c:	llseek = proc_file->f_path.dentry->d_inode->i_fop->llseek;
fs/hppfs/hppfs.c:	readdir = proc_file->f_path.dentry->d_inode->i_fop->readdir;
fs/hppfs/hppfs.c:	call_rcu(&inode->i_rcu, hppfs_i_callback);
fs/hppfs/hppfs.c:	return proc_dentry->d_inode->i_op->readlink(proc_dentry, buffer,
fs/hppfs/hppfs.c:	return proc_dentry->d_inode->i_op->follow_link(proc_dentry, nd);
fs/hppfs/hppfs.c:	if (proc_dentry->d_inode->i_op->put_link)
fs/hppfs/hppfs.c:		proc_dentry->d_inode->i_op->put_link(proc_dentry, nd, cookie);
fs/hppfs/hppfs.c:	if (S_ISDIR(dentry->d_inode->i_mode)) {
fs/hppfs/hppfs.c:		inode->i_op = &hppfs_dir_iops;
fs/hppfs/hppfs.c:		inode->i_fop = &hppfs_dir_fops;
fs/hppfs/hppfs.c:	} else if (S_ISLNK(dentry->d_inode->i_mode)) {
fs/hppfs/hppfs.c:		inode->i_op = &hppfs_link_iops;
fs/hppfs/hppfs.c:		inode->i_fop = &hppfs_file_fops;
fs/hppfs/hppfs.c:		inode->i_op = &hppfs_file_iops;
fs/hppfs/hppfs.c:		inode->i_fop = &hppfs_file_fops;
fs/hppfs/hppfs.c:	inode->i_uid = proc_ino->i_uid;
fs/hppfs/hppfs.c:	inode->i_gid = proc_ino->i_gid;
fs/hppfs/hppfs.c:	inode->i_atime = proc_ino->i_atime;
fs/hppfs/hppfs.c:	inode->i_mtime = proc_ino->i_mtime;
fs/hppfs/hppfs.c:	inode->i_ctime = proc_ino->i_ctime;
fs/hppfs/hppfs.c:	inode->i_ino = proc_ino->i_ino;
fs/hppfs/hppfs.c:	inode->i_mode = proc_ino->i_mode;
fs/hppfs/hppfs.c:	inode->i_size = proc_ino->i_size;
fs/hppfs/hppfs.c:	inode->i_blocks = proc_ino->i_blocks;
fs/namei.c:	        if (inode->i_op->get_acl) {
fs/namei.c:			acl = inode->i_op->get_acl(inode, ACL_TYPE_ACCESS);
fs/namei.c:	unsigned int mode = inode->i_mode;
fs/namei.c:	if (likely(uid_eq(current_fsuid(), inode->i_uid)))
fs/namei.c:		if (in_group_p(inode->i_gid))
fs/namei.c:	if (S_ISDIR(inode->i_mode)) {
fs/namei.c:	if (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))
fs/namei.c: * even looking at the inode->i_op values. So we keep a cache
fs/namei.c: * flag in inode->i_opflags, that says "this has not special
fs/namei.c:	if (unlikely(!(inode->i_opflags & IOP_FASTPERM))) {
fs/namei.c:		if (likely(inode->i_op->permission))
fs/namei.c:			return inode->i_op->permission(inode, mask);
fs/namei.c:		spin_lock(&inode->i_lock);
fs/namei.c:		inode->i_opflags |= IOP_FASTPERM;
fs/namei.c:		spin_unlock(&inode->i_lock);
fs/namei.c: * Separate out file-system wide checks from inode-specific permission checks.
fs/namei.c:		umode_t mode = inode->i_mode;
fs/namei.c:	retval = sb_permission(inode->i_sb, inode, mask);
fs/namei.c:	if (inode->i_op->put_link)
fs/namei.c:		inode->i_op->put_link(link->dentry, nd, cookie);
fs/namei.c:	if (uid_eq(current_cred()->fsuid, inode->i_uid))
fs/namei.c:	if (uid_eq(parent->i_uid, inode->i_uid))
fs/namei.c:	umode_t mode = inode->i_mode;
fs/namei.c:	if (uid_eq(cred->fsuid, inode->i_uid) || safe_hardlink_source(inode) ||
fs/namei.c:	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
fs/namei.c: * dir->d_inode->i_mutex must be held
fs/namei.c: * dir->d_inode->i_mutex must be held
fs/namei.c:	mutex_lock(&parent->d_inode->i_mutex);
fs/namei.c:	mutex_unlock(&parent->d_inode->i_mutex);
fs/namei.c: * to do this check without having to look at inode->i_op,
fs/namei.c:	if (unlikely(!(inode->i_opflags & IOP_NOFOLLOW))) {
fs/namei.c:		if (likely(inode->i_op->follow_link))
fs/namei.c:		spin_lock(&inode->i_lock);
fs/namei.c:		inode->i_opflags |= IOP_NOFOLLOW;
fs/namei.c:		spin_unlock(&inode->i_lock);
fs/namei.c: * We really don't want to look at inode->i_op->lookup
fs/namei.c:	if (likely(inode->i_opflags & IOP_LOOKUP))
fs/namei.c:	if (likely(!inode->i_op->lookup))
fs/namei.c:	spin_lock(&inode->i_lock);
fs/namei.c:	inode->i_opflags |= IOP_LOOKUP;
fs/namei.c:	spin_unlock(&inode->i_lock);
fs/namei.c:		if (!nd->inode->i_op->lookup) {
fs/namei.c:	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
fs/namei.c:		mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
fs/namei.c:	WARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));
fs/namei.c:	if (uid_eq(inode->i_uid, fsuid))
fs/namei.c:		if (!S_ISDIR(victim->d_inode->i_mode))
fs/namei.c:	} else if (S_ISDIR(victim->d_inode->i_mode))
fs/namei.c:		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
fs/namei.c:	mutex_lock(&p1->d_inode->i_sb->s_vfs_rename_mutex);
fs/namei.c:		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
fs/namei.c:		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
fs/namei.c:		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
fs/namei.c:		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
fs/namei.c:	mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
fs/namei.c:	mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
fs/namei.c:	mutex_unlock(&p1->d_inode->i_mutex);
fs/namei.c:		mutex_unlock(&p2->d_inode->i_mutex);
fs/namei.c:		mutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);
fs/namei.c:	switch (inode->i_mode & S_IFMT) {
fs/namei.c:				   S_ISREG(dentry->d_inode->i_mode)) {
fs/namei.c:	if ((nd->flags & LOOKUP_OPEN) && dir_inode->i_op->atomic_open) {
fs/namei.c:	mutex_lock(&dir->d_inode->i_mutex);
fs/namei.c:	mutex_unlock(&dir->d_inode->i_mutex);
fs/namei.c:		    !S_ISREG(file->f_path.dentry->d_inode->i_mode))
fs/namei.c:	if ((open_flag & O_CREAT) && S_ISDIR(nd->inode->i_mode))
fs/namei.c:	if ((nd->flags & LOOKUP_DIRECTORY) && !nd->inode->i_op->lookup)
fs/namei.c:	if (!S_ISREG(nd->inode->i_mode))
fs/namei.c:	if (dentry->d_inode->i_op->follow_link && op->intent & LOOKUP_OPEN)
fs/namei.c:	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
fs/namei.c:	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
fs/namei.c:	mutex_unlock(&path->dentry->d_inode->i_mutex);
fs/namei.c:	mutex_lock(&dentry->d_inode->i_mutex);
fs/namei.c:	dentry->d_inode->i_flags |= S_DEAD;
fs/namei.c:	mutex_unlock(&dentry->d_inode->i_mutex);
fs/namei.c:	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
fs/namei.c:	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
fs/namei.c:	mutex_lock(&dentry->d_inode->i_mutex);
fs/namei.c:	mutex_unlock(&dentry->d_inode->i_mutex);
fs/namei.c:	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
fs/namei.c:	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
fs/namei.c:		S_ISDIR(dentry->d_inode->i_mode) ? -EISDIR : -ENOTDIR;
fs/namei.c:	if (dir->i_sb != inode->i_sb)
fs/namei.c:	if (S_ISDIR(inode->i_mode))
fs/namei.c:	mutex_lock(&inode->i_mutex);
fs/namei.c:	if (inode->i_nlink == 0)
fs/namei.c:	else if (max_links && inode->i_nlink >= max_links)
fs/namei.c:	mutex_unlock(&inode->i_mutex);
fs/namei.c:	int is_dir = S_ISDIR(old_dentry->d_inode->i_mode);
fs/namei.c:	if (!S_ISDIR(old_dentry->d_inode->i_mode)) {
fs/namei.c:	cookie = dentry->d_inode->i_op->follow_link(dentry, &nd);
fs/namei.c:	if (dentry->d_inode->i_op->put_link)
fs/namei.c:		dentry->d_inode->i_op->put_link(dentry, &nd, cookie);
fs/namei.c:	struct address_space *mapping = dentry->d_inode->i_mapping;
fs/namei.c:	nd_terminate_link(kaddr, dentry->d_inode->i_size, PAGE_SIZE - 1);
fs/namei.c:	struct address_space *mapping = inode->i_mapping;
fs/namei.c:			!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));
fs/binfmt_elf.c:		if (vma->vm_file->f_path.dentry->d_inode->i_nlink == 0 ?
fs/splice.c:	sb_start_write(inode->i_sb);
fs/splice.c:		mutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);
fs/splice.c:		mutex_unlock(&inode->i_mutex);
fs/splice.c:	sb_end_write(inode->i_sb);
fs/splice.c:	i_mode = in->f_path.dentry->d_inode->i_mode;
fs/ncpfs/inode.c:	call_rcu(&inode->i_rcu, ncp_i_callback);
fs/ncpfs/inode.c:		inode->i_mode = nwi->nfs.mode;
fs/ncpfs/inode.c:	inode->i_blocks = (i_size_read(inode) + NCP_BLOCK_SIZE - 1) >> NCP_BLOCK_SHIFT;
fs/ncpfs/inode.c:	inode->i_mtime.tv_sec = ncp_date_dos2unix(nwi->modifyTime, nwi->modifyDate);
fs/ncpfs/inode.c:	inode->i_ctime.tv_sec = ncp_date_dos2unix(nwi->creationTime, nwi->creationDate);
fs/ncpfs/inode.c:	inode->i_atime.tv_sec = ncp_date_dos2unix(0, nwi->lastAccessDate);
fs/ncpfs/inode.c:	inode->i_atime.tv_nsec = 0;
fs/ncpfs/inode.c:	inode->i_mtime.tv_nsec = 0;
fs/ncpfs/inode.c:	inode->i_ctime.tv_nsec = 0;
fs/ncpfs/inode.c:		inode->i_mode = server->m.dir_mode;
fs/ncpfs/inode.c:		inode->i_mode = server->m.file_mode;
fs/ncpfs/inode.c:							inode->i_mode = (inode->i_mode & ~S_IFMT) | S_IFLNK;
fs/ncpfs/inode.c:						inode->i_mode |= S_IRUGO;
fs/ncpfs/inode.c:						inode->i_mode |= (inode->i_mode >> 2) & S_IXUGO;
fs/ncpfs/inode.c:	if (nwi->attributes & aRONLY) inode->i_mode &= ~S_IWUGO;
fs/ncpfs/inode.c:	DDPRINTK("ncp_read_inode: inode->i_mode = %u\n", inode->i_mode);
fs/ncpfs/inode.c:	inode->i_uid = server->m.uid;
fs/ncpfs/inode.c:	inode->i_gid = server->m.gid;
fs/ncpfs/inode.c:		inode->i_mapping->backing_dev_info = sb->s_bdi;
fs/ncpfs/inode.c:		inode->i_ino = info->ino;
fs/ncpfs/inode.c:		if (S_ISREG(inode->i_mode)) {
fs/ncpfs/inode.c:			inode->i_op = &ncp_file_inode_operations;
fs/ncpfs/inode.c:			inode->i_fop = &ncp_file_operations;
fs/ncpfs/inode.c:		} else if (S_ISDIR(inode->i_mode)) {
fs/ncpfs/inode.c:			inode->i_op = &ncp_dir_inode_operations;
fs/ncpfs/inode.c:			inode->i_fop = &ncp_dir_operations;
fs/ncpfs/inode.c:		} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) || S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {
fs/ncpfs/inode.c:			init_special_inode(inode, inode->i_mode,
fs/ncpfs/inode.c:		} else if (S_ISLNK(inode->i_mode)) {
fs/ncpfs/inode.c:			inode->i_op = &ncp_symlink_inode_operations;
fs/ncpfs/inode.c:			inode->i_data.a_ops = &ncp_symlink_aops;
fs/ncpfs/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/ncpfs/inode.c:	if (S_ISDIR(inode->i_mode)) {
fs/ncpfs/inode.c:		DDPRINTK("ncp_evict_inode: put directory %ld\n", inode->i_ino);
fs/ncpfs/inode.c:	if (!S_ISSOCK(sock_inode->i_mode))
fs/ncpfs/inode.c:		if (!S_ISSOCK(sock_inode->i_mode))
fs/ncpfs/inode.c:                if (S_ISDIR(inode->i_mode)) {
fs/ncpfs/dir.c:	return ncp_strnicmp(NCP_IO_TABLE(pinode->i_sb), str, name->name, len);
fs/ncpfs/dir.c:		inode == inode->i_sb->s_root->d_inode);
fs/ncpfs/dir.c:		mutex_lock(&inode->i_mutex);
fs/ncpfs/dir.c:		mutex_unlock(&inode->i_mutex);
fs/ncpfs/dir.c:		if (filldir(dirent, ".", 1, 0, inode->i_ino, DT_DIR))
fs/ncpfs/dir.c:	page = grab_cache_page(&inode->i_data, 0);
fs/ncpfs/dir.c:			ctl.page = find_lock_page(&inode->i_data, ctl.ofs);
fs/ncpfs/dir.c:					dent->d_inode->i_ino, DT_UNKNOWN);
fs/ncpfs/dir.c:		mutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);
fs/ncpfs/dir.c:		mutex_unlock(&inode->i_mutex);
fs/ncpfs/dir.c:		ino = newdent->d_inode->i_ino;
fs/ncpfs/dir.c:	if (new_dentry->d_inode && S_ISDIR(new_dentry->d_inode->i_mode)) {
fs/ncpfs/file.c:	if (pos > inode->i_sb->s_maxbytes)
fs/ncpfs/file.c:	if (pos + count > inode->i_sb->s_maxbytes) {
fs/ncpfs/file.c:		count = inode->i_sb->s_maxbytes - pos;
fs/ncpfs/file.c:	if (pos >= inode->i_sb->s_maxbytes) {
fs/ncpfs/file.c:		if (count || pos > inode->i_sb->s_maxbytes) {
fs/ncpfs/file.c:	if (pos + count > inode->i_sb->s_maxbytes) {
fs/ncpfs/file.c:		count = inode->i_sb->s_maxbytes - pos;
fs/ncpfs/file.c:		mutex_lock(&inode->i_mutex);
fs/ncpfs/file.c:		mutex_unlock(&inode->i_mutex);
fs/ncpfs/ioctl.c:			result = ncp_conn_logged_in(inode->i_sb);
fs/ncpfs/ioctl.c:				struct dentry* dentry = inode->i_sb->s_root;
fs/ncpfs/ioctl.c:					dentry = inode->i_sb->s_root;
fs/ncpfs/ioctl.c:			if (!S_ISREG(inode->i_mode))
fs/squashfs/inode.c:	inode->i_ino = le32_to_cpu(sqsh_ino->inode_number);
fs/squashfs/inode.c:	inode->i_mtime.tv_sec = le32_to_cpu(sqsh_ino->mtime);
fs/squashfs/inode.c:	inode->i_atime.tv_sec = inode->i_mtime.tv_sec;
fs/squashfs/inode.c:	inode->i_ctime.tv_sec = inode->i_mtime.tv_sec;
fs/squashfs/inode.c:	inode->i_mode = le16_to_cpu(sqsh_ino->mode);
fs/squashfs/inode.c:	inode->i_size = 0;
fs/squashfs/inode.c:	if (!(inode->i_state & I_NEW))
fs/squashfs/inode.c:	struct super_block *sb = inode->i_sb;
fs/squashfs/inode.c:		inode->i_size = le32_to_cpu(sqsh_ino->file_size);
fs/squashfs/inode.c:		inode->i_fop = &generic_ro_fops;
fs/squashfs/inode.c:		inode->i_mode |= S_IFREG;
fs/squashfs/inode.c:		inode->i_blocks = ((inode->i_size - 1) >> 9) + 1;
fs/squashfs/inode.c:		inode->i_data.a_ops = &squashfs_aops;
fs/squashfs/inode.c:		inode->i_size = le64_to_cpu(sqsh_ino->file_size);
fs/squashfs/inode.c:		inode->i_op = &squashfs_inode_ops;
fs/squashfs/inode.c:		inode->i_fop = &generic_ro_fops;
fs/squashfs/inode.c:		inode->i_mode |= S_IFREG;
fs/squashfs/inode.c:		inode->i_blocks = (inode->i_size -
fs/squashfs/inode.c:		inode->i_data.a_ops = &squashfs_aops;
fs/squashfs/inode.c:		inode->i_size = le16_to_cpu(sqsh_ino->file_size);
fs/squashfs/inode.c:		inode->i_op = &squashfs_dir_inode_ops;
fs/squashfs/inode.c:		inode->i_fop = &squashfs_dir_ops;
fs/squashfs/inode.c:		inode->i_mode |= S_IFDIR;
fs/squashfs/inode.c:		inode->i_size = le32_to_cpu(sqsh_ino->file_size);
fs/squashfs/inode.c:		inode->i_op = &squashfs_dir_inode_ops;
fs/squashfs/inode.c:		inode->i_fop = &squashfs_dir_ops;
fs/squashfs/inode.c:		inode->i_mode |= S_IFDIR;
fs/squashfs/inode.c:		inode->i_size = le32_to_cpu(sqsh_ino->symlink_size);
fs/squashfs/inode.c:		inode->i_op = &squashfs_symlink_inode_ops;
fs/squashfs/inode.c:		inode->i_data.a_ops = &squashfs_symlink_aops;
fs/squashfs/inode.c:		inode->i_mode |= S_IFLNK;
fs/squashfs/inode.c:						&offset, inode->i_size);
fs/squashfs/inode.c:			inode->i_mode |= S_IFCHR;
fs/squashfs/inode.c:			inode->i_mode |= S_IFBLK;
fs/squashfs/inode.c:		init_special_inode(inode, inode->i_mode, new_decode_dev(rdev));
fs/squashfs/inode.c:			inode->i_mode |= S_IFCHR;
fs/squashfs/inode.c:			inode->i_mode |= S_IFBLK;
fs/squashfs/inode.c:		inode->i_op = &squashfs_inode_ops;
fs/squashfs/inode.c:		init_special_inode(inode, inode->i_mode, new_decode_dev(rdev));
fs/squashfs/inode.c:			inode->i_mode |= S_IFIFO;
fs/squashfs/inode.c:			inode->i_mode |= S_IFSOCK;
fs/squashfs/inode.c:		init_special_inode(inode, inode->i_mode, 0);
fs/squashfs/inode.c:			inode->i_mode |= S_IFIFO;
fs/squashfs/inode.c:			inode->i_mode |= S_IFSOCK;
fs/squashfs/inode.c:		inode->i_op = &squashfs_inode_ops;
fs/squashfs/inode.c:		init_special_inode(inode, inode->i_mode, 0);
fs/squashfs/inode.c:		inode->i_blocks += ((squashfs_i(inode)->xattr_size - 1) >> 9)
fs/squashfs/super.c:	call_rcu(&inode->i_rcu, squashfs_i_callback);
fs/squashfs/dir.c:	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
fs/squashfs/dir.c:			i_ino = inode->i_ino;
fs/squashfs/dir.c:	length = get_dir_index_using_offset(inode->i_sb, &block, &offset,
fs/squashfs/dir.c:		err = squashfs_read_metadata(inode->i_sb, &dirh, &block,
fs/squashfs/dir.c:			err = squashfs_read_metadata(inode->i_sb, dire, &block,
fs/squashfs/dir.c:			err = squashfs_read_metadata(inode->i_sb, dire->name,
fs/squashfs/symlink.c:	struct super_block *sb = inode->i_sb;
fs/squashfs/file.c:	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
fs/squashfs/file.c:		if (msblk->meta_index[i].inode_number == inode->i_ino &&
fs/squashfs/file.c:	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
fs/squashfs/file.c:	meta->inode_number = inode->i_ino;
fs/squashfs/file.c:	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
fs/squashfs/file.c:	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
fs/squashfs/file.c:			long long res = read_indexes(inode->i_sb, blocks,
fs/squashfs/file.c:		blks = read_indexes(inode->i_sb, index - res, &start, &offset);
fs/squashfs/file.c:	res = squashfs_read_metadata(inode->i_sb, &size, &start, &offset,
fs/squashfs/file.c:	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
fs/squashfs/file.c:			buffer = squashfs_get_datablock(inode->i_sb,
fs/squashfs/file.c:		buffer = squashfs_get_fragment(inode->i_sb,
fs/squashfs/export.c:	return squashfs_export_iget(inode->i_sb, parent_ino);
fs/squashfs/xattr.c:	struct super_block *sb = inode->i_sb;
fs/squashfs/xattr.c:	struct super_block *sb = inode->i_sb;
fs/xattr.c:		if (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))
fs/xattr.c:		if (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&
fs/xattr.c:		inode->i_flags &= ~S_NOSEC;
fs/xattr.c:	if (inode->i_op->setxattr) {
fs/xattr.c:		error = inode->i_op->setxattr(dentry, name, value, size, flags);
fs/xattr.c:	mutex_lock(&inode->i_mutex);
fs/xattr.c:	mutex_unlock(&inode->i_mutex);
fs/xattr.c:	if (!inode->i_op->getxattr)
fs/xattr.c:	error = inode->i_op->getxattr(dentry, name, NULL, 0);
fs/xattr.c:	error = inode->i_op->getxattr(dentry, name, value, error);
fs/xattr.c:	if (inode->i_op->getxattr)
fs/xattr.c:		error = inode->i_op->getxattr(dentry, name, value, size);
fs/xattr.c:	if (d->d_inode->i_op->listxattr) {
fs/xattr.c:		error = d->d_inode->i_op->listxattr(d, list, size);
fs/xattr.c:	if (!inode->i_op->removexattr)
fs/xattr.c:	mutex_lock(&inode->i_mutex);
fs/xattr.c:		mutex_unlock(&inode->i_mutex);
fs/xattr.c:	error = inode->i_op->removexattr(dentry, name);
fs/xattr.c:	mutex_unlock(&inode->i_mutex);
fs/read_write.c:					inode->i_sb->s_maxbytes,
fs/read_write.c:	mutex_lock(&inode->i_mutex);
fs/read_write.c:			if (offset >= inode->i_size) {
fs/read_write.c:			if (offset >= inode->i_size) {
fs/read_write.c:			offset = inode->i_size;
fs/read_write.c:	mutex_unlock(&inode->i_mutex);
fs/read_write.c:	if (unlikely(inode->i_flock && mandatory_lock(inode))) {
fs/read_write.c:		max = min(in_inode->i_sb->s_maxbytes, out_inode->i_sb->s_maxbytes);
fs/ext4/inode.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/inode.c:	if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&
fs/ext4/inode.c:			   EXT4_INODE_SIZE(inode->i_sb));
fs/ext4/inode.c:	if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&
fs/ext4/inode.c:	if (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=
fs/ext4/inode.c:	    !EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/inode.c:	if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&
fs/ext4/inode.c:	if (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=
fs/ext4/inode.c:	    !EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/inode.c:	if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&
fs/ext4/inode.c:		(inode->i_sb->s_blocksize >> 9) : 0;
fs/ext4/inode.c:	return (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);
fs/ext4/inode.c:	if (inode->i_nlink) {
fs/ext4/inode.c:		    (S_ISLNK(inode->i_mode) || S_ISREG(inode->i_mode)) &&
fs/ext4/inode.c:		    inode->i_ino != EXT4_JOURNAL_INO) {
fs/ext4/inode.c:			journal_t *journal = EXT4_SB(inode->i_sb)->s_journal;
fs/ext4/inode.c:			filemap_write_and_wait(&inode->i_data);
fs/ext4/inode.c:		truncate_inode_pages(&inode->i_data, 0);
fs/ext4/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/ext4/inode.c:	sb_start_intwrite(inode->i_sb);
fs/ext4/inode.c:		ext4_std_error(inode->i_sb, PTR_ERR(handle));
fs/ext4/inode.c:		sb_end_intwrite(inode->i_sb);
fs/ext4/inode.c:	inode->i_size = 0;
fs/ext4/inode.c:		ext4_warning(inode->i_sb,
fs/ext4/inode.c:	if (inode->i_blocks)
fs/ext4/inode.c:			ext4_warning(inode->i_sb,
fs/ext4/inode.c:			sb_end_intwrite(inode->i_sb);
fs/ext4/inode.c:	sb_end_intwrite(inode->i_sb);
fs/ext4/inode.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/inode.c:		ext4_msg(inode->i_sb, KERN_NOTICE, "%s: ino %lu, used %d "
fs/ext4/inode.c:			 __func__, inode->i_ino, used,
fs/ext4/inode.c:		ext4_msg(inode->i_sb, KERN_NOTICE, "%s: ino %lu, allocated %d "
fs/ext4/inode.c:			 inode->i_ino, ei->i_allocated_meta_blocks,
fs/ext4/inode.c:	    (atomic_read(&inode->i_writecount) == 0))
fs/ext4/inode.c:	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
fs/ext4/inode.c:	struct address_space *mapping = inode->i_mapping;
fs/ext4/inode.c:		  "logical block %lu\n", inode->i_ino, flags, map->m_len,
fs/ext4/inode.c:	map.m_len = bh->b_size >> inode->i_blkbits;
fs/ext4/inode.c:		map_bh(bh, inode->i_sb, map.m_pblk);
fs/ext4/inode.c:		bh->b_size = inode->i_sb->s_blocksize * map.m_len;
fs/ext4/inode.c:	bh = sb_getblk(inode->i_sb, map.m_pblk);
fs/ext4/inode.c:			memset(bh->b_data, 0, inode->i_sb->s_blocksize);
fs/ext4/inode.c:		if (pos + len > inode->i_size && ext4_can_truncate(inode))
fs/ext4/inode.c:		if (pos + len > inode->i_size) {
fs/ext4/inode.c:			if (inode->i_nlink)
fs/ext4/inode.c:	if (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))
fs/ext4/inode.c:	if (pos + copied > inode->i_size) {
fs/ext4/inode.c:		 * new_i_size is less that inode->i_size
fs/ext4/inode.c: * ext4 never places buffers on inode->i_mapping->private_list.  metadata
fs/ext4/inode.c:		if (pos + len > inode->i_size && ext4_can_truncate(inode))
fs/ext4/inode.c:			 * inode->i_size. So truncate them
fs/ext4/inode.c:	if (pos + len > inode->i_size) {
fs/ext4/inode.c:		if (inode->i_nlink)
fs/ext4/inode.c:	if (pos + len > inode->i_size && ext4_can_truncate(inode))
fs/ext4/inode.c:		 * inode->i_size. So truncate them
fs/ext4/inode.c:	if (pos + len > inode->i_size) {
fs/ext4/inode.c:		if (inode->i_nlink)
fs/ext4/inode.c:	if (new_i_size > inode->i_size)
fs/ext4/inode.c:	if (pos + len > inode->i_size && ext4_can_truncate(inode))
fs/ext4/inode.c:		 * inode->i_size. So truncate them
fs/ext4/inode.c:	if (pos + len > inode->i_size) {
fs/ext4/inode.c:		if (inode->i_nlink)
fs/ext4/inode.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/inode.c:		if (ext4_should_retry_alloc(inode->i_sb, &retries)) {
fs/ext4/inode.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/inode.c:		ext4_msg(inode->i_sb, KERN_NOTICE, "ext4_da_release_space: "
fs/ext4/inode.c:			 "data blocks", inode->i_ino, to_free,
fs/ext4/inode.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/inode.c:		lblk = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/ext4/inode.c:		lblk = (page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits)) +
fs/ext4/inode.c:	struct address_space *mapping = inode->i_mapping;
fs/ext4/inode.c:							inode->i_blkbits);
fs/ext4/inode.c:			else if (test_opt(inode->i_sb, MBLK_IO_SUBMIT))
fs/ext4/inode.c:	struct address_space *mapping = inode->i_mapping;
fs/ext4/inode.c:	start = index << (PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/ext4/inode.c:	last = end << (PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/ext4/inode.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/inode.c:	struct super_block *sb = inode->i_sb;
fs/ext4/inode.c:	       EXT4_C2B(EXT4_SB(inode->i_sb),
fs/ext4/inode.c:			ext4_count_free_clusters(inode->i_sb)));
fs/ext4/inode.c:	       (long long) EXT4_C2B(EXT4_SB(inode->i_sb),
fs/ext4/inode.c:	       (long long) EXT4_C2B(EXT4_SB(inode->i_sb),
fs/ext4/inode.c:	unsigned max_blocks = mpd->b_size >> mpd->inode->i_blkbits;
fs/ext4/inode.c:		struct super_block *sb = mpd->inode->i_sb;
fs/ext4/inode.c:				 "with error %d", mpd->inode->i_ino,
fs/ext4/inode.c:				 mpd->b_size >> mpd->inode->i_blkbits, err);
fs/ext4/inode.c:		struct block_device *bdev = mpd->inode->i_sb->s_bdev;
fs/ext4/inode.c:	disksize = ((loff_t) next + blks) << mpd->inode->i_blkbits;
fs/ext4/inode.c:			ext4_error(mpd->inode->i_sb,
fs/ext4/inode.c:				   mpd->inode->i_ino);
fs/ext4/inode.c:	int nrblocks = mpd->b_size >> mpd->inode->i_blkbits;
fs/ext4/inode.c:	if (nrblocks >= 8*1024*1024/mpd->inode->i_sb->s_blocksize)
fs/ext4/inode.c:		} else if ((nrblocks + (b_size >> mpd->inode->i_blkbits)) >
fs/ext4/inode.c:						mpd->inode->i_blkbits;
fs/ext4/inode.c:	if (invalid_block < ext4_blocks_count(EXT4_SB(inode->i_sb)->s_es))
fs/ext4/inode.c:		  "logical block %lu\n", inode->i_ino, map->m_len,
fs/ext4/inode.c:		if ((EXT4_SB(inode->i_sb)->s_cluster_ratio > 1) &&
fs/ext4/inode.c:		map_bh(bh, inode->i_sb, invalid_block);
fs/ext4/inode.c:	BUG_ON(bh->b_size != inode->i_sb->s_blocksize);
fs/ext4/inode.c:	map_bh(bh, inode->i_sb, map.m_pblk);
fs/ext4/inode.c:	BUG_ON(bh_result->b_size != inode->i_sb->s_blocksize);
fs/ext4/inode.c:				(PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/ext4/inode.c:			ext4_msg(inode->i_sb, KERN_CRIT, "%s: jbd2_start: "
fs/ext4/inode.c:				wbc->nr_to_write, inode->i_ino, ret);
fs/ext4/inode.c:	if (ext4_nonda_switch(inode->i_sb)) {
fs/ext4/inode.c:		if (pos + len > inode->i_size)
fs/ext4/inode.c:	if (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))
fs/ext4/inode.c:	idx = offset >> inode->i_blkbits;
fs/ext4/inode.c:			 * new_i_size is less that inode->i_size
fs/ext4/inode.c:	return filemap_flush(inode->i_mapping);
fs/ext4/inode.c:			test_opt(inode->i_sb, DELALLOC)) {
fs/ext4/inode.c:		   inode->i_ino, create);
fs/ext4/inode.c:		   inode->i_ino, create);
fs/ext4/inode.c: 		  iocb->private, io_end->inode->i_ino, iocb, offset,
fs/ext4/inode.c:	if (!(io_end->inode->i_sb->s_flags & MS_ACTIVE)) {
fs/ext4/inode.c:		ext4_msg(io_end->inode->i_sb, KERN_INFO,
fs/ext4/inode.c:			 io_end->inode->i_ino);
fs/ext4/inode.c:	if (rw != WRITE || final_size > inode->i_size)
fs/ext4/inode.c:		atomic_inc(&inode->i_dio_count);
fs/ext4/inode.c:		mutex_unlock(&inode->i_mutex);
fs/ext4/inode.c:				   inode->i_sb->s_bdev, iov,
fs/ext4/inode.c:		mutex_lock(&inode->i_mutex);
fs/ext4/inode.c:		if (test_opt(inode->i_sb, DELALLOC))
fs/ext4/inode.c:			inode->i_mapping->a_ops = &ext4_da_aops;
fs/ext4/inode.c:			inode->i_mapping->a_ops = &ext4_ordered_aops;
fs/ext4/inode.c:		if (test_opt(inode->i_sb, DELALLOC))
fs/ext4/inode.c:			inode->i_mapping->a_ops = &ext4_da_aops;
fs/ext4/inode.c:			inode->i_mapping->a_ops = &ext4_writeback_aops;
fs/ext4/inode.c:		inode->i_mapping->a_ops = &ext4_journalled_aops;
fs/ext4/inode.c:	blocksize = inode->i_sb->s_blocksize;
fs/ext4/inode.c:	iblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);
fs/ext4/inode.c:	if (S_ISREG(inode->i_mode))
fs/ext4/inode.c:	if (S_ISDIR(inode->i_mode))
fs/ext4/inode.c:	if (S_ISLNK(inode->i_mode))
fs/ext4/inode.c:	if (!S_ISREG(inode->i_mode))
fs/ext4/inode.c:	if (EXT4_SB(inode->i_sb)->s_cluster_ratio > 1) {
fs/ext4/inode.c:	if (inode->i_size == 0 && !test_opt(inode->i_sb, NO_AUTO_DA_ALLOC))
fs/ext4/inode.c:	struct super_block	*sb = inode->i_sb;
fs/ext4/inode.c:	if (!ext4_valid_inum(sb, inode->i_ino))
fs/ext4/inode.c:	iloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);
fs/ext4/inode.c:	inode_offset = ((inode->i_ino - 1) %
fs/ext4/inode.c:	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);
fs/ext4/inode.c:		inode->i_flags |= S_SYNC;
fs/ext4/inode.c:		inode->i_flags |= S_APPEND;
fs/ext4/inode.c:		inode->i_flags |= S_IMMUTABLE;
fs/ext4/inode.c:		inode->i_flags |= S_NOATIME;
fs/ext4/inode.c:		inode->i_flags |= S_DIRSYNC;
fs/ext4/inode.c:	struct super_block *sb = inode->i_sb;
fs/ext4/inode.c:		i_blocks = ((u64)le16_to_cpu(raw_inode->i_blocks_high)) << 32 |
fs/ext4/inode.c:					le32_to_cpu(raw_inode->i_blocks_lo);
fs/ext4/inode.c:			return i_blocks  << (inode->i_blkbits - 9);
fs/ext4/inode.c:		return le32_to_cpu(raw_inode->i_blocks_lo);
fs/ext4/inode.c:	if (!(inode->i_state & I_NEW))
fs/ext4/inode.c:	if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {
fs/ext4/inode.c:		ei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);
fs/ext4/inode.c:		    EXT4_INODE_SIZE(inode->i_sb)) {
fs/ext4/inode.c:				EXT4_INODE_SIZE(inode->i_sb));
fs/ext4/inode.c:		struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/inode.c:		__le32 inum = cpu_to_le32(inode->i_ino);
fs/ext4/inode.c:		__le32 gen = raw_inode->i_generation;
fs/ext4/inode.c:	inode->i_mode = le16_to_cpu(raw_inode->i_mode);
fs/ext4/inode.c:	i_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
fs/ext4/inode.c:	i_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
fs/ext4/inode.c:	if (!(test_opt(inode->i_sb, NO_UID32))) {
fs/ext4/inode.c:		i_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;
fs/ext4/inode.c:		i_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;
fs/ext4/inode.c:	set_nlink(inode, le16_to_cpu(raw_inode->i_links_count));
fs/ext4/inode.c:	ei->i_dtime = le32_to_cpu(raw_inode->i_dtime);
fs/ext4/inode.c:	if (inode->i_nlink == 0) {
fs/ext4/inode.c:		if (inode->i_mode == 0 ||
fs/ext4/inode.c:		    !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS)) {
fs/ext4/inode.c:	ei->i_flags = le32_to_cpu(raw_inode->i_flags);
fs/ext4/inode.c:	inode->i_blocks = ext4_inode_blocks(raw_inode, ei);
fs/ext4/inode.c:	ei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl_lo);
fs/ext4/inode.c:			((__u64)le16_to_cpu(raw_inode->i_file_acl_high)) << 32;
fs/ext4/inode.c:	inode->i_size = ext4_isize(raw_inode);
fs/ext4/inode.c:	ei->i_disksize = inode->i_size;
fs/ext4/inode.c:	inode->i_generation = le32_to_cpu(raw_inode->i_generation);
fs/ext4/inode.c:		ei->i_data[block] = raw_inode->i_block[block];
fs/ext4/inode.c:	if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {
fs/ext4/inode.c:	inode->i_version = le32_to_cpu(raw_inode->i_disk_version);
fs/ext4/inode.c:	if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {
fs/ext4/inode.c:			inode->i_version |=
fs/ext4/inode.c:			(__u64)(le32_to_cpu(raw_inode->i_version_hi)) << 32;
fs/ext4/inode.c:			if ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
fs/ext4/inode.c:			    (S_ISLNK(inode->i_mode) &&
fs/ext4/inode.c:		} else if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
fs/ext4/inode.c:			   (S_ISLNK(inode->i_mode) &&
fs/ext4/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/ext4/inode.c:		inode->i_op = &ext4_file_inode_operations;
fs/ext4/inode.c:		inode->i_fop = &ext4_file_operations;
fs/ext4/inode.c:	} else if (S_ISDIR(inode->i_mode)) {
fs/ext4/inode.c:		inode->i_op = &ext4_dir_inode_operations;
fs/ext4/inode.c:		inode->i_fop = &ext4_dir_operations;
fs/ext4/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/ext4/inode.c:			inode->i_op = &ext4_fast_symlink_inode_operations;
fs/ext4/inode.c:			nd_terminate_link(ei->i_data, inode->i_size,
fs/ext4/inode.c:			inode->i_op = &ext4_symlink_inode_operations;
fs/ext4/inode.c:	} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||
fs/ext4/inode.c:	      S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {
fs/ext4/inode.c:		inode->i_op = &ext4_special_inode_operations;
fs/ext4/inode.c:		if (raw_inode->i_block[0])
fs/ext4/inode.c:			init_special_inode(inode, inode->i_mode,
fs/ext4/inode.c:			   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));
fs/ext4/inode.c:			init_special_inode(inode, inode->i_mode,
fs/ext4/inode.c:			   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));
fs/ext4/inode.c:		EXT4_ERROR_INODE(inode, "bogus i_mode (%o)", inode->i_mode);
fs/ext4/inode.c:	u64 i_blocks = inode->i_blocks;
fs/ext4/inode.c:	struct super_block *sb = inode->i_sb;
fs/ext4/inode.c:		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
fs/ext4/inode.c:		raw_inode->i_blocks_high = 0;
fs/ext4/inode.c:		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
fs/ext4/inode.c:		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);
fs/ext4/inode.c:		i_blocks = i_blocks >> (inode->i_blkbits - 9);
fs/ext4/inode.c:		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
fs/ext4/inode.c:		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);
fs/ext4/inode.c:		memset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);
fs/ext4/inode.c:	raw_inode->i_mode = cpu_to_le16(inode->i_mode);
fs/ext4/inode.c:	if (!(test_opt(inode->i_sb, NO_UID32))) {
fs/ext4/inode.c:		raw_inode->i_uid_low = cpu_to_le16(low_16_bits(i_uid));
fs/ext4/inode.c:		raw_inode->i_gid_low = cpu_to_le16(low_16_bits(i_gid));
fs/ext4/inode.c:			raw_inode->i_uid_high =
fs/ext4/inode.c:			raw_inode->i_gid_high =
fs/ext4/inode.c:			raw_inode->i_uid_high = 0;
fs/ext4/inode.c:			raw_inode->i_gid_high = 0;
fs/ext4/inode.c:		raw_inode->i_uid_low = cpu_to_le16(fs_high2lowuid(i_uid));
fs/ext4/inode.c:		raw_inode->i_gid_low = cpu_to_le16(fs_high2lowgid(i_gid));
fs/ext4/inode.c:		raw_inode->i_uid_high = 0;
fs/ext4/inode.c:		raw_inode->i_gid_high = 0;
fs/ext4/inode.c:	raw_inode->i_links_count = cpu_to_le16(inode->i_nlink);
fs/ext4/inode.c:	raw_inode->i_dtime = cpu_to_le32(ei->i_dtime);
fs/ext4/inode.c:	raw_inode->i_flags = cpu_to_le32(ei->i_flags & 0xFFFFFFFF);
fs/ext4/inode.c:	if (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=
fs/ext4/inode.c:		raw_inode->i_file_acl_high =
fs/ext4/inode.c:	raw_inode->i_file_acl_lo = cpu_to_le32(ei->i_file_acl);
fs/ext4/inode.c:		struct super_block *sb = inode->i_sb;
fs/ext4/inode.c:	raw_inode->i_generation = cpu_to_le32(inode->i_generation);
fs/ext4/inode.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {
fs/ext4/inode.c:		if (old_valid_dev(inode->i_rdev)) {
fs/ext4/inode.c:			raw_inode->i_block[0] =
fs/ext4/inode.c:				cpu_to_le32(old_encode_dev(inode->i_rdev));
fs/ext4/inode.c:			raw_inode->i_block[1] = 0;
fs/ext4/inode.c:			raw_inode->i_block[0] = 0;
fs/ext4/inode.c:			raw_inode->i_block[1] =
fs/ext4/inode.c:				cpu_to_le32(new_encode_dev(inode->i_rdev));
fs/ext4/inode.c:			raw_inode->i_block[2] = 0;
fs/ext4/inode.c:			raw_inode->i_block[block] = ei->i_data[block];
fs/ext4/inode.c:	raw_inode->i_disk_version = cpu_to_le32(inode->i_version);
fs/ext4/inode.c:			raw_inode->i_version_hi =
fs/ext4/inode.c:			cpu_to_le32(inode->i_version >> 32);
fs/ext4/inode.c:		raw_inode->i_extra_isize = cpu_to_le16(ei->i_extra_isize);
fs/ext4/inode.c:	ext4_std_error(inode->i_sb, err);
fs/ext4/inode.c: *	inode->i_size = expr;
fs/ext4/inode.c:	if (EXT4_SB(inode->i_sb)->s_journal) {
fs/ext4/inode.c:		err = ext4_force_commit(inode->i_sb);
fs/ext4/inode.c:	journal_t *journal = EXT4_SB(inode->i_sb)->s_journal;
fs/ext4/inode.c:	offset = inode->i_size & (PAGE_CACHE_SIZE - 1);
fs/ext4/inode.c:	if (offset > PAGE_CACHE_SIZE - (1 << inode->i_blkbits))
fs/ext4/inode.c:		page = find_lock_page(inode->i_mapping,
fs/ext4/inode.c:				      inode->i_size >> PAGE_CACHE_SHIFT);
fs/ext4/inode.c: * Called with inode->i_mutex down.
fs/ext4/inode.c:	if ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||
fs/ext4/inode.c:	    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {
fs/ext4/inode.c:		handle = ext4_journal_start(inode, (EXT4_MAXQUOTAS_INIT_BLOCKS(inode->i_sb)+
fs/ext4/inode.c:					EXT4_MAXQUOTAS_DEL_BLOCKS(inode->i_sb))+3);
fs/ext4/inode.c:			inode->i_uid = attr->ia_uid;
fs/ext4/inode.c:			inode->i_gid = attr->ia_gid;
fs/ext4/inode.c:			struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/inode.c:	if (S_ISREG(inode->i_mode) &&
fs/ext4/inode.c:	    (attr->ia_size < inode->i_size)) {
fs/ext4/inode.c:		if (attr->ia_size != inode->i_size) {
fs/ext4/inode.c:			loff_t oldsize = inode->i_size;
fs/ext4/inode.c:			truncate_pagecache(inode, oldsize, inode->i_size);
fs/ext4/inode.c:	if (orphan && inode->i_nlink)
fs/ext4/inode.c:	ext4_std_error(inode->i_sb, error);
fs/ext4/inode.c:	delalloc_blocks = EXT4_C2B(EXT4_SB(inode->i_sb),
fs/ext4/inode.c:	stat->blocks += (delalloc_blocks << inode->i_sb->s_blocksize_bits)>>9;
fs/ext4/inode.c:	ext4_group_t groups, ngroups = ext4_get_groups_count(inode->i_sb);
fs/ext4/inode.c:	if (groups > EXT4_SB(inode->i_sb)->s_gdb_count)
fs/ext4/inode.c:		gdpblocks = EXT4_SB(inode->i_sb)->s_gdb_count;
fs/ext4/inode.c:	ret += EXT4_META_TRANS_BLOCKS(inode->i_sb);
fs/ext4/inode.c:	ext4_std_error(inode->i_sb, err);
fs/ext4/inode.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/inode.c:			     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {
fs/ext4/inode.c:					ext4_warning(inode->i_sb,
fs/ext4/inode.c:					inode->i_ino);
fs/ext4/inode.c:	ext4_std_error(inode->i_sb, err);
fs/ext4/inode.c:	if (val && test_opt(inode->i_sb, DELALLOC)) {
fs/ext4/inode.c:	ext4_std_error(inode->i_sb, err);
fs/ext4/inode.c:	struct address_space *mapping = inode->i_mapping;
fs/ext4/inode.c:	sb_start_pagefault(inode->i_sb);
fs/ext4/inode.c:	if (test_opt(inode->i_sb, DELALLOC) &&
fs/ext4/inode.c:	    !ext4_nonda_switch(inode->i_sb)) {
fs/ext4/inode.c:		       ext4_should_retry_alloc(inode->i_sb, &retries));
fs/ext4/inode.c:	if (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))
fs/ext4/inode.c:	sb_end_pagefault(inode->i_sb);
fs/ext4/ext4_jbd2.h:	return ext4_journal_start_sb(inode->i_sb, nblocks);
fs/ext4/ext4_jbd2.h:	if (!S_ISREG(inode->i_mode) ||
fs/ext4/ext4_jbd2.h:	    test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)
fs/ext4/ext4_jbd2.h:	    !test_opt(inode->i_sb, DELALLOC))
fs/ext4/ext4_jbd2.h:	if (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)
fs/ext4/ext4_jbd2.h:	if (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)
fs/ext4/ext4_jbd2.h:	if (!test_opt(inode->i_sb, DIOREAD_NOLOCK))
fs/ext4/ext4_jbd2.h:	if (!S_ISREG(inode->i_mode))
fs/ext4/truncate.h:	truncate_inode_pages(inode->i_mapping, inode->i_size);
fs/ext4/truncate.h:	needed = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);
fs/ext4/truncate.h:	return EXT4_DATA_TRANS_BLOCKS(inode->i_sb) + needed;
fs/ext4/super.c:	struct backing_dev_info *bdi = bd_inode->i_mapping->backing_dev_info;
fs/ext4/super.c:	struct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;
fs/ext4/super.c:	es->s_last_error_ino = cpu_to_le32(inode->i_ino);
fs/ext4/super.c:	save_error_info(inode->i_sb, function, line);
fs/ext4/super.c:		       inode->i_sb->s_id, function, line, inode->i_ino,
fs/ext4/super.c:		       inode->i_sb->s_id, function, line, inode->i_ino,
fs/ext4/super.c:	ext4_handle_error(inode->i_sb);
fs/ext4/super.c:	es = EXT4_SB(inode->i_sb)->s_es;
fs/ext4/super.c:	es->s_last_error_ino = cpu_to_le32(inode->i_ino);
fs/ext4/super.c:	save_error_info(inode->i_sb, function, line);
fs/ext4/super.c:		       inode->i_sb->s_id, function, line, inode->i_ino,
fs/ext4/super.c:		       inode->i_sb->s_id, function, line, inode->i_ino,
fs/ext4/super.c:	ext4_handle_error(inode->i_sb);
fs/ext4/super.c:		       inode->i_sb->s_id, inode->i_ino, inode,
fs/ext4/super.c:		       inode->i_mode, inode->i_nlink,
fs/ext4/super.c:		ext4_msg(inode->i_sb, KERN_ERR,
fs/ext4/super.c:			 inode->i_ino, EXT4_I(inode));
fs/ext4/super.c:	call_rcu(&inode->i_rcu, ext4_i_callback);
fs/ext4/super.c:	if (generation && inode->i_generation != generation) {
fs/ext4/super.c:		if (inode->i_nlink) {
fs/ext4/super.c:				__func__, inode->i_ino, inode->i_size);
fs/ext4/super.c:				  inode->i_ino, inode->i_size);
fs/ext4/super.c:			mutex_lock(&inode->i_mutex);
fs/ext4/super.c:			mutex_unlock(&inode->i_mutex);
fs/ext4/super.c:				__func__, inode->i_ino);
fs/ext4/super.c:				  inode->i_ino);
fs/ext4/super.c:	blocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;
fs/ext4/super.c:	if (!journal_inode->i_nlink) {
fs/ext4/super.c:		  journal_inode, journal_inode->i_size);
fs/ext4/super.c:	if (!S_ISREG(journal_inode->i_mode)) {
fs/ext4/super.c:	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/ext4/super.c:	if (inode->i_size < off + len) {
fs/ext4/super.c:		EXT4_I(inode)->i_disksize = inode->i_size;
fs/ext4/extents.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/extents.c:	if (!EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/extents.c:	if (!EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/extents.c:	size = (inode->i_sb->s_blocksize - sizeof(struct ext4_extent_header))
fs/ext4/extents.c:	size = (inode->i_sb->s_blocksize - sizeof(struct ext4_extent_header))
fs/ext4/extents.c:	idxs = ((inode->i_sb->s_blocksize - sizeof(struct ext4_extent_header))
fs/ext4/extents.c:	return ext4_data_block_valid(EXT4_SB(inode->i_sb), block, len);
fs/ext4/extents.c:	return ext4_data_block_valid(EXT4_SB(inode->i_sb), block, 1);
fs/ext4/extents.c:	ext_debug("Displaying leaf extents for inode %lu\n", inode->i_ino);
fs/ext4/extents.c:		bh = sb_getblk(inode->i_sb, path[ppos].p_block);
fs/ext4/extents.c:	ext4_std_error(inode->i_sb, err);
fs/ext4/extents.c:	bh = sb_getblk(inode->i_sb, newblock);
fs/ext4/extents.c:		bh = sb_getblk(inode->i_sb, newblock);
fs/ext4/extents.c:	bh = sb_getblk(inode->i_sb, newblock);
fs/ext4/extents.c:		bh = sb_bread(inode->i_sb, block);
fs/ext4/extents.c:	bh = sb_bread(inode->i_sb, block);
fs/ext4/extents.c:	unsigned char blksize_bits = inode->i_sb->s_blocksize_bits;
fs/ext4/extents.c:			ret = 2 + EXT4_META_TRANS_BLOCKS(inode->i_sb);
fs/ext4/extents.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/extents.c:	if (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))
fs/ext4/extents.c:		struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/extents.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/extents.c:		credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));
fs/ext4/extents.c:		credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);
fs/ext4/extents.c:		if (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))
fs/ext4/extents.c:	struct super_block *sb = inode->i_sb;
fs/ext4/extents.c:		if (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))
fs/ext4/extents.c:	ret = sb_issue_zeroout(inode->i_sb, ee_pblock, ee_len, GFP_NOFS);
fs/ext4/extents.c:		"block %llu\n", inode->i_ino, (unsigned long long)split);
fs/ext4/extents.c:		"block %llu, max_blocks %u\n", inode->i_ino,
fs/ext4/extents.c:	sbi = EXT4_SB(inode->i_sb);
fs/ext4/extents.c:	eof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>
fs/ext4/extents.c:		inode->i_sb->s_blocksize_bits;
fs/ext4/extents.c:			(inode->i_sb->s_blocksize_bits - 10);
fs/ext4/extents.c:		"block %llu, max_blocks %u\n", inode->i_ino,
fs/ext4/extents.c:	eof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>
fs/ext4/extents.c:		inode->i_sb->s_blocksize_bits;
fs/ext4/extents.c:		"block %llu, max_blocks %u\n", inode->i_ino,
fs/ext4/extents.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/extents.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/extents.c:		  inode->i_ino, (unsigned long long)map->m_lblk, map->m_len,
fs/ext4/extents.c:		unmap_underlying_metadata_blocks(inode->i_sb->s_bdev,
fs/ext4/extents.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/extents.c:		  map->m_lblk, map->m_len, inode->i_ino);
fs/ext4/extents.c:	    get_implied_cluster_alloc(inode->i_sb, map, ex, path)) {
fs/ext4/extents.c:	    get_implied_cluster_alloc(inode->i_sb, map, ex2, path)) {
fs/ext4/extents.c:	if (S_ISREG(inode->i_mode))
fs/ext4/extents.c:	struct address_space *mapping = inode->i_mapping;
fs/ext4/extents.c:	struct super_block *sb = inode->i_sb;
fs/ext4/extents.c:	if (inode->i_size % PAGE_CACHE_SIZE != 0) {
fs/ext4/extents.c:			(inode->i_size & (PAGE_CACHE_SIZE - 1));
fs/ext4/extents.c:			mapping, inode->i_size, page_len, 0);
fs/ext4/extents.c:	EXT4_I(inode)->i_disksize = inode->i_size;
fs/ext4/extents.c:	last_block = (inode->i_size + sb->s_blocksize - 1)
fs/ext4/extents.c:	if (inode->i_nlink)
fs/ext4/extents.c:	inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
fs/ext4/extents.c:		now = current_fs_time(inode->i_sb);
fs/ext4/extents.c:		if (!timespec_equal(&inode->i_ctime, &now))
fs/ext4/extents.c:			inode->i_ctime = now;
fs/ext4/extents.c:	unsigned int credits, blkbits = inode->i_blkbits;
fs/ext4/extents.c:	mutex_lock(&inode->i_mutex);
fs/ext4/extents.c:		mutex_unlock(&inode->i_mutex);
fs/ext4/extents.c:				    inode->i_ino, map.m_lblk, max_blocks);
fs/ext4/extents.c:			ext4_should_retry_alloc(inode->i_sb, &retries)) {
fs/ext4/extents.c:	mutex_unlock(&inode->i_mutex);
fs/ext4/extents.c:	unsigned int credits, blkbits = inode->i_blkbits;
fs/ext4/extents.c:			ext4_msg(inode->i_sb, KERN_ERR,
fs/ext4/extents.c:				 __func__, __LINE__, inode->i_ino, map.m_lblk,
fs/ext4/extents.c:	int blockbits = inode->i_sb->s_blocksize_bits;
fs/ext4/extents.c:		length = EXT4_SB(inode->i_sb)->s_inode_size - offset;
fs/ext4/extents.c:		length = inode->i_sb->s_blocksize;
fs/ext4/extents.c:	struct super_block *sb = inode->i_sb;
fs/ext4/extents.c:	struct address_space *mapping = inode->i_mapping;
fs/ext4/extents.c:	mutex_lock(&inode->i_mutex);
fs/ext4/extents.c:	if (offset >= inode->i_size)
fs/ext4/extents.c:	if (offset + length > inode->i_size) {
fs/ext4/extents.c:		length = inode->i_size +
fs/ext4/extents.c:		   PAGE_CACHE_SIZE - (inode->i_size & (PAGE_CACHE_SIZE - 1)) -
fs/ext4/extents.c:	if (inode->i_size >> PAGE_CACHE_SHIFT == last_page &&
fs/ext4/extents.c:	   inode->i_size % PAGE_CACHE_SIZE != 0) {
fs/ext4/extents.c:			(inode->i_size & (PAGE_CACHE_SIZE - 1));
fs/ext4/extents.c:			  mapping, inode->i_size, page_len, 0);
fs/ext4/extents.c:	inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
fs/ext4/extents.c:	mutex_unlock(&inode->i_mutex);
fs/ext4/extents.c:		start_blk = start >> inode->i_sb->s_blocksize_bits;
fs/ext4/extents.c:		last_blk = (start + len - 1) >> inode->i_sb->s_blocksize_bits;
fs/ext4/ext4.h: * inode-size = GOOD_OLD_INODE_SIZE + i_extra_isize
fs/ext4/ext4.h:				       raw_inode->xtime ## _extra);	       \
fs/ext4/ext4.h:				       raw_inode->xtime ## _extra);	       \
fs/ext4/ext4.h:	return (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?
fs/ext4/ext4.h:		current_fs_time(inode->i_sb) : CURRENT_TIME_SEC;
fs/ext4/ext4.h:	return inode->i_private;
fs/ext4/ext4.h:	inode->i_private = io;
fs/ext4/ext4.h:	if (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,
fs/ext4/ext4.h:	if (S_ISREG(le16_to_cpu(raw_inode->i_mode)))
fs/ext4/ext4.h:		return ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |
fs/ext4/ext4.h:			le32_to_cpu(raw_inode->i_size_lo);
fs/ext4/ext4.h:		return (loff_t) le32_to_cpu(raw_inode->i_size_lo);
fs/ext4/ext4.h:	raw_inode->i_size_lo = cpu_to_le32(i_size);
fs/ext4/ext4.h:	raw_inode->i_size_high = cpu_to_le32(i_size >> 32);
fs/ext4/ext4_extents.h: * Each block (leaves and indexes), even inode-stored has header.
fs/ext4/extents_status.c: *	Delayed extent tree is protected inode->i_es_lock.
fs/ext4/extents_status.c:	printk(KERN_DEBUG "status extents for inode %lu:", inode->i_ino);
fs/ext4/extents_status.c: * Caller holds inode->i_es_lock.
fs/ext4/extents_status.c:		 offset, len, inode->i_ino);
fs/ext4/extents_status.c: * Caller holds inode->i_es_lock.
fs/ext4/extents_status.c:		 offset, len, inode->i_ino);
fs/ext4/resize.c:	struct super_block *sb = inode->i_sb;
fs/ext4/resize.c:	inode->i_blocks -= (gdbackups + 1) * sb->s_blocksize >> 9;
fs/ext4/resize.c:	struct super_block *sb = inode->i_sb;
fs/ext4/resize.c:	inode->i_blocks += reserved_gdb * sb->s_blocksize >> 9;
fs/ext4/resize.c:	 * inode-by-inode within a group, so enabling these
fs/ext4/resize.c:		if (inode->i_blocks != 1 << (inode->i_blkbits - 9))
fs/ext4/resize.c:		inode->i_blocks = 0;
fs/ext4/dir.c:	struct super_block *sb = inode->i_sb;
fs/ext4/dir.c:	if (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,
fs/ext4/dir.c:	     ((inode->i_size >> sb->s_blocksize_bits) == 1)))
fs/ext4/dir.c:	struct super_block *sb = inode->i_sb;
fs/ext4/dir.c:	while (!error && !stored && filp->f_pos < inode->i_size) {
fs/ext4/dir.c:					(PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/ext4/dir.c:					sb->s_bdev->bd_inode->i_mapping,
fs/ext4/dir.c:			if (filp->f_pos > inode->i_blocks << 9)
fs/ext4/dir.c:		if (filp->f_version != inode->i_version) {
fs/ext4/dir.c:			filp->f_version = inode->i_version;
fs/ext4/dir.c:		while (!error && filp->f_pos < inode->i_size
fs/ext4/dir.c:	sb = inode->i_sb;
fs/ext4/dir.c:			 inode->i_ino, current->comm);
fs/ext4/dir.c:		    (filp->f_version != inode->i_version)) {
fs/ext4/dir.c:			filp->f_version = inode->i_version;
fs/ext4/fsync.c:		ret = sync_mapping_buffers(inode->i_mapping);
fs/ext4/fsync.c:	ret = sync_mapping_buffers(inode->i_mapping);
fs/ext4/fsync.c:	if (!(inode->i_state & I_DIRTY))
fs/ext4/fsync.c:	if (datasync && !(inode->i_state & I_DIRTY_DATASYNC))
fs/ext4/fsync.c:	journal_t *journal = EXT4_SB(inode->i_sb)->s_journal;
fs/ext4/fsync.c:	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/ext4/fsync.c:	mutex_lock(&inode->i_mutex);
fs/ext4/fsync.c:	if (inode->i_sb->s_flags & MS_RDONLY)
fs/ext4/fsync.c:		if (!ret && !hlist_empty(&inode->i_dentry))
fs/ext4/fsync.c:		ret = ext4_force_commit(inode->i_sb);
fs/ext4/fsync.c:		err = blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);
fs/ext4/fsync.c:	mutex_unlock(&inode->i_mutex);
fs/ext4/ext4_jbd2.c:		  bh, is_metadata, inode->i_mode,
fs/ext4/ext4_jbd2.c:		  test_opt(inode->i_sb, DATA_FLAGS));
fs/ext4/ext4_jbd2.c:	if (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA ||
fs/ext4/ext4_jbd2.c:		__ext4_abort(inode->i_sb, where, line,
fs/ext4/ext4_jbd2.c:				es = EXT4_SB(inode->i_sb)->s_es;
fs/ext4/migrate.c:	unsigned long max_entries = inode->i_sb->s_blocksize >> 2;
fs/ext4/migrate.c:	bh = sb_bread(inode->i_sb, pblock);
fs/ext4/migrate.c:	unsigned long max_entries = inode->i_sb->s_blocksize >> 2;
fs/ext4/migrate.c:	bh = sb_bread(inode->i_sb, pblock);
fs/ext4/migrate.c:	unsigned long max_entries = inode->i_sb->s_blocksize >> 2;
fs/ext4/migrate.c:	bh = sb_bread(inode->i_sb, pblock);
fs/ext4/migrate.c:	needed = 3 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);
fs/ext4/migrate.c:	unsigned long max_entries = inode->i_sb->s_blocksize >> 2;
fs/ext4/migrate.c:	bh = sb_bread(inode->i_sb, le32_to_cpu(i_data));
fs/ext4/migrate.c:	unsigned long max_entries = inode->i_sb->s_blocksize >> 2;
fs/ext4/migrate.c:	bh = sb_bread(inode->i_sb, le32_to_cpu(i_data));
fs/ext4/migrate.c:	spin_lock(&inode->i_lock);
fs/ext4/migrate.c:	inode->i_blocks += tmp_inode->i_blocks;
fs/ext4/migrate.c:	spin_unlock(&inode->i_lock);
fs/ext4/migrate.c:	bh = sb_bread(inode->i_sb, block);
fs/ext4/migrate.c:	if (!EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,
fs/ext4/migrate.c:	if (S_ISLNK(inode->i_mode) && inode->i_blocks == 0)
fs/ext4/migrate.c:					EXT4_DATA_TRANS_BLOCKS(inode->i_sb) +
fs/ext4/migrate.c:					EXT4_MAXQUOTAS_INIT_BLOCKS(inode->i_sb)
fs/ext4/migrate.c:	goal = (((inode->i_ino - 1) / EXT4_INODES_PER_GROUP(inode->i_sb)) *
fs/ext4/migrate.c:		EXT4_INODES_PER_GROUP(inode->i_sb)) + 1;
fs/ext4/migrate.c:	tmp_inode = ext4_new_inode(handle, inode->i_sb->s_root->d_inode,
fs/ext4/migrate.c:	max_entries = inode->i_sb->s_blocksize >> 2;
fs/ext4/migrate.c:	tmp_inode->i_blocks = 0;
fs/ext4/balloc.c:				EXT4_C2B(EXT4_SB(inode->i_sb), ar.len));
fs/ext4/balloc.c:	int flex_size = ext4_flex_bg_size(EXT4_SB(inode->i_sb));
fs/ext4/balloc.c:		if (S_ISREG(inode->i_mode))
fs/ext4/balloc.c:	bg_start = ext4_group_first_block_no(inode->i_sb, block_group);
fs/ext4/balloc.c:	last_block = ext4_blocks_count(EXT4_SB(inode->i_sb)->s_es) - 1;
fs/ext4/balloc.c:	if (test_opt(inode->i_sb, DELALLOC))
fs/ext4/balloc.c:	if (bg_start + EXT4_BLOCKS_PER_GROUP(inode->i_sb) <= last_block)
fs/ext4/balloc.c:			(EXT4_BLOCKS_PER_GROUP(inode->i_sb) / 16);
fs/ext4/page-io.c:		   io, inode->i_ino, io->list.next, io->list.prev);
fs/ext4/page-io.c:		ext4_msg(inode->i_sb, KERN_EMERG,
fs/ext4/page-io.c:			 inode->i_ino, offset, size, ret);
fs/ext4/page-io.c:			   inode->i_ino);
fs/ext4/page-io.c:	ext4_debug("Dump inode %lu completed_io list\n", inode->i_ino);
fs/ext4/page-io.c:			    io, inode->i_ino, io0, io1);
fs/ext4/page-io.c:	wq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;
fs/ext4/page-io.c:	WARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex) &&
fs/ext4/page-io.c:		     !(inode->i_state & I_FREEING));
fs/ext4/page-io.c:		ext4_warning(inode->i_sb, "I/O error writing to inode %lu "
fs/ext4/page-io.c:			     inode->i_ino,
fs/ext4/page-io.c:			     bi_sector >> (inode->i_blkbits - 9));
fs/ext4/page-io.c:	blocksize = 1 << inode->i_blkbits;
fs/ext4/file.c:			(atomic_read(&inode->i_writecount) == 1) &&
fs/ext4/file.c:	struct super_block *sb = inode->i_sb;
fs/ext4/file.c:	if (pos >= inode->i_size)
fs/ext4/file.c:	mutex_lock(&inode->i_mutex);
fs/ext4/file.c:		unsigned int blkbits = inode->i_blkbits;
fs/ext4/file.c:	mutex_unlock(&inode->i_mutex);
fs/ext4/file.c:		struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/file.c:	struct super_block *sb = inode->i_sb;
fs/ext4/file.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/file.c:		spin_lock(&inode->i_lock);
fs/ext4/file.c:				spin_unlock(&inode->i_lock);
fs/ext4/file.c:		spin_unlock(&inode->i_lock);
fs/ext4/file.c:	blkbits = inode->i_sb->s_blocksize_bits;
fs/ext4/file.c:		nr_pages = pagevec_lookup(&pvec, inode->i_mapping, index,
fs/ext4/file.c:			if (unlikely(page->mapping != inode->i_mapping)) {
fs/ext4/file.c:	mutex_lock(&inode->i_mutex);
fs/ext4/file.c:		mutex_unlock(&inode->i_mutex);
fs/ext4/file.c:	blkbits = inode->i_sb->s_blocksize_bits;
fs/ext4/file.c:	mutex_unlock(&inode->i_mutex);
fs/ext4/file.c:	mutex_lock(&inode->i_mutex);
fs/ext4/file.c:		mutex_unlock(&inode->i_mutex);
fs/ext4/file.c:	blkbits = inode->i_sb->s_blocksize_bits;
fs/ext4/file.c:	mutex_unlock(&inode->i_mutex);
fs/ext4/file.c:		maxbytes = EXT4_SB(inode->i_sb)->s_bitmap_maxbytes;
fs/ext4/file.c:		maxbytes = inode->i_sb->s_maxbytes;
fs/ext4/ioctl.c:	struct super_block *sb = inode->i_sb;
fs/ext4/ioctl.c:		flags = ext4_mask_flags(inode->i_mode, flags);
fs/ext4/ioctl.c:		mutex_lock(&inode->i_mutex);
fs/ext4/ioctl.c:		inode->i_ctime = ext4_current_time(inode);
fs/ext4/ioctl.c:		mutex_unlock(&inode->i_mutex);
fs/ext4/ioctl.c:		return put_user(inode->i_generation, (int __user *) arg);
fs/ext4/ioctl.c:		if (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/ioctl.c:		mutex_lock(&inode->i_mutex);
fs/ext4/ioctl.c:			inode->i_ctime = ext4_current_time(inode);
fs/ext4/ioctl.c:			inode->i_generation = generation;
fs/ext4/ioctl.c:		mutex_unlock(&inode->i_mutex);
fs/ext4/ioctl.c:		mutex_lock(&(inode->i_mutex));
fs/ext4/ioctl.c:		mutex_unlock(&(inode->i_mutex));
fs/ext4/ioctl.c:		struct super_block *sb = inode->i_sb;
fs/ext4/inline.c:	min_offs = EXT4_SB(inode->i_sb)->s_inode_size -
fs/ext4/inline.c:				 inode->i_ino);
fs/ext4/inline.c:	memcpy(buffer, (void *)(raw_inode->i_block), cp_len);
fs/ext4/inline.c:		memcpy((void *)raw_inode->i_block + pos, buffer, cp_len);
fs/ext4/inline.c:	if (EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,
fs/ext4/inline.c:		if (S_ISDIR(inode->i_mode) ||
fs/ext4/inline.c:		    S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {
fs/ext4/inline.c:		ext4_warning(inode->i_sb, "inode %lu doesn't have inline data.",
fs/ext4/inline.c:			     inode->i_ino);
fs/ext4/inline.c:		if (inode->i_nlink)
fs/ext4/inline.c:	if (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))
fs/ext4/inline.c:		ext4_std_error(inode->i_sb, ret);
fs/ext4/inline.c:		ext4_std_error(inode->i_sb, ret);
fs/ext4/inline.c:	if (pos+copied > inode->i_size) {
fs/ext4/inline.c:		inode->i_sb->s_blocksize, csum_size,
fs/ext4/inline.c:	if (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/inline.c:	inode->i_size = inode->i_sb->s_blocksize;
fs/ext4/inline.c:	i_size_write(inode, inode->i_sb->s_blocksize);
fs/ext4/inline.c:	EXT4_I(inode)->i_disksize = inode->i_sb->s_blocksize;
fs/ext4/inline.c:			inode->i_sb->s_blocksize - csum_size);
fs/ext4/inline.c:				     inode->i_sb->s_blocksize);
fs/ext4/inline.c:		initialize_dirent_tail(t, inode->i_sb->s_blocksize);
fs/ext4/inline.c:	data_bh = sb_getblk(inode->i_sb, map.m_pblk);
fs/ext4/inline.c:	memset(data_bh->b_data, 0, inode->i_sb->s_blocksize);
fs/ext4/inline.c:	if (!S_ISDIR(inode->i_mode)) {
fs/ext4/inline.c:	sb = inode->i_sb;
fs/ext4/inline.c:	while (!error && !stored && filp->f_pos < inode->i_size) {
fs/ext4/inline.c:		if (filp->f_version != inode->i_version) {
fs/ext4/inline.c:			     i < inode->i_size && i < offset;) {
fs/ext4/inline.c:			filp->f_version = inode->i_version;
fs/ext4/inline.c:		while (!error && filp->f_pos < inode->i_size) {
fs/ext4/inline.c:				error = filldir(dirent, ".", 1, 0, inode->i_ino,
fs/ext4/inline.c:	inode->i_size = EXT4_I(inode)->i_disksize = inline_size;
fs/ext4/inline.c:	physical = iloc.bh->b_blocknr << inode->i_sb->s_blocksize_bits;
fs/ext4/inline.c:	i_size = inode->i_size;
fs/ext4/inline.c:	if (inode->i_nlink)
fs/ext4/inline.c:	inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
fs/ext4/block_validity.c:	struct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;
fs/ext4/block_validity.c:		    unlikely(!ext4_data_block_valid(EXT4_SB(inode->i_sb),
fs/ext4/acl.c: * inode->i_mutex: don't care
fs/ext4/acl.c:	if (!test_opt(inode->i_sb, POSIX_ACL))
fs/ext4/acl.c: * inode->i_mutex: down unless called from ext4_new_inode
fs/ext4/acl.c:	if (S_ISLNK(inode->i_mode))
fs/ext4/acl.c:			error = posix_acl_equiv_mode(acl, &inode->i_mode);
fs/ext4/acl.c:				inode->i_ctime = ext4_current_time(inode);
fs/ext4/acl.c:		if (!S_ISDIR(inode->i_mode))
fs/ext4/acl.c: * inode->i_mutex: up (access to inode is still exclusive)
fs/ext4/acl.c:	if (!S_ISLNK(inode->i_mode)) {
fs/ext4/acl.c:			inode->i_mode &= ~current_umask();
fs/ext4/acl.c:	if (test_opt(inode->i_sb, POSIX_ACL) && acl) {
fs/ext4/acl.c:		if (S_ISDIR(inode->i_mode)) {
fs/ext4/acl.c:		error = posix_acl_create(&acl, GFP_NOFS, &inode->i_mode);
fs/ext4/acl.c: * inode->i_mode field must be updated to the desired value by the caller
fs/ext4/acl.c: * inode->i_mutex: down
fs/ext4/acl.c:	if (S_ISLNK(inode->i_mode))
fs/ext4/acl.c:	if (!test_opt(inode->i_sb, POSIX_ACL))
fs/ext4/acl.c:	error = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
fs/ext4/acl.c:			EXT4_DATA_TRANS_BLOCKS(inode->i_sb));
fs/ext4/acl.c:		ext4_std_error(inode->i_sb, error);
fs/ext4/acl.c:	    ext4_should_retry_alloc(inode->i_sb, &retries))
fs/ext4/acl.c:	if (!test_opt(inode->i_sb, POSIX_ACL))
fs/ext4/acl.c:	handle = ext4_journal_start(inode, EXT4_DATA_TRANS_BLOCKS(inode->i_sb));
fs/ext4/acl.c:	if (error == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))
fs/ext4/move_extent.c:				sb_bread(inode->i_sb, path[ppos].p_block);
fs/ext4/move_extent.c:				path[cur_ppos+1].p_bh = sb_bread(inode->i_sb,
fs/ext4/move_extent.c:	blocksize = 1 << inode->i_blkbits;
fs/ext4/move_extent.c:	block = (sector_t)page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/ext4/move_extent.c:	unsigned long blocksize = orig_inode->i_sb->s_blocksize;
fs/ext4/move_extent.c:	int from = data_offset_in_page << orig_inode->i_blkbits;
fs/ext4/move_extent.c:	int blocks_per_page = PAGE_CACHE_SIZE >> orig_inode->i_blkbits;
fs/ext4/move_extent.c:	offs = (long long)orig_blk_offset << orig_inode->i_blkbits;
fs/ext4/move_extent.c:	    ((orig_inode->i_size - 1) >> orig_inode->i_blkbits)) {
fs/ext4/move_extent.c:		tmp_data_size = orig_inode->i_size & (blocksize - 1);
fs/ext4/move_extent.c:			((block_len_in_page - 1) << orig_inode->i_blkbits);
fs/ext4/move_extent.c:		data_size = block_len_in_page << orig_inode->i_blkbits;
fs/ext4/move_extent.c:				block_len_in_page << orig_inode->i_blkbits;
fs/ext4/move_extent.c:	if (*err == -EBUSY && ext4_should_retry_alloc(orig_inode->i_sb,
fs/ext4/move_extent.c:	unsigned int blkbits = orig_inode->i_blkbits;
fs/ext4/move_extent.c:	if (donor_inode->i_mode & (S_ISUID|S_ISGID)) {
fs/ext4/move_extent.c:			   orig_inode->i_ino, donor_inode->i_ino);
fs/ext4/move_extent.c:			orig_inode->i_ino, donor_inode->i_ino);
fs/ext4/move_extent.c:			"based file [ino:orig %lu]\n", orig_inode->i_ino);
fs/ext4/move_extent.c:			"based file [ino:donor %lu]\n", donor_inode->i_ino);
fs/ext4/move_extent.c:	if ((!orig_inode->i_size) || (!donor_inode->i_size)) {
fs/ext4/move_extent.c:			orig_inode->i_ino, donor_inode->i_ino);
fs/ext4/move_extent.c:			orig_inode->i_ino, donor_inode->i_ino);
fs/ext4/move_extent.c:	if (orig_inode->i_size > donor_inode->i_size) {
fs/ext4/move_extent.c:		donor_blocks = (donor_inode->i_size + blocksize - 1) >> blkbits;
fs/ext4/move_extent.c:			orig_inode->i_ino, donor_inode->i_ino);
fs/ext4/move_extent.c:				orig_inode->i_ino, donor_inode->i_ino);
fs/ext4/move_extent.c:		orig_blocks = (orig_inode->i_size + blocksize - 1) >> blkbits;
fs/ext4/move_extent.c:				orig_inode->i_ino, donor_inode->i_ino);
fs/ext4/move_extent.c:				orig_inode->i_ino, donor_inode->i_ino);
fs/ext4/move_extent.c:			"[ino:orig %lu, donor %lu]\n", orig_inode->i_ino,
fs/ext4/move_extent.c:			donor_inode->i_ino);
fs/ext4/move_extent.c:	int blocks_per_page = PAGE_CACHE_SIZE >> orig_inode->i_blkbits;
fs/ext4/move_extent.c:	if (orig_inode->i_sb != donor_inode->i_sb) {
fs/ext4/move_extent.c:			orig_inode->i_ino, donor_inode->i_ino);
fs/ext4/move_extent.c:			orig_inode->i_ino, donor_inode->i_ino);
fs/ext4/move_extent.c:	if (!S_ISREG(orig_inode->i_mode) || !S_ISREG(donor_inode->i_mode)) {
fs/ext4/move_extent.c:			orig_inode->i_ino, donor_inode->i_ino);
fs/ext4/move_extent.c:	file_end = (i_size_read(orig_inode) - 1) >> orig_inode->i_blkbits;
fs/ext4/move_extent.c:				(PAGE_CACHE_SHIFT - orig_inode->i_blkbits);
fs/ext4/move_extent.c:				(PAGE_CACHE_SHIFT - orig_inode->i_blkbits);
fs/ext4/mballoc.c:					      inode ? inode->i_ino : 0,
fs/ext4/mballoc.c:	sb = inode->i_sb;
fs/ext4/mballoc.c:	blocksize = 1 << inode->i_blkbits;
fs/ext4/mballoc.c:	page = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);
fs/ext4/mballoc.c:	BUG_ON(page->mapping != inode->i_mapping);
fs/ext4/mballoc.c:	page = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);
fs/ext4/mballoc.c:	BUG_ON(page->mapping != inode->i_mapping);
fs/ext4/mballoc.c:	page = find_get_page(inode->i_mapping, pnum);
fs/ext4/mballoc.c:		page = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);
fs/ext4/mballoc.c:			BUG_ON(page->mapping != inode->i_mapping);
fs/ext4/mballoc.c:	page = find_get_page(inode->i_mapping, pnum);
fs/ext4/mballoc.c:		page = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);
fs/ext4/mballoc.c:			BUG_ON(page->mapping != inode->i_mapping);
fs/ext4/mballoc.c:					      inode ? inode->i_ino : 0,
fs/ext4/mballoc.c:	BUG_ON(!S_ISREG(ac->ac_inode->i_mode));
fs/ext4/mballoc.c:	BUG_ON(!S_ISREG(ac->ac_inode->i_mode));
fs/ext4/mballoc.c:	struct super_block *sb = inode->i_sb;
fs/ext4/mballoc.c:	if (!S_ISREG(inode->i_mode)) {
fs/ext4/mballoc.c:	mb_debug(1, "discard preallocation for inode %lu\n", inode->i_ino);
fs/ext4/mballoc.c:	    (atomic_read(&ac->ac_inode->i_writecount) == 0)) {
fs/ext4/mballoc.c:	struct super_block *sb = ar->inode->i_sb;
fs/ext4/mballoc.c:			atomic_read(&ar->inode->i_writecount) ? "" : "non-");
fs/ext4/mballoc.c:	sb = ar->inode->i_sb;
fs/ext4/mballoc.c:	struct super_block *sb = inode->i_sb;
fs/ext4/mballoc.c:				tbh = sb_find_get_block(inode->i_sb,
fs/ext4/namei.c:	if (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&
fs/ext4/namei.c:		     ((inode->i_size >> 10) >=
fs/ext4/namei.c:		      EXT4_SB(inode->i_sb)->s_max_dir_size_kb))) {
fs/ext4/namei.c:	*block = inode->i_size >> inode->i_sb->s_blocksize_bits;
fs/ext4/namei.c:		inode->i_size += inode->i_sb->s_blocksize;
fs/ext4/namei.c:		EXT4_I(inode)->i_disksize = inode->i_size;
fs/ext4/namei.c:		ext4_error(inode->i_sb,
fs/ext4/namei.c:			   inode->i_ino);
fs/ext4/namei.c:		(EXT4_BLOCK_SIZE(inode->i_sb) -
fs/ext4/namei.c:	t = EXT4_DIRENT_TAIL(de, EXT4_BLOCK_SIZE(inode->i_sb));
fs/ext4/namei.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/namei.c:	ext4_warning(inode->i_sb, "no space in directory inode %lu leaf for "
fs/ext4/namei.c:		     "checksum.  Please run e2fsck -D.", inode->i_ino);
fs/ext4/namei.c:	if (!EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/namei.c:	if (!EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/namei.c:	if (le16_to_cpu(dirent->rec_len) == EXT4_BLOCK_SIZE(inode->i_sb))
fs/ext4/namei.c:		    EXT4_BLOCK_SIZE(inode->i_sb) - 12)
fs/ext4/namei.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/namei.c:	if (!EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/namei.c:	    EXT4_BLOCK_SIZE(inode->i_sb) - sizeof(struct dx_tail)) {
fs/ext4/namei.c:	if (!EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/namei.c:	    EXT4_BLOCK_SIZE(inode->i_sb) - sizeof(struct dx_tail)) {
fs/ext4/namei.c:	if (!ext4_valid_inum(child->d_inode->i_sb, ino)) {
fs/ext4/namei.c:	return d_obtain_alias(ext4_iget(child->d_inode->i_sb, ino));
fs/ext4/namei.c:	de->inode = cpu_to_le32(inode->i_ino);
fs/ext4/namei.c:	ext4_set_de_type(inode->i_sb, de, inode->i_mode);
fs/ext4/namei.c:	if (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/namei.c:	if (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/namei.c:	if (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/namei.c:				ext4_error(inode->i_sb,
fs/ext4/namei.c:					   inode->i_ino);
fs/ext4/namei.c:			ext4_std_error(inode->i_sb, err);
fs/ext4/namei.c:	if (is_dx(inode) && inode->i_nlink > 1) {
fs/ext4/namei.c:		if (inode->i_nlink >= EXT4_LINK_MAX || inode->i_nlink == 2) {
fs/ext4/namei.c:			EXT4_SET_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/namei.c:	if (!S_ISDIR(inode->i_mode) || inode->i_nlink > 2)
fs/ext4/namei.c:		inode->i_op = &ext4_file_inode_operations;
fs/ext4/namei.c:		inode->i_fop = &ext4_file_operations;
fs/ext4/namei.c:		init_special_inode(inode, inode->i_mode, rdev);
fs/ext4/namei.c:		inode->i_op = &ext4_special_inode_operations;
fs/ext4/namei.c:	de->inode = cpu_to_le32(inode->i_ino);
fs/ext4/namei.c:	ext4_set_de_type(inode->i_sb, de, S_IFDIR);
fs/ext4/namei.c:	ext4_set_de_type(inode->i_sb, de, S_IFDIR);
fs/ext4/namei.c:	inode->i_size = EXT4_I(inode)->i_disksize = blocksize;
fs/ext4/namei.c:			ext4_error(inode->i_sb,
fs/ext4/namei.c:				   inode->i_ino);
fs/ext4/namei.c:	inode->i_op = &ext4_dir_inode_operations;
fs/ext4/namei.c:	inode->i_fop = &ext4_dir_operations;
fs/ext4/namei.c:	sb = inode->i_sb;
fs/ext4/namei.c:	if (inode->i_size < EXT4_DIR_REC_LEN(1) + EXT4_DIR_REC_LEN(2) ||
fs/ext4/namei.c:			ext4_warning(inode->i_sb,
fs/ext4/namei.c:				     inode->i_ino);
fs/ext4/namei.c:	if (le32_to_cpu(de->inode) != inode->i_ino ||
fs/ext4/namei.c:		ext4_warning(inode->i_sb,
fs/ext4/namei.c:			     inode->i_ino);
fs/ext4/namei.c:	while (offset < inode->i_size) {
fs/ext4/namei.c:					ext4_warning(inode->i_sb,
fs/ext4/namei.c:						inode->i_ino);
fs/ext4/namei.c:	struct super_block *sb = inode->i_sb;
fs/ext4/namei.c:	J_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
fs/ext4/namei.c:		  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);
fs/ext4/namei.c:	EXT4_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);
fs/ext4/namei.c:	jbd_debug(4, "superblock will point to %lu\n", inode->i_ino);
fs/ext4/namei.c:			inode->i_ino, NEXT_ORPHAN(inode));
fs/ext4/namei.c:	ext4_std_error(inode->i_sb, err);
fs/ext4/namei.c:	if ((!EXT4_SB(inode->i_sb)->s_journal) &&
fs/ext4/namei.c:	    !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS))
fs/ext4/namei.c:	mutex_lock(&EXT4_SB(inode->i_sb)->s_orphan_lock);
fs/ext4/namei.c:	sbi = EXT4_SB(inode->i_sb);
fs/ext4/namei.c:	jbd_debug(4, "remove inode %lu from orphan list\n", inode->i_ino);
fs/ext4/namei.c:		err = ext4_handle_dirty_super(handle, inode->i_sb);
fs/ext4/namei.c:	ext4_std_error(inode->i_sb, err);
fs/ext4/namei.c:	mutex_unlock(&EXT4_SB(inode->i_sb)->s_orphan_lock);
fs/ext4/namei.c:	if (le32_to_cpu(de->inode) != inode->i_ino)
fs/ext4/namei.c:		ext4_warning(inode->i_sb,
fs/ext4/namei.c:			     inode->i_nlink);
fs/ext4/namei.c:	inode->i_version++;
fs/ext4/namei.c:	inode->i_size = 0;
fs/ext4/namei.c:	inode->i_ctime = dir->i_ctime = dir->i_mtime = ext4_current_time(inode);
fs/ext4/namei.c:	if (le32_to_cpu(de->inode) != inode->i_ino)
fs/ext4/namei.c:	if (!inode->i_nlink) {
fs/ext4/namei.c:		ext4_warning(inode->i_sb,
fs/ext4/namei.c:			     inode->i_ino, inode->i_nlink);
fs/ext4/namei.c:	if (!inode->i_nlink)
fs/ext4/namei.c:	inode->i_ctime = ext4_current_time(inode);
fs/ext4/namei.c:		inode->i_op = &ext4_symlink_inode_operations;
fs/ext4/namei.c:		inode->i_op = &ext4_fast_symlink_inode_operations;
fs/ext4/namei.c:		inode->i_size = l-1;
fs/ext4/namei.c:	EXT4_I(inode)->i_disksize = inode->i_size;
fs/ext4/namei.c:	if (inode->i_nlink >= EXT4_LINK_MAX)
fs/ext4/namei.c:	inode->i_ctime = ext4_current_time(inode);
fs/ext4/namei.c:				ext4_error(inode->i_sb,
fs/ext4/namei.c:					   inode->i_ino);
fs/ext4/namei.c:					inode->i_sb->s_blocksize);
fs/ext4/namei.c:	if (!old_bh || le32_to_cpu(old_de->inode) != old_inode->i_ino)
fs/ext4/namei.c:	if (S_ISDIR(old_inode->i_mode)) {
fs/ext4/namei.c:		new_de->inode = cpu_to_le32(old_inode->i_ino);
fs/ext4/namei.c:	old_inode->i_ctime = ext4_current_time(old_inode);
fs/ext4/namei.c:	if (le32_to_cpu(old_de->inode) != old_inode->i_ino ||
fs/ext4/namei.c:		new_inode->i_ctime = ext4_current_time(new_inode);
fs/ext4/namei.c:		if (!new_inode->i_nlink)
fs/ext4/ialloc.c:	struct super_block *sb = inode->i_sb;
fs/ext4/ialloc.c:	if (atomic_read(&inode->i_count) > 1) {
fs/ext4/ialloc.c:			 __func__, __LINE__, inode->i_ino,
fs/ext4/ialloc.c:			 atomic_read(&inode->i_count));
fs/ext4/ialloc.c:	if (inode->i_nlink) {
fs/ext4/ialloc.c:			 __func__, __LINE__, inode->i_ino, inode->i_nlink);
fs/ext4/ialloc.c:	ino = inode->i_ino;
fs/ext4/ialloc.c:	is_directory = S_ISDIR(inode->i_mode);
fs/ext4/ialloc.c:		inode->i_mode = mode;
fs/ext4/ialloc.c:		inode->i_mode = mode;
fs/ext4/ialloc.c:		inode->i_uid = current_fsuid();
fs/ext4/ialloc.c:		inode->i_gid = dir->i_gid;
fs/ext4/ialloc.c:	inode->i_ino = ino + group * EXT4_INODES_PER_GROUP(sb);
fs/ext4/ialloc.c:	inode->i_blocks = 0;
fs/ext4/ialloc.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = ei->i_crtime =
fs/ext4/ialloc.c:	inode->i_generation = sbi->s_next_generation++;
fs/ext4/ialloc.c:		struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/ialloc.c:		__le32 inum = cpu_to_le32(inode->i_ino);
fs/ext4/ialloc.c:		__le32 gen = cpu_to_le32(inode->i_generation);
fs/ext4/ialloc.c:	ext4_debug("allocating inode %lu\n", inode->i_ino);
fs/ext4/ialloc.c:	inode->i_flags |= S_NOQUOTA;
fs/ext4/ialloc.c:	if (inode->i_nlink && !ext4_can_truncate(inode))
fs/ext4/ialloc.c:		printk(KERN_NOTICE "i_nlink=%u\n", inode->i_nlink);
fs/ext4/ialloc.c:		if (inode->i_nlink == 0)
fs/ext4/ialloc.c:			inode->i_blocks = 0;
fs/ext4/indirect.c: *	inode->i_sb).
fs/ext4/indirect.c:	int ptrs = EXT4_ADDR_PER_BLOCK(inode->i_sb);
fs/ext4/indirect.c:	int ptrs_bits = EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb);
fs/ext4/indirect.c:		ext4_warning(inode->i_sb, "block %lu > max in inode %lu",
fs/ext4/indirect.c:			     indirect_blocks + double_blocks, inode->i_ino);
fs/ext4/indirect.c:	struct super_block *sb = inode->i_sb;
fs/ext4/indirect.c:	if (S_ISREG(inode->i_mode))
fs/ext4/indirect.c:	int blocksize = inode->i_sb->s_blocksize;
fs/ext4/indirect.c:		bh = sb_getblk(inode->i_sb, new_blocks[n-1]);
fs/ext4/indirect.c:	if (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/indirect.c:		if (final_size > inode->i_size) {
fs/ext4/indirect.c:			ei->i_disksize = inode->i_size;
fs/ext4/indirect.c:			mutex_lock(&inode->i_mutex);
fs/ext4/indirect.c:			mutex_unlock(&inode->i_mutex);
fs/ext4/indirect.c:		atomic_inc(&inode->i_dio_count);
fs/ext4/indirect.c:				 inode->i_sb->s_bdev, iov,
fs/ext4/indirect.c:	if (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))
fs/ext4/indirect.c:			if (inode->i_nlink)
fs/ext4/indirect.c:		if (inode->i_nlink)
fs/ext4/indirect.c:			if (end > inode->i_size) {
fs/ext4/indirect.c:	sector_t dind_mask = ~((sector_t)EXT4_ADDR_PER_BLOCK(inode->i_sb) - 1);
fs/ext4/indirect.c:	return (blk_bits / EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb)) + 1;
fs/ext4/indirect.c:		 * N/EXT4_ADDR_PER_BLOCK(inode->i_sb) + 1 indirect blocks,
fs/ext4/indirect.c:				    EXT4_ADDR_PER_BLOCK(inode->i_sb)) + 4;
fs/ext4/indirect.c:	ext4_std_error(inode->i_sb, PTR_ERR(result));
fs/ext4/indirect.c:	if (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))
fs/ext4/indirect.c:	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), block_to_free,
fs/ext4/indirect.c:	ext4_std_error(inode->i_sb, err);
fs/ext4/indirect.c: * little-endian 32-bit) and updating @inode->i_blocks appropriately.
fs/ext4/indirect.c: *	stored as little-endian 32-bit) and updating @inode->i_blocks
fs/ext4/indirect.c:		int addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);
fs/ext4/indirect.c:			if (!ext4_data_block_valid(EXT4_SB(inode->i_sb),
fs/ext4/indirect.c:			bh = sb_bread(inode->i_sb, nr);
fs/ext4/indirect.c:	int addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);
fs/ext4/indirect.c:	struct address_space *mapping = inode->i_mapping;
fs/ext4/indirect.c:	unsigned blocksize = inode->i_sb->s_blocksize;
fs/ext4/indirect.c:	last_block = (inode->i_size + blocksize-1)
fs/ext4/indirect.c:					>> EXT4_BLOCK_SIZE_BITS(inode->i_sb);
fs/ext4/indirect.c:	max_block = (EXT4_SB(inode->i_sb)->s_bitmap_maxbytes + blocksize-1)
fs/ext4/indirect.c:					>> EXT4_BLOCK_SIZE_BITS(inode->i_sb);
fs/ext4/indirect.c:	if (inode->i_size % PAGE_CACHE_SIZE != 0) {
fs/ext4/indirect.c:			(inode->i_size & (PAGE_CACHE_SIZE - 1));
fs/ext4/indirect.c:			mapping, inode->i_size, page_len, 0);
fs/ext4/indirect.c:	ei->i_disksize = inode->i_size;
fs/ext4/indirect.c:	inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
fs/ext4/indirect.c:	if (inode->i_nlink)
fs/ext4/xattr.c:			inode->i_sb->s_id, inode->i_ino); \
fs/ext4/xattr.c:	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
fs/ext4/xattr.c:			   EXT4_BLOCK_SIZE(inode->i_sb));
fs/ext4/xattr.c:	if (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/xattr.c:	if (!EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,
fs/ext4/xattr.c: * dentry->d_inode->i_mutex: don't care
fs/ext4/xattr.c:	bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
fs/ext4/xattr.c:	end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;
fs/ext4/xattr.c:	bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
fs/ext4/xattr.c:	end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;
fs/ext4/xattr.c:		dquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));
fs/ext4/xattr.c:	ext4_std_error(inode->i_sb, error);
fs/ext4/xattr.c:	struct super_block *sb = inode->i_sb;
fs/ext4/xattr.c:	struct super_block *sb = inode->i_sb;
fs/ext4/xattr.c:	is->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;
fs/ext4/xattr.c:		memset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);
fs/ext4/xattr.c:		ext4_xattr_update_super_block(handle, inode->i_sb);
fs/ext4/xattr.c:		inode->i_ctime = ext4_current_time(inode);
fs/ext4/xattr.c:	int credits = EXT4_DATA_TRANS_BLOCKS(inode->i_sb);
fs/ext4/xattr.c:		    ext4_should_retry_alloc(inode->i_sb, &retries))
fs/ext4/xattr.c:	int s_min_extra_isize = le16_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_min_extra_isize);
fs/ext4/xattr.c:	end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;
fs/ext4/xattr.c:				inode->i_sb->s_blocksize);
fs/ext4/xattr.c:		bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
fs/ext4/xattr.c:		free = inode->i_sb->s_blocksize;
fs/ext4/xattr.c:			inode->i_sb->s_blocksize);
fs/ext4/xattr.c:	bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
fs/ext4/xattr.c:	ce = mb_cache_entry_find_first(ext4_xattr_cache, inode->i_sb->s_bdev,
fs/ext4/xattr.c:		bh = sb_bread(inode->i_sb, ce->e_block);
fs/ext4/xattr.c:		ce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);
fs/ramfs/inode.c:		inode->i_ino = get_next_ino();
fs/ramfs/inode.c:		inode->i_mapping->a_ops = &ramfs_aops;
fs/ramfs/inode.c:		inode->i_mapping->backing_dev_info = &ramfs_backing_dev_info;
fs/ramfs/inode.c:		mapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);
fs/ramfs/inode.c:		mapping_set_unevictable(inode->i_mapping);
fs/ramfs/inode.c:		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/ramfs/inode.c:			inode->i_op = &ramfs_file_inode_operations;
fs/ramfs/inode.c:			inode->i_fop = &ramfs_file_operations;
fs/ramfs/inode.c:			inode->i_op = &ramfs_dir_inode_operations;
fs/ramfs/inode.c:			inode->i_fop = &simple_dir_operations;
fs/ramfs/inode.c:			inode->i_op = &page_symlink_inode_operations;
fs/ramfs/file-nommu.c:	pages = alloc_pages(mapping_gfp_mask(inode->i_mapping), order);
fs/ramfs/file-nommu.c:		ret = add_to_page_cache_lru(page, inode->i_mapping, loop,
fs/ramfs/file-nommu.c:		loff_t size = inode->i_size;
fs/ramfs/file-nommu.c:	nr = find_get_pages(inode->i_mapping, pgoff, lpages, pages);
fs/jfs/inode.c:	if (!(inode->i_state & I_NEW))
fs/jfs/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/jfs/inode.c:		inode->i_op = &jfs_file_inode_operations;
fs/jfs/inode.c:		inode->i_fop = &jfs_file_operations;
fs/jfs/inode.c:		inode->i_mapping->a_ops = &jfs_aops;
fs/jfs/inode.c:	} else if (S_ISDIR(inode->i_mode)) {
fs/jfs/inode.c:		inode->i_op = &jfs_dir_inode_operations;
fs/jfs/inode.c:		inode->i_fop = &jfs_dir_operations;
fs/jfs/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/jfs/inode.c:		if (inode->i_size >= IDATASIZE) {
fs/jfs/inode.c:			inode->i_op = &page_symlink_inode_operations;
fs/jfs/inode.c:			inode->i_mapping->a_ops = &jfs_aops;
fs/jfs/inode.c:			inode->i_op = &jfs_fast_symlink_inode_operations;
fs/jfs/inode.c:			JFS_IP(inode)->i_inline[inode->i_size] = '\0';
fs/jfs/inode.c:		inode->i_op = &jfs_file_inode_operations;
fs/jfs/inode.c:		init_special_inode(inode, inode->i_mode, inode->i_rdev);
fs/jfs/inode.c:	if (inode->i_nlink == 0 || !test_cflag(COMMIT_Dirty, inode))
fs/jfs/inode.c:		if (!special_file(inode->i_mode) && noisy) {
fs/jfs/inode.c:	tid = txBegin(inode->i_sb, COMMIT_INODE);
fs/jfs/inode.c:	if (inode->i_nlink && test_cflag(COMMIT_Dirty, inode))
fs/jfs/inode.c:		jfs_flush_journal(JFS_SBI(inode->i_sb)->log, wait);
fs/jfs/inode.c:	if (!inode->i_nlink && !is_bad_inode(inode)) {
fs/jfs/inode.c:			truncate_inode_pages(&inode->i_data, 0);
fs/jfs/inode.c:		truncate_inode_pages(&inode->i_data, 0);
fs/jfs/inode.c:		if (!special_file(inode->i_mode) && noisy) {
fs/jfs/inode.c:	if (to > inode->i_size) {
fs/jfs/inode.c:		truncate_pagecache(inode, to, inode->i_size);
fs/jfs/super.c:	return &jfs_inode->vfs_inode;
fs/jfs/super.c:		struct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;
fs/jfs/super.c:	call_rcu(&inode->i_rcu, jfs_i_callback);
fs/jfs/super.c:	truncate_inode_pages(sbi->direct_inode->i_mapping, 0);
fs/jfs/super.c:			*newLVSize = sb->s_bdev->bd_inode->i_size >>
fs/jfs/super.c:		truncate_inode_pages(JFS_SBI(sb)->direct_inode->i_mapping, 0);
fs/jfs/super.c:	inode->i_ino = 0;
fs/jfs/super.c:	inode->i_size = sb->s_bdev->bd_inode->i_size;
fs/jfs/super.c:	inode->i_mapping->a_ops = &jfs_metapage_aops;
fs/jfs/super.c:	mapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);
fs/jfs/super.c:	filemap_write_and_wait(sbi->direct_inode->i_mapping);
fs/jfs/super.c:	truncate_inode_pages(sbi->direct_inode->i_mapping, 0);
fs/jfs/super.c:		tmp_bh.b_size = 1 << inode->i_blkbits;
fs/jfs/super.c:	mutex_lock(&inode->i_mutex);
fs/jfs/super.c:		tmp_bh.b_size = 1 << inode->i_blkbits;
fs/jfs/super.c:		mutex_unlock(&inode->i_mutex);
fs/jfs/super.c:	if (inode->i_size < off+len-towrite)
fs/jfs/super.c:	inode->i_version++;
fs/jfs/super.c:	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/jfs/super.c:	mutex_unlock(&inode->i_mutex);
fs/jfs/jfs_metapage.c:	sector_t file_blocks = (inode->i_size + inode->i_sb->s_blocksize - 1) >>
fs/jfs/jfs_metapage.c:			       inode->i_blkbits;
fs/jfs/jfs_metapage.c:	if (inode->i_ino) {
fs/jfs/jfs_metapage.c:	int blocks_per_mp = JFS_SBI(inode->i_sb)->nbperpage;
fs/jfs/jfs_metapage.c:		     (PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/jfs/jfs_metapage.c:		block_offset = offset >> inode->i_blkbits;
fs/jfs/jfs_metapage.c:				bio_bytes += len << inode->i_blkbits;
fs/jfs/jfs_metapage.c:		xlen = (PAGE_CACHE_SIZE - offset) >> inode->i_blkbits;
fs/jfs/jfs_metapage.c:		len = min(xlen, (int)JFS_SBI(inode->i_sb)->nbperpage);
fs/jfs/jfs_metapage.c:		bio->bi_bdev = inode->i_sb->s_bdev;
fs/jfs/jfs_metapage.c:		bio->bi_sector = pblock << (inode->i_blkbits - 9);
fs/jfs/jfs_metapage.c:		bio_bytes = len << inode->i_blkbits;
fs/jfs/jfs_metapage.c:	int blocks_per_page = PAGE_CACHE_SIZE >> inode->i_blkbits;
fs/jfs/jfs_metapage.c:		     (PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/jfs/jfs_metapage.c:			bio->bi_bdev = inode->i_sb->s_bdev;
fs/jfs/jfs_metapage.c:			bio->bi_sector = pblock << (inode->i_blkbits - 9);
fs/jfs/jfs_metapage.c:			len = xlen << inode->i_blkbits;
fs/jfs/jfs_metapage.c:			offset = block_offset << inode->i_blkbits;
fs/jfs/jfs_metapage.c:		 inode->i_ino, lblock, absolute);
fs/jfs/jfs_metapage.c:	l2bsize = inode->i_blkbits;
fs/jfs/jfs_metapage.c:		mapping = JFS_SBI(inode->i_sb)->direct_inode->i_mapping;
fs/jfs/jfs_metapage.c:		if ((lblock << inode->i_blkbits) >= inode->i_size)
fs/jfs/jfs_metapage.c:		mapping = inode->i_mapping;
fs/jfs/jfs_metapage.c:			jfs_error(inode->i_sb,
fs/jfs/jfs_metapage.c:				jfs_error(inode->i_sb,
fs/jfs/jfs_metapage.c:		JFS_SBI(ip->i_sb)->direct_inode->i_mapping;
fs/jfs/resize.c:	VolumeSize = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;
fs/jfs/resize.c:	sbi->direct_inode->i_size =  sb->s_bdev->bd_inode->i_size;
fs/jfs/jfs_dtree.c:	tid = txBegin(inode->i_sb, 0);
fs/jfs/file.c:	rc = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/jfs/file.c:	mutex_lock(&inode->i_mutex);
fs/jfs/file.c:	if (!(inode->i_state & I_DIRTY) ||
fs/jfs/file.c:	    (datasync && !(inode->i_state & I_DIRTY_DATASYNC))) {
fs/jfs/file.c:		jfs_flush_journal(JFS_SBI(inode->i_sb)->log, 1);
fs/jfs/file.c:		mutex_unlock(&inode->i_mutex);
fs/jfs/file.c:	mutex_unlock(&inode->i_mutex);
fs/jfs/file.c:	if (S_ISREG(inode->i_mode) && file->f_mode & FMODE_WRITE &&
fs/jfs/file.c:	    (inode->i_size == 0)) {
fs/jfs/file.c:			struct jfs_sb_info *jfs_sb = JFS_SBI(inode->i_sb);
fs/jfs/file.c:		struct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;
fs/jfs/file.c:	if ((iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid)) ||
fs/jfs/file.c:	    (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid))) {
fs/jfs/jfs_logmgr.c:		writer(sbi->direct_inode->i_mapping);
fs/jfs/ioctl.c:		flags = jfs_inode->mode2 & JFS_FL_USER_VISIBLE;
fs/jfs/ioctl.c:		if (!S_ISDIR(inode->i_mode))
fs/jfs/ioctl.c:		mutex_lock(&inode->i_mutex);
fs/jfs/ioctl.c:		oldflags = jfs_inode->mode2;
fs/jfs/ioctl.c:				mutex_unlock(&inode->i_mutex);
fs/jfs/ioctl.c:		jfs_inode->mode2 = flags;
fs/jfs/ioctl.c:		mutex_unlock(&inode->i_mutex);
fs/jfs/ioctl.c:		inode->i_ctime = CURRENT_TIME_SEC;
fs/jfs/ioctl.c:		struct super_block *sb = inode->i_sb;
fs/jfs/jfs_incore.h:	if (JFS_SBI(inode->i_sb)->log)
fs/jfs/acl.c:	if (S_ISLNK(inode->i_mode))
fs/jfs/acl.c:			if (!S_ISDIR(inode->i_mode))
fs/jfs/acl.c:	if (S_ISLNK(inode->i_mode))
fs/jfs/acl.c:		if (S_ISDIR(inode->i_mode)) {
fs/jfs/acl.c:		rc = posix_acl_create(&acl, GFP_KERNEL, &inode->i_mode);
fs/jfs/acl.c:		inode->i_mode &= ~current_umask();
fs/jfs/acl.c:			       inode->i_mode;
fs/jfs/acl.c:	if (S_ISLNK(inode->i_mode))
fs/jfs/acl.c:	rc = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
fs/jfs/acl.c:	tid = txBegin(inode->i_sb, 0);
fs/jfs/namei.c:	if (generation && inode->i_generation != generation) {
fs/jfs/namei.c:	return d_obtain_alias(jfs_iget(dentry->d_inode->i_sb, parent_ino));
fs/jfs/jfs_umount.c:	filemap_write_and_wait(sbi->direct_inode->i_mapping);
fs/jfs/jfs_umount.c:	filemap_write_and_wait(sbi->direct_inode->i_mapping);
fs/jfs/xattr.c:	struct super_block *sb = inode->i_sb;
fs/jfs/xattr.c:	inode->i_ctime = CURRENT_TIME;
fs/jfs/xattr.c:			rc = posix_acl_equiv_mode(acl, &inode->i_mode);
fs/jfs/xattr.c:	tid = txBegin(inode->i_sb, 0);
fs/jfs/xattr.c:	tid = txBegin(inode->i_sb, 0);
fs/jfs/jfs_inode.c:	inode->i_flags &= ~(S_IMMUTABLE | S_APPEND |
fs/jfs/jfs_inode.c:		inode->i_flags |= S_IMMUTABLE;
fs/jfs/jfs_inode.c:		inode->i_flags |= S_APPEND;
fs/jfs/jfs_inode.c:		inode->i_flags |= S_NOATIME;
fs/jfs/jfs_inode.c:		inode->i_flags |= S_DIRSYNC;
fs/jfs/jfs_inode.c:		inode->i_flags |= S_SYNC;
fs/jfs/jfs_inode.c:	jfs_inode->saved_uid = inode->i_uid;
fs/jfs/jfs_inode.c:	jfs_inode->saved_gid = inode->i_gid;
fs/jfs/jfs_inode.c:	jfs_inode->mode2 = JFS_IP(parent)->mode2 & JFS_FL_INHERIT;
fs/jfs/jfs_inode.c:		jfs_inode->mode2 |= IDIRECTORY;
fs/jfs/jfs_inode.c:		jfs_inode->mode2 &= ~JFS_DIRSYNC_FL;
fs/jfs/jfs_inode.c:		jfs_inode->mode2 |= INLINEEA | ISPARSE;
fs/jfs/jfs_inode.c:			jfs_inode->mode2 &= ~(JFS_IMMUTABLE_FL|JFS_APPEND_FL);
fs/jfs/jfs_inode.c:	jfs_inode->mode2 |= inode->i_mode;
fs/jfs/jfs_inode.c:	inode->i_blocks = 0;
fs/jfs/jfs_inode.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
fs/jfs/jfs_inode.c:	jfs_inode->otime = inode->i_ctime.tv_sec;
fs/jfs/jfs_inode.c:	inode->i_generation = JFS_SBI(sb)->gengen++;
fs/jfs/jfs_inode.c:	jfs_inode->cflag = 0;
fs/jfs/jfs_inode.c:	memset(&jfs_inode->acl, 0, sizeof(dxd_t));
fs/jfs/jfs_inode.c:	memset(&jfs_inode->ea, 0, sizeof(dxd_t));
fs/jfs/jfs_inode.c:	jfs_inode->next_index = 0;
fs/jfs/jfs_inode.c:	jfs_inode->acltype = 0;
fs/jfs/jfs_inode.c:	jfs_inode->btorder = 0;
fs/jfs/jfs_inode.c:	jfs_inode->btindex = 0;
fs/jfs/jfs_inode.c:	jfs_inode->bxflag = 0;
fs/jfs/jfs_inode.c:	jfs_inode->blid = 0;
fs/jfs/jfs_inode.c:	jfs_inode->atlhead = 0;
fs/jfs/jfs_inode.c:	jfs_inode->atltail = 0;
fs/jfs/jfs_inode.c:	jfs_inode->xtlid = 0;
fs/jfs/jfs_inode.c:	inode->i_flags |= S_NOQUOTA;
fs/nfs_common/nfsacl.c:		.uid = inode->i_uid,
fs/nfs_common/nfsacl.c:		.gid = inode->i_gid,
fs/binfmt_elf_fdpic.c:	       what, file->f_path.dentry->d_inode->i_ino);
fs/binfmt_elf_fdpic.c:		if (vma->vm_file->f_path.dentry->d_inode->i_nlink == 0) {
fs/pipe.c:		mutex_lock_nested(&pipe->inode->i_mutex, subclass);
fs/pipe.c:		mutex_unlock(&pipe->inode->i_mutex);
fs/pipe.c:	mutex_lock(&inode->i_mutex);
fs/pipe.c:	pipe = inode->i_pipe;
fs/pipe.c:	mutex_unlock(&inode->i_mutex);
fs/pipe.c:	mutex_lock(&inode->i_mutex);
fs/pipe.c:	pipe = inode->i_pipe;
fs/pipe.c:	mutex_unlock(&inode->i_mutex);
fs/pipe.c:			mutex_lock(&inode->i_mutex);
fs/pipe.c:			pipe = inode->i_pipe;
fs/pipe.c:			mutex_unlock(&inode->i_mutex);
fs/pipe.c:	struct pipe_inode_info *pipe = inode->i_pipe;
fs/pipe.c:	mutex_lock(&inode->i_mutex);
fs/pipe.c:	pipe = inode->i_pipe;
fs/pipe.c:	mutex_unlock(&inode->i_mutex);
fs/pipe.c:	mutex_lock(&inode->i_mutex);
fs/pipe.c:	retval = fasync_helper(fd, filp, on, &inode->i_pipe->fasync_readers);
fs/pipe.c:	mutex_unlock(&inode->i_mutex);
fs/pipe.c:	mutex_lock(&inode->i_mutex);
fs/pipe.c:	retval = fasync_helper(fd, filp, on, &inode->i_pipe->fasync_writers);
fs/pipe.c:	mutex_unlock(&inode->i_mutex);
fs/pipe.c:	struct pipe_inode_info *pipe = inode->i_pipe;
fs/pipe.c:	mutex_lock(&inode->i_mutex);
fs/pipe.c:	mutex_unlock(&inode->i_mutex);
fs/pipe.c:	mutex_lock(&inode->i_mutex);
fs/pipe.c:	if (inode->i_pipe) {
fs/pipe.c:		inode->i_pipe->readers++;
fs/pipe.c:	mutex_unlock(&inode->i_mutex);
fs/pipe.c:	mutex_lock(&inode->i_mutex);
fs/pipe.c:	if (inode->i_pipe) {
fs/pipe.c:		inode->i_pipe->writers++;
fs/pipe.c:	mutex_unlock(&inode->i_mutex);
fs/pipe.c:	mutex_lock(&inode->i_mutex);
fs/pipe.c:	if (inode->i_pipe) {
fs/pipe.c:			inode->i_pipe->readers++;
fs/pipe.c:			inode->i_pipe->writers++;
fs/pipe.c:	mutex_unlock(&inode->i_mutex);
fs/pipe.c:	__free_pipe_info(inode->i_pipe);
fs/pipe.c:	inode->i_pipe = NULL;
fs/pipe.c:				dentry->d_inode->i_ino);
fs/pipe.c:	inode->i_ino = get_next_ino();
fs/pipe.c:	inode->i_pipe = pipe;
fs/pipe.c:	inode->i_fop = &rdwr_pipefifo_fops;
fs/pipe.c:	inode->i_state = I_DIRTY;
fs/pipe.c:	inode->i_mode = S_IFIFO | S_IRUSR | S_IWUSR;
fs/pipe.c:	inode->i_uid = current_fsuid();
fs/pipe.c:	inode->i_gid = current_fsgid();
fs/pipe.c:	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/pipe.c:	mutex_lock(&pipe->inode->i_mutex);
fs/pipe.c:	mutex_unlock(&pipe->inode->i_mutex);
fs/drop_caches.c:		spin_lock(&inode->i_lock);
fs/drop_caches.c:		if ((inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) ||
fs/drop_caches.c:		    (inode->i_mapping->nrpages == 0)) {
fs/drop_caches.c:			spin_unlock(&inode->i_lock);
fs/drop_caches.c:		spin_unlock(&inode->i_lock);
fs/drop_caches.c:		invalidate_mapping_pages(inode->i_mapping, 0, -1);
fs/jbd2/transaction.c:	jbd_debug(4, "Adding inode %lu, tid:%d\n", jinode->i_vfs_inode->i_ino,
fs/jbd2/transaction.c:	 * because if jinode->i_transaction == transaction, commit code
fs/jbd2/transaction.c:	 * and if jinode->i_next_transaction == transaction, commit code
fs/jbd2/transaction.c:	if (jinode->i_transaction == transaction ||
fs/jbd2/transaction.c:	    jinode->i_next_transaction == transaction)
fs/jbd2/transaction.c:	if (jinode->i_transaction == transaction ||
fs/jbd2/transaction.c:	    jinode->i_next_transaction == transaction)
fs/jbd2/transaction.c:	if (jinode->i_transaction) {
fs/jbd2/transaction.c:		J_ASSERT(jinode->i_next_transaction == NULL);
fs/jbd2/transaction.c:		J_ASSERT(jinode->i_transaction ==
fs/jbd2/transaction.c:		jinode->i_next_transaction = transaction;
fs/jbd2/transaction.c:	J_ASSERT(!jinode->i_next_transaction);
fs/jbd2/transaction.c:	jinode->i_transaction = transaction;
fs/jbd2/transaction.c:	list_add(&jinode->i_list, &transaction->t_inode_list);
fs/jbd2/transaction.c:	if (!jinode->i_transaction)
fs/jbd2/transaction.c:	inode_trans = jinode->i_transaction;
fs/jbd2/transaction.c:		ret = filemap_fdatawrite_range(jinode->i_vfs_inode->i_mapping,
fs/jbd2/journal.c:	journal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;
fs/jbd2/journal.c:	sprintf(p, "-%lu", journal->j_inode->i_ino);
fs/jbd2/journal.c:		  journal, inode->i_sb->s_id, inode->i_ino,
fs/jbd2/journal.c:		  (long long) inode->i_size,
fs/jbd2/journal.c:		  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);
fs/jbd2/journal.c:	journal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;
fs/jbd2/journal.c:	journal->j_blocksize = inode->i_sb->s_blocksize;
fs/jbd2/journal.c:	return 1 << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);
fs/jbd2/journal.c:	jinode->i_transaction = NULL;
fs/jbd2/journal.c:	jinode->i_next_transaction = NULL;
fs/jbd2/journal.c:	jinode->i_vfs_inode = inode;
fs/jbd2/journal.c:	jinode->i_flags = 0;
fs/jbd2/journal.c:	INIT_LIST_HEAD(&jinode->i_list);
fs/jbd2/journal.c:	if (test_bit(__JI_COMMIT_RUNNING, &jinode->i_flags)) {
fs/jbd2/journal.c:		DEFINE_WAIT_BIT(wait, &jinode->i_flags, __JI_COMMIT_RUNNING);
fs/jbd2/journal.c:		wq = bit_waitqueue(&jinode->i_flags, __JI_COMMIT_RUNNING);
fs/jbd2/journal.c:	if (jinode->i_transaction) {
fs/jbd2/journal.c:		list_del(&jinode->i_list);
fs/jbd2/journal.c:		jinode->i_transaction = NULL;
fs/jbd2/commit.c:		mapping = jinode->i_vfs_inode->i_mapping;
fs/jbd2/commit.c:		set_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);
fs/jbd2/commit.c:		trace_jbd2_submit_inode_data(jinode->i_vfs_inode);
fs/jbd2/commit.c:		J_ASSERT(jinode->i_transaction == commit_transaction);
fs/jbd2/commit.c:		clear_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);
fs/jbd2/commit.c:		wake_up_bit(&jinode->i_flags, __JI_COMMIT_RUNNING);
fs/jbd2/commit.c:		set_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);
fs/jbd2/commit.c:		err = filemap_fdatawait(jinode->i_vfs_inode->i_mapping);
fs/jbd2/commit.c:				&jinode->i_vfs_inode->i_mapping->flags);
fs/jbd2/commit.c:		clear_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);
fs/jbd2/commit.c:		wake_up_bit(&jinode->i_flags, __JI_COMMIT_RUNNING);
fs/jbd2/commit.c:		list_del(&jinode->i_list);
fs/jbd2/commit.c:		if (jinode->i_next_transaction) {
fs/jbd2/commit.c:			jinode->i_transaction = jinode->i_next_transaction;
fs/jbd2/commit.c:			jinode->i_next_transaction = NULL;
fs/jbd2/commit.c:			list_add(&jinode->i_list,
fs/jbd2/commit.c:				&jinode->i_transaction->t_inode_list);
fs/jbd2/commit.c:			jinode->i_transaction = NULL;
fs/ext3/inode.c:		(inode->i_sb->s_blocksize >> 9) : 0;
fs/ext3/inode.c:	return (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);
fs/ext3/inode.c:		  bh, is_metadata, inode->i_mode,
fs/ext3/inode.c:		  test_opt(inode->i_sb, DATA_FLAGS));
fs/ext3/inode.c:	if (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA ||
fs/ext3/inode.c:		ext3_abort(inode->i_sb, __func__,
fs/ext3/inode.c:	needed = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);
fs/ext3/inode.c:	return EXT3_DATA_TRANS_BLOCKS(inode->i_sb) + needed;
fs/ext3/inode.c:	ext3_std_error(inode->i_sb, PTR_ERR(result));
fs/ext3/inode.c:	if (!inode->i_nlink && !is_bad_inode(inode)) {
fs/ext3/inode.c:	if (inode->i_nlink && ext3_should_journal_data(inode) &&
fs/ext3/inode.c:	    EXT3_SB(inode->i_sb)->s_journal &&
fs/ext3/inode.c:	    (S_ISLNK(inode->i_mode) || S_ISREG(inode->i_mode))) {
fs/ext3/inode.c:		journal_t *journal = EXT3_SB(inode->i_sb)->s_journal;
fs/ext3/inode.c:		filemap_write_and_wait(&inode->i_data);
fs/ext3/inode.c:	truncate_inode_pages(&inode->i_data, 0);
fs/ext3/inode.c:	inode->i_size = 0;
fs/ext3/inode.c:	if (inode->i_blocks)
fs/ext3/inode.c: *	inode->i_sb).
fs/ext3/inode.c:	int ptrs = EXT3_ADDR_PER_BLOCK(inode->i_sb);
fs/ext3/inode.c:	int ptrs_bits = EXT3_ADDR_PER_BLOCK_BITS(inode->i_sb);
fs/ext3/inode.c:		ext3_warning (inode->i_sb, "ext3_block_to_path", "block < 0");
fs/ext3/inode.c:		ext3_warning(inode->i_sb, "ext3_block_to_path", "block > big");
fs/ext3/inode.c:	struct super_block *sb = inode->i_sb;
fs/ext3/inode.c:	bg_start = ext3_group_first_block_no(inode->i_sb, ei->i_block_group);
fs/ext3/inode.c:			(EXT3_BLOCKS_PER_GROUP(inode->i_sb) / 16);
fs/ext3/inode.c:	int blocksize = inode->i_sb->s_blocksize;
fs/ext3/inode.c:		bh = sb_getblk(inode->i_sb, new_blocks[n-1]);
fs/ext3/inode.c:	if (!timespec_equal(&inode->i_ctime, &now) || !where->bh) {
fs/ext3/inode.c:		inode->i_ctime = now;
fs/ext3/inode.c:	if (S_ISREG(inode->i_mode) && (!ei->i_block_alloc_info))
fs/ext3/inode.c:	map_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));
fs/ext3/inode.c:	unsigned max_blocks = bh_result->b_size >> inode->i_blkbits;
fs/ext3/inode.c:				EXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb));
fs/ext3/inode.c:		bh_result->b_size = (ret << inode->i_blkbits);
fs/ext3/inode.c:		bh = sb_getblk(inode->i_sb, dummy.b_blocknr);
fs/ext3/inode.c:				memset(bh->b_data,0,inode->i_sb->s_blocksize);
fs/ext3/inode.c:	truncate_inode_pages(inode->i_mapping, inode->i_size);
fs/ext3/inode.c:	ext3_block_truncate_page(inode, inode->i_size);
fs/ext3/inode.c:		if (pos + len > inode->i_size && ext3_can_truncate(inode))
fs/ext3/inode.c:		if (pos + len > inode->i_size)
fs/ext3/inode.c:	if (ret == -ENOSPC && ext3_should_retry_alloc(inode->i_sb, &retries))
fs/ext3/inode.c:	if (pos + copied > inode->i_size)
fs/ext3/inode.c: * ext3 never places buffers on inode->i_mapping->private_list.  metadata
fs/ext3/inode.c:	if (pos + len > inode->i_size && ext3_can_truncate(inode))
fs/ext3/inode.c:	if (pos + len > inode->i_size)
fs/ext3/inode.c:	if (pos + len > inode->i_size && ext3_can_truncate(inode))
fs/ext3/inode.c:	if (pos + len > inode->i_size)
fs/ext3/inode.c:	if (pos + copied > inode->i_size)
fs/ext3/inode.c:	if (pos + len > inode->i_size && ext3_can_truncate(inode))
fs/ext3/inode.c:	if (inode->i_size > ei->i_disksize) {
fs/ext3/inode.c:		ei->i_disksize = inode->i_size;
fs/ext3/inode.c:	if (pos + len > inode->i_size)
fs/ext3/inode.c:	 * ordered to avoid dereferencing inode->i_sb in non-error case to
fs/ext3/inode.c:		     !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ERROR_FS));
fs/ext3/inode.c:		create_empty_buffers(page, inode->i_sb->s_blocksize,
fs/ext3/inode.c:	 * ordered to avoid dereferencing inode->i_sb in non-error case to
fs/ext3/inode.c:		     !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ERROR_FS));
fs/ext3/inode.c:	 * ordered to avoid dereferencing inode->i_sb in non-error case to
fs/ext3/inode.c:		     !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ERROR_FS));
fs/ext3/inode.c:		if (final_size > inode->i_size) {
fs/ext3/inode.c:			ei->i_disksize = inode->i_size;
fs/ext3/inode.c:	if (ret == -ENOSPC && ext3_should_retry_alloc(inode->i_sb, &retries))
fs/ext3/inode.c:		if (inode->i_nlink)
fs/ext3/inode.c:			if (end > inode->i_size) {
fs/ext3/inode.c:		inode->i_mapping->a_ops = &ext3_ordered_aops;
fs/ext3/inode.c:		inode->i_mapping->a_ops = &ext3_writeback_aops;
fs/ext3/inode.c:		inode->i_mapping->a_ops = &ext3_journalled_aops;
fs/ext3/inode.c:	blocksize = inode->i_sb->s_blocksize;
fs/ext3/inode.c:	page = grab_cache_page(inode->i_mapping, index);
fs/ext3/inode.c:	iblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);
fs/ext3/inode.c:			bh = sb_find_get_block(inode->i_sb, nr);
fs/ext3/inode.c: * little-endian 32-bit) and updating @inode->i_blocks appropriately.
fs/ext3/inode.c:			ext3_error(inode->i_sb, "ext3_free_data",
fs/ext3/inode.c:				   inode->i_ino,
fs/ext3/inode.c: *	stored as little-endian 32-bit) and updating @inode->i_blocks
fs/ext3/inode.c:		int addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);
fs/ext3/inode.c:			bh = sb_bread(inode->i_sb, nr);
fs/ext3/inode.c:				ext3_error(inode->i_sb, "ext3_free_branches",
fs/ext3/inode.c:					   inode->i_ino, nr);
fs/ext3/inode.c:	if (S_ISREG(inode->i_mode))
fs/ext3/inode.c:	if (S_ISDIR(inode->i_mode))
fs/ext3/inode.c:	if (S_ISLNK(inode->i_mode))
fs/ext3/inode.c:	int addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);
fs/ext3/inode.c:	unsigned blocksize = inode->i_sb->s_blocksize;
fs/ext3/inode.c:	if (inode->i_size == 0 && ext3_should_writeback_data(inode))
fs/ext3/inode.c:	last_block = (inode->i_size + blocksize-1)
fs/ext3/inode.c:					>> EXT3_BLOCK_SIZE_BITS(inode->i_sb);
fs/ext3/inode.c:	ei->i_disksize = inode->i_size;
fs/ext3/inode.c:	inode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;
fs/ext3/inode.c:	if (inode->i_nlink)
fs/ext3/inode.c:	if (inode->i_nlink)
fs/ext3/inode.c:	block = ext3_get_inode_block(inode->i_sb, inode->i_ino, iloc);
fs/ext3/inode.c:	bh = sb_getblk(inode->i_sb, block);
fs/ext3/inode.c:		ext3_error (inode->i_sb, "ext3_get_inode_loc",
fs/ext3/inode.c:				 inode->i_ino, block);
fs/ext3/inode.c:			block_group = (inode->i_ino - 1) /
fs/ext3/inode.c:					EXT3_INODES_PER_GROUP(inode->i_sb);
fs/ext3/inode.c:				EXT3_INODE_SIZE(inode->i_sb);
fs/ext3/inode.c:			inode_offset = ((inode->i_ino - 1) %
fs/ext3/inode.c:					EXT3_INODES_PER_GROUP(inode->i_sb));
fs/ext3/inode.c:			desc = ext3_get_group_desc(inode->i_sb,
fs/ext3/inode.c:			bitmap_bh = sb_getblk(inode->i_sb,
fs/ext3/inode.c:			ext3_error(inode->i_sb, "ext3_get_inode_loc",
fs/ext3/inode.c:					inode->i_ino, block);
fs/ext3/inode.c:	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);
fs/ext3/inode.c:		inode->i_flags |= S_SYNC;
fs/ext3/inode.c:		inode->i_flags |= S_APPEND;
fs/ext3/inode.c:		inode->i_flags |= S_IMMUTABLE;
fs/ext3/inode.c:		inode->i_flags |= S_NOATIME;
fs/ext3/inode.c:		inode->i_flags |= S_DIRSYNC;
fs/ext3/inode.c:	if (!(inode->i_state & I_NEW))
fs/ext3/inode.c:	inode->i_mode = le16_to_cpu(raw_inode->i_mode);
fs/ext3/inode.c:	i_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
fs/ext3/inode.c:	i_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
fs/ext3/inode.c:	if(!(test_opt (inode->i_sb, NO_UID32))) {
fs/ext3/inode.c:		i_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;
fs/ext3/inode.c:		i_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;
fs/ext3/inode.c:	set_nlink(inode, le16_to_cpu(raw_inode->i_links_count));
fs/ext3/inode.c:	inode->i_size = le32_to_cpu(raw_inode->i_size);
fs/ext3/inode.c:	inode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);
fs/ext3/inode.c:	inode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);
fs/ext3/inode.c:	inode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);
fs/ext3/inode.c:	inode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;
fs/ext3/inode.c:	ei->i_dtime = le32_to_cpu(raw_inode->i_dtime);
fs/ext3/inode.c:	if (inode->i_nlink == 0) {
fs/ext3/inode.c:		if (inode->i_mode == 0 ||
fs/ext3/inode.c:		    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {
fs/ext3/inode.c:	inode->i_blocks = le32_to_cpu(raw_inode->i_blocks);
fs/ext3/inode.c:	ei->i_flags = le32_to_cpu(raw_inode->i_flags);
fs/ext3/inode.c:	ei->i_faddr = le32_to_cpu(raw_inode->i_faddr);
fs/ext3/inode.c:	ei->i_frag_no = raw_inode->i_frag;
fs/ext3/inode.c:	ei->i_frag_size = raw_inode->i_fsize;
fs/ext3/inode.c:	ei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);
fs/ext3/inode.c:	if (!S_ISREG(inode->i_mode)) {
fs/ext3/inode.c:		ei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);
fs/ext3/inode.c:		inode->i_size |=
fs/ext3/inode.c:			((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;
fs/ext3/inode.c:	ei->i_disksize = inode->i_size;
fs/ext3/inode.c:	inode->i_generation = le32_to_cpu(raw_inode->i_generation);
fs/ext3/inode.c:		ei->i_data[block] = raw_inode->i_block[block];
fs/ext3/inode.c:	if (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&
fs/ext3/inode.c:	    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {
fs/ext3/inode.c:		ei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);
fs/ext3/inode.c:		    EXT3_INODE_SIZE(inode->i_sb)) {
fs/ext3/inode.c:	if (S_ISREG(inode->i_mode)) {
fs/ext3/inode.c:		inode->i_op = &ext3_file_inode_operations;
fs/ext3/inode.c:		inode->i_fop = &ext3_file_operations;
fs/ext3/inode.c:	} else if (S_ISDIR(inode->i_mode)) {
fs/ext3/inode.c:		inode->i_op = &ext3_dir_inode_operations;
fs/ext3/inode.c:		inode->i_fop = &ext3_dir_operations;
fs/ext3/inode.c:	} else if (S_ISLNK(inode->i_mode)) {
fs/ext3/inode.c:			inode->i_op = &ext3_fast_symlink_inode_operations;
fs/ext3/inode.c:			nd_terminate_link(ei->i_data, inode->i_size,
fs/ext3/inode.c:			inode->i_op = &ext3_symlink_inode_operations;
fs/ext3/inode.c:		inode->i_op = &ext3_special_inode_operations;
fs/ext3/inode.c:		if (raw_inode->i_block[0])
fs/ext3/inode.c:			init_special_inode(inode, inode->i_mode,
fs/ext3/inode.c:			   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));
fs/ext3/inode.c:			init_special_inode(inode, inode->i_mode,
fs/ext3/inode.c:			   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));
fs/ext3/inode.c:		memset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);
fs/ext3/inode.c:	raw_inode->i_mode = cpu_to_le16(inode->i_mode);
fs/ext3/inode.c:	if(!(test_opt(inode->i_sb, NO_UID32))) {
fs/ext3/inode.c:		raw_inode->i_uid_low = cpu_to_le16(low_16_bits(i_uid));
fs/ext3/inode.c:		raw_inode->i_gid_low = cpu_to_le16(low_16_bits(i_gid));
fs/ext3/inode.c:			raw_inode->i_uid_high =
fs/ext3/inode.c:			raw_inode->i_gid_high =
fs/ext3/inode.c:			raw_inode->i_uid_high = 0;
fs/ext3/inode.c:			raw_inode->i_gid_high = 0;
fs/ext3/inode.c:		raw_inode->i_uid_low =
fs/ext3/inode.c:		raw_inode->i_gid_low =
fs/ext3/inode.c:		raw_inode->i_uid_high = 0;
fs/ext3/inode.c:		raw_inode->i_gid_high = 0;
fs/ext3/inode.c:	raw_inode->i_links_count = cpu_to_le16(inode->i_nlink);
fs/ext3/inode.c:	if (disksize != raw_inode->i_size) {
fs/ext3/inode.c:		raw_inode->i_size = disksize;
fs/ext3/inode.c:	raw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);
fs/ext3/inode.c:	raw_inode->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);
fs/ext3/inode.c:	raw_inode->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);
fs/ext3/inode.c:	raw_inode->i_blocks = cpu_to_le32(inode->i_blocks);
fs/ext3/inode.c:	raw_inode->i_dtime = cpu_to_le32(ei->i_dtime);
fs/ext3/inode.c:	raw_inode->i_flags = cpu_to_le32(ei->i_flags);
fs/ext3/inode.c:	raw_inode->i_faddr = cpu_to_le32(ei->i_faddr);
fs/ext3/inode.c:	raw_inode->i_frag = ei->i_frag_no;
fs/ext3/inode.c:	raw_inode->i_fsize = ei->i_frag_size;
fs/ext3/inode.c:	raw_inode->i_file_acl = cpu_to_le32(ei->i_file_acl);
fs/ext3/inode.c:	if (!S_ISREG(inode->i_mode)) {
fs/ext3/inode.c:		raw_inode->i_dir_acl = cpu_to_le32(ei->i_dir_acl);
fs/ext3/inode.c:		if (disksize != raw_inode->i_size_high) {
fs/ext3/inode.c:			raw_inode->i_size_high = disksize;
fs/ext3/inode.c:			struct super_block *sb = inode->i_sb;
fs/ext3/inode.c:	raw_inode->i_generation = cpu_to_le32(inode->i_generation);
fs/ext3/inode.c:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {
fs/ext3/inode.c:		if (old_valid_dev(inode->i_rdev)) {
fs/ext3/inode.c:			raw_inode->i_block[0] =
fs/ext3/inode.c:				cpu_to_le32(old_encode_dev(inode->i_rdev));
fs/ext3/inode.c:			raw_inode->i_block[1] = 0;
fs/ext3/inode.c:			raw_inode->i_block[0] = 0;
fs/ext3/inode.c:			raw_inode->i_block[1] =
fs/ext3/inode.c:				cpu_to_le32(new_encode_dev(inode->i_rdev));
fs/ext3/inode.c:			raw_inode->i_block[2] = 0;
fs/ext3/inode.c:		raw_inode->i_block[block] = ei->i_data[block];
fs/ext3/inode.c:		raw_inode->i_extra_isize = cpu_to_le16(ei->i_extra_isize);
fs/ext3/inode.c:	ext3_std_error(inode->i_sb, err);
fs/ext3/inode.c: *	inode->i_size = expr;
fs/ext3/inode.c:	return ext3_force_commit(inode->i_sb);
fs/ext3/inode.c: * Called with inode->sem down.
fs/ext3/inode.c:	if ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||
fs/ext3/inode.c:	    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {
fs/ext3/inode.c:		handle = ext3_journal_start(inode, EXT3_MAXQUOTAS_INIT_BLOCKS(inode->i_sb)+
fs/ext3/inode.c:					EXT3_MAXQUOTAS_DEL_BLOCKS(inode->i_sb)+3);
fs/ext3/inode.c:			inode->i_uid = attr->ia_uid;
fs/ext3/inode.c:			inode->i_gid = attr->ia_gid;
fs/ext3/inode.c:	if (S_ISREG(inode->i_mode) &&
fs/ext3/inode.c:	    attr->ia_valid & ATTR_SIZE && attr->ia_size < inode->i_size) {
fs/ext3/inode.c:	ext3_std_error(inode->i_sb, error);
fs/ext3/inode.c:	ret += EXT3_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);
fs/ext3/inode.c:	ext3_std_error(inode->i_sb, err);
fs/ext3/inode.c:	ext3_std_error(inode->i_sb, err);
fs/ext3/inode.c:	ext3_std_error(inode->i_sb, err);
fs/ext3/namei.h:		ext3_error(inode->i_sb, __func__,
fs/ext3/namei.h:			   inode->i_ino);
fs/ext3/super.c:		       inode->i_sb->s_id, inode->i_ino, inode,
fs/ext3/super.c:		       inode->i_mode, inode->i_nlink,
fs/ext3/super.c:	call_rcu(&inode->i_rcu, ext3_i_callback);
fs/ext3/super.c:	if (generation && inode->i_generation != generation) {
fs/ext3/super.c:		if (inode->i_nlink) {
fs/ext3/super.c:				__func__, inode->i_ino, inode->i_size);
fs/ext3/super.c:				  inode->i_ino, inode->i_size);
fs/ext3/super.c:				__func__, inode->i_ino);
fs/ext3/super.c:				  inode->i_ino);
fs/ext3/super.c:	if (!journal_inode->i_nlink) {
fs/ext3/super.c:		  journal_inode, journal_inode->i_size);
fs/ext3/super.c:	if (!S_ISREG(journal_inode->i_mode)) {
fs/ext3/super.c:	if (inode->i_size < off + len) {
fs/ext3/super.c:		EXT3_I(inode)->i_disksize = inode->i_size;
fs/ext3/super.c:	inode->i_version++;
fs/ext3/super.c:	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/ext3/resize.c:	struct super_block *sb = inode->i_sb;
fs/ext3/resize.c:	inode->i_blocks -= (gdbackups + 1) * sb->s_blocksize >> 9;
fs/ext3/resize.c:	struct super_block *sb = inode->i_sb;
fs/ext3/resize.c:	inode->i_blocks += reserved_gdb * sb->s_blocksize >> 9;
fs/ext3/resize.c:	 * inode-by-inode within a group, so enabling these
fs/ext3/dir.c:	struct super_block *sb = inode->i_sb;
fs/ext3/dir.c:	if (EXT3_HAS_COMPAT_FEATURE(inode->i_sb,
fs/ext3/dir.c:	     ((inode->i_size >> sb->s_blocksize_bits) == 1)))
fs/ext3/dir.c:	struct super_block *sb = inode->i_sb;
fs/ext3/dir.c:	while (!error && !stored && filp->f_pos < inode->i_size) {
fs/ext3/dir.c:					(PAGE_CACHE_SHIFT - inode->i_blkbits);
fs/ext3/dir.c:					sb->s_bdev->bd_inode->i_mapping,
fs/ext3/dir.c:					inode->i_ino, filp->f_pos);
fs/ext3/dir.c:			if (filp->f_pos > inode->i_blocks << 9)
fs/ext3/dir.c:		if (filp->f_version != inode->i_version) {
fs/ext3/dir.c:			filp->f_version = inode->i_version;
fs/ext3/dir.c:		while (!error && filp->f_pos < inode->i_size
fs/ext3/dir.c:	sb = inode->i_sb;
fs/ext3/dir.c:		    (filp->f_version != inode->i_version)) {
fs/ext3/dir.c:			filp->f_version = inode->i_version;
fs/ext3/fsync.c:	journal_t *journal = EXT3_SB(inode->i_sb)->s_journal;
fs/ext3/fsync.c:	if (inode->i_sb->s_flags & MS_RDONLY)
fs/ext3/fsync.c:	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/ext3/fsync.c:		ret = ext3_force_commit(inode->i_sb);
fs/ext3/fsync.c:	if (test_opt(inode->i_sb, BARRIER) &&
fs/ext3/fsync.c:		err = blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);
fs/ext3/balloc.c:	struct super_block *sb = inode->i_sb;
fs/ext3/balloc.c:	spinlock_t *rsv_lock = &EXT3_SB(inode->i_sb)->s_rsv_window_lock;
fs/ext3/balloc.c:			rsv_window_remove(inode->i_sb, rsv);
fs/ext3/balloc.c:	struct super_block *sb = inode->i_sb;
fs/ext3/balloc.c:	sb = inode->i_sb;
fs/ext3/ext3.h:	return ext3_journal_start_sb(inode->i_sb, nblocks);
fs/ext3/ext3.h:	if (!S_ISREG(inode->i_mode))
fs/ext3/ext3.h:	if (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)
fs/ext3/ext3.h:	if (!S_ISREG(inode->i_mode))
fs/ext3/ext3.h:	if (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_ORDERED_DATA)
fs/ext3/ext3.h:	if (!S_ISREG(inode->i_mode))
fs/ext3/ext3.h:	if (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_WRITEBACK_DATA)
fs/ext3/file.c:		filemap_flush(inode->i_mapping);
fs/ext3/file.c:			(atomic_read(&inode->i_writecount) == 1))
fs/ext3/ioctl.c:		flags = ext3_mask_flags(inode->i_mode, flags);
fs/ext3/ioctl.c:		mutex_lock(&inode->i_mutex);
fs/ext3/ioctl.c:		inode->i_ctime = CURRENT_TIME_SEC;
fs/ext3/ioctl.c:		mutex_unlock(&inode->i_mutex);
fs/ext3/ioctl.c:		return put_user(inode->i_generation, (int __user *) arg);
fs/ext3/ioctl.c:		mutex_lock(&inode->i_mutex);
fs/ext3/ioctl.c:			inode->i_ctime = CURRENT_TIME_SEC;
fs/ext3/ioctl.c:			inode->i_generation = generation;
fs/ext3/ioctl.c:		mutex_unlock(&inode->i_mutex);
fs/ext3/ioctl.c:		if (test_opt(inode->i_sb, RESERVATION)
fs/ext3/ioctl.c:			&& S_ISREG(inode->i_mode)
fs/ext3/ioctl.c:		if (!test_opt(inode->i_sb, RESERVATION) ||!S_ISREG(inode->i_mode))
fs/ext3/ioctl.c:		struct super_block *sb = inode->i_sb;
fs/ext3/ioctl.c:		struct super_block *sb = inode->i_sb;
fs/ext3/ioctl.c:		struct super_block *sb = inode->i_sb;
fs/ext3/acl.c: * inode->i_mutex: don't care
fs/ext3/acl.c:	if (!test_opt(inode->i_sb, POSIX_ACL))
fs/ext3/acl.c: * inode->i_mutex: down unless called from ext3_new_inode
fs/ext3/acl.c:	if (S_ISLNK(inode->i_mode))
fs/ext3/acl.c:				error = posix_acl_equiv_mode(acl, &inode->i_mode);
fs/ext3/acl.c:					inode->i_ctime = CURRENT_TIME_SEC;
fs/ext3/acl.c:			if (!S_ISDIR(inode->i_mode))
fs/ext3/acl.c: * inode->i_mutex: up (access to inode is still exclusive)
fs/ext3/acl.c:	if (!S_ISLNK(inode->i_mode)) {
fs/ext3/acl.c:			inode->i_mode &= ~current_umask();
fs/ext3/acl.c:	if (test_opt(inode->i_sb, POSIX_ACL) && acl) {
fs/ext3/acl.c:		if (S_ISDIR(inode->i_mode)) {
fs/ext3/acl.c:		error = posix_acl_create(&acl, GFP_NOFS, &inode->i_mode);
fs/ext3/acl.c: * inode->i_mode field must be updated to the desired value by the caller
fs/ext3/acl.c: * inode->i_mutex: down
fs/ext3/acl.c:	if (S_ISLNK(inode->i_mode))
fs/ext3/acl.c:	if (!test_opt(inode->i_sb, POSIX_ACL))
fs/ext3/acl.c:	error = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
fs/ext3/acl.c:			EXT3_DATA_TRANS_BLOCKS(inode->i_sb));
fs/ext3/acl.c:		ext3_std_error(inode->i_sb, error);
fs/ext3/acl.c:	    ext3_should_retry_alloc(inode->i_sb, &retries))
fs/ext3/acl.c:	if (!test_opt(inode->i_sb, POSIX_ACL))
fs/ext3/acl.c:	handle = ext3_journal_start(inode, EXT3_DATA_TRANS_BLOCKS(inode->i_sb));
fs/ext3/acl.c:	if (error == -ENOSPC && ext3_should_retry_alloc(inode->i_sb, &retries))
fs/ext3/namei.c:	*block = inode->i_size >> inode->i_sb->s_blocksize_bits;
fs/ext3/namei.c:		inode->i_size += inode->i_sb->s_blocksize;
fs/ext3/namei.c:		EXT3_I(inode)->i_disksize = inode->i_size;
fs/ext3/namei.c:	if (!EXT3_HAS_COMPAT_FEATURE(inode->i_sb,
fs/ext3/namei.c:	if (!ext3_valid_inum(child->d_inode->i_sb, ino)) {
fs/ext3/namei.c:		ext3_error(child->d_inode->i_sb, "ext3_get_parent",
fs/ext3/namei.c:	return d_obtain_alias(ext3_iget(child->d_inode->i_sb, ino));
fs/ext3/namei.c:		de->inode = cpu_to_le32(inode->i_ino);
fs/ext3/namei.c:		ext3_set_de_type(dir->i_sb, de, inode->i_mode);
fs/ext3/namei.c:		inode->i_op = &ext3_file_inode_operations;
fs/ext3/namei.c:		inode->i_fop = &ext3_file_operations;
fs/ext3/namei.c:		init_special_inode(inode, inode->i_mode, rdev);
fs/ext3/namei.c:		inode->i_op = &ext3_special_inode_operations;
fs/ext3/namei.c:	inode->i_op = &ext3_dir_inode_operations;
fs/ext3/namei.c:	inode->i_fop = &ext3_dir_operations;
fs/ext3/namei.c:	inode->i_size = EXT3_I(inode)->i_disksize = inode->i_sb->s_blocksize;
fs/ext3/namei.c:	de->inode = cpu_to_le32(inode->i_ino);
fs/ext3/namei.c:	de->rec_len = ext3_rec_len_to_disk(inode->i_sb->s_blocksize -
fs/ext3/namei.c:	sb = inode->i_sb;
fs/ext3/namei.c:	if (inode->i_size < EXT3_DIR_REC_LEN(1) + EXT3_DIR_REC_LEN(2) ||
fs/ext3/namei.c:			ext3_error(inode->i_sb, __func__,
fs/ext3/namei.c:				   err, inode->i_ino);
fs/ext3/namei.c:			ext3_warning(inode->i_sb, __func__,
fs/ext3/namei.c:				     inode->i_ino);
fs/ext3/namei.c:	if (le32_to_cpu(de->inode) != inode->i_ino ||
fs/ext3/namei.c:		ext3_warning (inode->i_sb, "empty_dir",
fs/ext3/namei.c:			      inode->i_ino);
fs/ext3/namei.c:	while (offset < inode->i_size ) {
fs/ext3/namei.c:						   err, inode->i_ino, offset);
fs/ext3/namei.c:	struct super_block *sb = inode->i_sb;
fs/ext3/namei.c:	J_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
fs/ext3/namei.c:		S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);
fs/ext3/namei.c:	EXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);
fs/ext3/namei.c:	jbd_debug(4, "superblock will point to %lu\n", inode->i_ino);
fs/ext3/namei.c:			inode->i_ino, NEXT_ORPHAN(inode));
fs/ext3/namei.c:	ext3_std_error(inode->i_sb, err);
fs/ext3/namei.c:	mutex_lock(&EXT3_SB(inode->i_sb)->s_orphan_lock);
fs/ext3/namei.c:	sbi = EXT3_SB(inode->i_sb);
fs/ext3/namei.c:	jbd_debug(4, "remove inode %lu from orphan list\n", inode->i_ino);
fs/ext3/namei.c:	ext3_std_error(inode->i_sb, err);
fs/ext3/namei.c:	mutex_unlock(&EXT3_SB(inode->i_sb)->s_orphan_lock);
fs/ext3/namei.c:	if (le32_to_cpu(de->inode) != inode->i_ino)
fs/ext3/namei.c:	if (inode->i_nlink != 2)
fs/ext3/namei.c:		ext3_warning (inode->i_sb, "ext3_rmdir",
fs/ext3/namei.c:			      inode->i_nlink);
fs/ext3/namei.c:	inode->i_version++;
fs/ext3/namei.c:	inode->i_size = 0;
fs/ext3/namei.c:	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;
fs/ext3/namei.c:	if (le32_to_cpu(de->inode) != inode->i_ino)
fs/ext3/namei.c:	if (!inode->i_nlink) {
fs/ext3/namei.c:		ext3_warning (inode->i_sb, "ext3_unlink",
fs/ext3/namei.c:			      inode->i_ino, inode->i_nlink);
fs/ext3/namei.c:	if (!inode->i_nlink)
fs/ext3/namei.c:	inode->i_ctime = dir->i_ctime;
fs/ext3/namei.c:		inode->i_op = &ext3_symlink_inode_operations;
fs/ext3/namei.c:		inode->i_op = &ext3_fast_symlink_inode_operations;
fs/ext3/namei.c:		inode->i_size = l-1;
fs/ext3/namei.c:	EXT3_I(inode)->i_disksize = inode->i_size;
fs/ext3/namei.c:	if (inode->i_nlink >= EXT3_LINK_MAX)
fs/ext3/namei.c:	inode->i_ctime = CURRENT_TIME_SEC;
fs/ext3/namei.c:	if (!old_bh || le32_to_cpu(old_de->inode) != old_inode->i_ino)
fs/ext3/namei.c:	if (S_ISDIR(old_inode->i_mode)) {
fs/ext3/namei.c:		new_de->inode = cpu_to_le32(old_inode->i_ino);
fs/ext3/namei.c:	old_inode->i_ctime = CURRENT_TIME_SEC;
fs/ext3/namei.c:	if (le32_to_cpu(old_de->inode) != old_inode->i_ino ||
fs/ext3/namei.c:		new_inode->i_ctime = CURRENT_TIME_SEC;
fs/ext3/namei.c:		if (!new_inode->i_nlink)
fs/ext3/namei.c:		filemap_flush(old_inode->i_mapping);
fs/ext3/ialloc.c:	struct super_block * sb = inode->i_sb;
fs/ext3/ialloc.c:	if (atomic_read(&inode->i_count) > 1) {
fs/ext3/ialloc.c:					atomic_read(&inode->i_count));
fs/ext3/ialloc.c:	if (inode->i_nlink) {
fs/ext3/ialloc.c:			inode->i_nlink);
fs/ext3/ialloc.c:	ino = inode->i_ino;
fs/ext3/ialloc.c:	is_directory = S_ISDIR(inode->i_mode);
fs/ext3/ialloc.c:		inode->i_mode = mode;
fs/ext3/ialloc.c:		inode->i_uid = current_fsuid();
fs/ext3/ialloc.c:		inode->i_gid = dir->i_gid;
fs/ext3/ialloc.c:	inode->i_ino = ino;
fs/ext3/ialloc.c:	inode->i_blocks = 0;
fs/ext3/ialloc.c:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
fs/ext3/ialloc.c:	inode->i_generation = sbi->s_next_generation++;
fs/ext3/ialloc.c:	ext3_debug("allocating inode %lu\n", inode->i_ino);
fs/ext3/ialloc.c:	inode->i_flags |= S_NOQUOTA;
fs/ext3/ialloc.c:	if (inode->i_nlink && !ext3_can_truncate(inode))
fs/ext3/ialloc.c:		printk(KERN_NOTICE "i_nlink=%u\n", inode->i_nlink);
fs/ext3/ialloc.c:		if (inode->i_nlink == 0)
fs/ext3/ialloc.c:			inode->i_blocks = 0;
fs/ext3/xattr.c:			inode->i_sb->s_id, inode->i_ino); \
fs/ext3/xattr.c: * dentry->d_inode->i_mutex: don't care
fs/ext3/xattr.c:	bh = sb_bread(inode->i_sb, EXT3_I(inode)->i_file_acl);
fs/ext3/xattr.c:bad_block:	ext3_error(inode->i_sb, __func__,
fs/ext3/xattr.c:			   "inode %lu: bad block "E3FSBLK, inode->i_ino,
fs/ext3/xattr.c:	end = (void *)raw_inode + EXT3_SB(inode->i_sb)->s_inode_size;
fs/ext3/xattr.c:	bh = sb_bread(inode->i_sb, EXT3_I(inode)->i_file_acl);
fs/ext3/xattr.c:		ext3_error(inode->i_sb, __func__,
fs/ext3/xattr.c:			   "inode %lu: bad block "E3FSBLK, inode->i_ino,
fs/ext3/xattr.c:	end = (void *)raw_inode + EXT3_SB(inode->i_sb)->s_inode_size;
fs/ext3/xattr.c:	ext3_std_error(inode->i_sb, error);
fs/ext3/xattr.c:	struct super_block *sb = inode->i_sb;
fs/ext3/xattr.c:				"inode %lu: bad block "E3FSBLK, inode->i_ino,
fs/ext3/xattr.c:	struct super_block *sb = inode->i_sb;
fs/ext3/xattr.c:	ext3_error(inode->i_sb, __func__,
fs/ext3/xattr.c:		   "inode %lu: bad block "E3FSBLK, inode->i_ino,
fs/ext3/xattr.c:	is->s.end = (void *)raw_inode + EXT3_SB(inode->i_sb)->s_inode_size;
fs/ext3/xattr.c:		memset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);
fs/ext3/xattr.c:		ext3_xattr_update_super_block(handle, inode->i_sb);
fs/ext3/xattr.c:		inode->i_ctime = CURRENT_TIME_SEC;
fs/ext3/xattr.c:	handle = ext3_journal_start(inode, EXT3_DATA_TRANS_BLOCKS(inode->i_sb));
fs/ext3/xattr.c:		    ext3_should_retry_alloc(inode->i_sb, &retries))
fs/ext3/xattr.c:	bh = sb_bread(inode->i_sb, EXT3_I(inode)->i_file_acl);
fs/ext3/xattr.c:		ext3_error(inode->i_sb, __func__,
fs/ext3/xattr.c:			"inode %lu: block "E3FSBLK" read error", inode->i_ino,
fs/ext3/xattr.c:		ext3_error(inode->i_sb, __func__,
fs/ext3/xattr.c:			"inode %lu: bad block "E3FSBLK, inode->i_ino,
fs/ext3/xattr.c:	ce = mb_cache_entry_find_first(ext3_xattr_cache, inode->i_sb->s_bdev,
fs/ext3/xattr.c:		bh = sb_bread(inode->i_sb, ce->e_block);
fs/ext3/xattr.c:			ext3_error(inode->i_sb, __func__,
fs/ext3/xattr.c:				inode->i_ino, (unsigned long) ce->e_block);
fs/ext3/xattr.c:		ce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);
fs/9p/vfs_super.c:		root->d_inode->i_ino = v9fs_qid2ino(&st->qid);
fs/9p/vfs_super.c:		root->d_inode->i_ino = v9fs_qid2ino(&st->qid);
fs/9p/vfs_super.c:	if (!v9inode->writeback_fid)
fs/9p/vfs_super.c:	ret = p9_client_wstat(v9inode->writeback_fid, &wstat);
fs/9p/vfs_super.c:	if (!v9inode->writeback_fid)
fs/9p/vfs_super.c:	ret = p9_client_fsync(v9inode->writeback_fid, 0);
fs/9p/cache.c:	memcpy(buffer, &v9inode->qid.path, sizeof(v9inode->qid.path));
fs/9p/cache.c:		 &v9inode->vfs_inode, v9inode->qid.path);
fs/9p/cache.c:	return sizeof(v9inode->qid.path);
fs/9p/cache.c:	*size = i_size_read(&v9inode->vfs_inode);
fs/9p/cache.c:		 &v9inode->vfs_inode, *size);
fs/9p/cache.c:	memcpy(buffer, &v9inode->qid.version, sizeof(v9inode->qid.version));
fs/9p/cache.c:		 &v9inode->vfs_inode, v9inode->qid.version);
fs/9p/cache.c:	return sizeof(v9inode->qid.version);
fs/9p/cache.c:	if (buflen != sizeof(v9inode->qid.version))
fs/9p/cache.c:	if (memcmp(buffer, &v9inode->qid.version,
fs/9p/cache.c:		   sizeof(v9inode->qid.version)))
fs/9p/cache.c:		nr_pages = pagevec_lookup(&pvec, v9inode->vfs_inode.i_mapping,
fs/9p/cache.c:	if (!S_ISREG(inode->i_mode))
fs/9p/cache.c:	if (v9inode->fscache)
fs/9p/cache.c:	v9inode->fscache = fscache_acquire_cookie(v9ses->fscache,
fs/9p/cache.c:		 inode, v9inode->fscache);
fs/9p/cache.c:	if (!v9inode->fscache)
fs/9p/cache.c:		 inode, v9inode->fscache);
fs/9p/cache.c:	fscache_relinquish_cookie(v9inode->fscache, 0);
fs/9p/cache.c:	v9inode->fscache = NULL;
fs/9p/cache.c:	if (!v9inode->fscache)
fs/9p/cache.c:		 inode, v9inode->fscache);
fs/9p/cache.c:	fscache_relinquish_cookie(v9inode->fscache, 1);
fs/9p/cache.c:	v9inode->fscache = NULL;
fs/9p/cache.c:	if (!v9inode->fscache)
fs/9p/cache.c:	spin_lock(&v9inode->fscache_lock);
fs/9p/cache.c:	spin_unlock(&v9inode->fscache_lock);
fs/9p/cache.c:	if (!v9inode->fscache)
fs/9p/cache.c:	old = v9inode->fscache;
fs/9p/cache.c:	spin_lock(&v9inode->fscache_lock);
fs/9p/cache.c:	fscache_relinquish_cookie(v9inode->fscache, 1);
fs/9p/cache.c:	v9inode->fscache = fscache_acquire_cookie(v9ses->fscache,
fs/9p/cache.c:		 inode, old, v9inode->fscache);
fs/9p/cache.c:	spin_unlock(&v9inode->fscache_lock);
fs/9p/cache.c:	BUG_ON(!v9inode->fscache);
fs/9p/cache.c:	return fscache_maybe_release_page(v9inode->fscache, page, gfp);
fs/9p/cache.c:	BUG_ON(!v9inode->fscache);
fs/9p/cache.c:		fscache_wait_on_page_write(v9inode->fscache, page);
fs/9p/cache.c:		fscache_uncache_page(v9inode->fscache, page);
fs/9p/cache.c:	if (!v9inode->fscache)
fs/9p/cache.c:	ret = fscache_read_or_alloc_page(v9inode->fscache,
fs/9p/cache.c:	if (!v9inode->fscache)
fs/9p/cache.c:	ret = fscache_read_or_alloc_pages(v9inode->fscache,
fs/9p/cache.c:	ret = fscache_write_page(v9inode->fscache, page, GFP_KERNEL);
fs/9p/cache.c:		fscache_wait_on_page_write(v9inode->fscache, page);
fs/9p/cache.h:	fscache_uncache_page(v9inode->fscache, page);
fs/9p/vfs_dentry.c:	if (v9inode->cache_validity & V9FS_INO_INVALID_ATTR) {
fs/9p/vfs_file.c:			inode->i_blocks = 0;
fs/9p/vfs_file.c:	mutex_lock(&v9inode->v_mutex);
fs/9p/vfs_file.c:	if (v9ses->cache && !v9inode->writeback_fid &&
fs/9p/vfs_file.c:			mutex_unlock(&v9inode->v_mutex);
fs/9p/vfs_file.c:		v9inode->writeback_fid = (void *) fid;
fs/9p/vfs_file.c:	mutex_unlock(&v9inode->v_mutex);
fs/9p/vfs_file.c:		filemap_write_and_wait(inode->i_mapping);
fs/9p/vfs_file.c:		invalidate_mapping_pages(&inode->i_data, 0, -1);
fs/9p/vfs_file.c:		filemap_write_and_wait(inode->i_mapping);
fs/9p/vfs_file.c:		invalidate_mapping_pages(&inode->i_data, 0, -1);
fs/9p/vfs_file.c:		filemap_write_and_wait(inode->i_mapping);
fs/9p/vfs_file.c:		invalidate_mapping_pages(&inode->i_data, 0, -1);
fs/9p/vfs_file.c:		if (inode->i_mapping && inode->i_mapping->nrpages)
fs/9p/vfs_file.c:			invalidate_inode_pages2_range(inode->i_mapping,
fs/9p/vfs_file.c:	retval = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/9p/vfs_file.c:	mutex_lock(&inode->i_mutex);
fs/9p/vfs_file.c:	mutex_unlock(&inode->i_mutex);
fs/9p/vfs_file.c:	retval = filemap_write_and_wait_range(inode->i_mapping, start, end);
fs/9p/vfs_file.c:	mutex_lock(&inode->i_mutex);
fs/9p/vfs_file.c:	mutex_unlock(&inode->i_mutex);
fs/9p/vfs_file.c:	BUG_ON(!v9inode->writeback_fid);
fs/9p/vfs_file.c:	if (page->mapping != inode->i_mapping)
fs/9p/vfs_file.c:	mutex_lock(&inode->i_mutex);
fs/9p/vfs_file.c:	mutex_unlock(&inode->i_mutex);
fs/9p/vfs_file.c:	mutex_unlock(&inode->i_mutex);
fs/9p/v9fs.c:	v9inode->fscache = NULL;
fs/9p/v9fs.c:	memset(&v9inode->qid, 0, sizeof(v9inode->qid));
fs/9p/v9fs.c:	inode_init_once(&v9inode->vfs_inode);
fs/9p/vfs_addr.c:	BUG_ON(!v9inode->writeback_fid);
fs/9p/vfs_addr.c:					  v9inode->writeback_fid,
fs/9p/vfs_addr.c:	BUG_ON(!v9inode->writeback_fid);
fs/9p/vfs_addr.c:	retval = v9fs_fid_readpage(v9inode->writeback_fid, page);
fs/9p/vfs_addr.c:	if (last_pos > inode->i_size) {
fs/9p/vfs_addr.c:		inode_add_bytes(inode, last_pos - inode->i_size);
fs/9p/v9fs.h:	return (inode->i_sb->s_fs_info);
fs/9p/vfs_inode_dotl.c:	if (dir_inode->i_mode & S_ISGID) {
fs/9p/vfs_inode_dotl.c:		return dir_inode->i_gid;
fs/9p/vfs_inode_dotl.c:	if ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT))
fs/9p/vfs_inode_dotl.c:	if (inode->i_generation != st->st_gen)
fs/9p/vfs_inode_dotl.c:	if (memcmp(&v9inode->qid.version,
fs/9p/vfs_inode_dotl.c:		   &st->qid.version, sizeof(v9inode->qid.version)))
fs/9p/vfs_inode_dotl.c:	if (v9inode->qid.type != st->qid.type)
fs/9p/vfs_inode_dotl.c:	memcpy(&v9inode->qid, &st->qid, sizeof(st->qid));
fs/9p/vfs_inode_dotl.c:	inode->i_generation = st->st_gen;
fs/9p/vfs_inode_dotl.c:	if (!(inode->i_state & I_NEW))
fs/9p/vfs_inode_dotl.c:	inode->i_ino = i_ino;
fs/9p/vfs_inode_dotl.c:	mutex_lock(&v9inode->v_mutex);
fs/9p/vfs_inode_dotl.c:	if (v9ses->cache && !v9inode->writeback_fid &&
fs/9p/vfs_inode_dotl.c:			mutex_unlock(&v9inode->v_mutex);
fs/9p/vfs_inode_dotl.c:		v9inode->writeback_fid = (void *) inode_fid;
fs/9p/vfs_inode_dotl.c:	mutex_unlock(&v9inode->v_mutex);
fs/9p/vfs_inode_dotl.c:	if (S_ISREG(dentry->d_inode->i_mode))
fs/9p/vfs_inode_dotl.c:		filemap_write_and_wait(dentry->d_inode->i_mapping);
fs/9p/vfs_inode_dotl.c:		inode->i_atime.tv_sec = stat->st_atime_sec;
fs/9p/vfs_inode_dotl.c:		inode->i_atime.tv_nsec = stat->st_atime_nsec;
fs/9p/vfs_inode_dotl.c:		inode->i_mtime.tv_sec = stat->st_mtime_sec;
fs/9p/vfs_inode_dotl.c:		inode->i_mtime.tv_nsec = stat->st_mtime_nsec;
fs/9p/vfs_inode_dotl.c:		inode->i_ctime.tv_sec = stat->st_ctime_sec;
fs/9p/vfs_inode_dotl.c:		inode->i_ctime.tv_nsec = stat->st_ctime_nsec;
fs/9p/vfs_inode_dotl.c:		inode->i_uid = stat->st_uid;
fs/9p/vfs_inode_dotl.c:		inode->i_gid = stat->st_gid;
fs/9p/vfs_inode_dotl.c:		mode |= inode->i_mode & ~S_IALLUGO;
fs/9p/vfs_inode_dotl.c:		inode->i_mode = mode;
fs/9p/vfs_inode_dotl.c:		inode->i_blocks = stat->st_blocks;
fs/9p/vfs_inode_dotl.c:			inode->i_atime.tv_sec = stat->st_atime_sec;
fs/9p/vfs_inode_dotl.c:			inode->i_atime.tv_nsec = stat->st_atime_nsec;
fs/9p/vfs_inode_dotl.c:			inode->i_mtime.tv_sec = stat->st_mtime_sec;
fs/9p/vfs_inode_dotl.c:			inode->i_mtime.tv_nsec = stat->st_mtime_nsec;
fs/9p/vfs_inode_dotl.c:			inode->i_ctime.tv_sec = stat->st_ctime_sec;
fs/9p/vfs_inode_dotl.c:			inode->i_ctime.tv_nsec = stat->st_ctime_nsec;
fs/9p/vfs_inode_dotl.c:			inode->i_uid = stat->st_uid;
fs/9p/vfs_inode_dotl.c:			inode->i_gid = stat->st_gid;
fs/9p/vfs_inode_dotl.c:			inode->i_mode = stat->st_mode;
fs/9p/vfs_inode_dotl.c:			if ((S_ISBLK(inode->i_mode)) ||
fs/9p/vfs_inode_dotl.c:						(S_ISCHR(inode->i_mode)))
fs/9p/vfs_inode_dotl.c:				init_special_inode(inode, inode->i_mode,
fs/9p/vfs_inode_dotl.c:								inode->i_rdev);
fs/9p/vfs_inode_dotl.c:			inode->i_rdev = new_decode_dev(stat->st_rdev);
fs/9p/vfs_inode_dotl.c:			inode->i_blocks = stat->st_blocks;
fs/9p/vfs_inode_dotl.c:		inode->i_generation = stat->st_gen;
fs/9p/vfs_inode_dotl.c:	v9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;
fs/9p/vfs_inode_dotl.c:	if ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT))
fs/9p/vfs_inode_dotl.c:	spin_lock(&inode->i_lock);
fs/9p/vfs_inode_dotl.c:	 * We don't want to refresh inode->i_size,
fs/9p/vfs_inode_dotl.c:	i_size = inode->i_size;
fs/9p/vfs_inode_dotl.c:		inode->i_size = i_size;
fs/9p/vfs_inode_dotl.c:	spin_unlock(&inode->i_lock);
fs/9p/v9fs_vfs.h:	v9inode->cache_validity |= V9FS_INO_INVALID_ATTR;
fs/9p/acl.c:	if (S_ISLNK(inode->i_mode))
fs/9p/acl.c:		retval = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
fs/9p/acl.c:	if (S_ISLNK(inode->i_mode))
fs/9p/acl.c:			umode_t mode = inode->i_mode;
fs/9p/acl.c:						 (inode->i_mode & ~S_IALLUGO));
fs/9p/acl.c:		if (!S_ISDIR(inode->i_mode)) {
fs/9p/vfs_inode.c:	v9inode->fscache = NULL;
fs/9p/vfs_inode.c:	spin_lock_init(&v9inode->fscache_lock);
fs/9p/vfs_inode.c:	v9inode->writeback_fid = NULL;
fs/9p/vfs_inode.c:	v9inode->cache_validity = 0;
fs/9p/vfs_inode.c:	mutex_init(&v9inode->v_mutex);
fs/9p/vfs_inode.c:	return &v9inode->vfs_inode;
fs/9p/vfs_inode.c:	call_rcu(&inode->i_rcu, v9fs_i_callback);
fs/9p/vfs_inode.c:	inode->i_blocks = 0;
fs/9p/vfs_inode.c:	inode->i_rdev = rdev;
fs/9p/vfs_inode.c:	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
fs/9p/vfs_inode.c:	inode->i_mapping->a_ops = &v9fs_addr_operations;
fs/9p/vfs_inode.c:			inode->i_op = &v9fs_file_inode_operations_dotl;
fs/9p/vfs_inode.c:			inode->i_op = &v9fs_file_inode_operations;
fs/9p/vfs_inode.c:		init_special_inode(inode, inode->i_mode, inode->i_rdev);
fs/9p/vfs_inode.c:			inode->i_op = &v9fs_file_inode_operations_dotl;
fs/9p/vfs_inode.c:				inode->i_fop =
fs/9p/vfs_inode.c:				inode->i_fop = &v9fs_file_operations_dotl;
fs/9p/vfs_inode.c:			inode->i_op = &v9fs_file_inode_operations;
fs/9p/vfs_inode.c:				inode->i_fop = &v9fs_cached_file_operations;
fs/9p/vfs_inode.c:				inode->i_fop = &v9fs_file_operations;
fs/9p/vfs_inode.c:			inode->i_op = &v9fs_symlink_inode_operations_dotl;
fs/9p/vfs_inode.c:			inode->i_op = &v9fs_symlink_inode_operations;
fs/9p/vfs_inode.c:			inode->i_op = &v9fs_dir_inode_operations_dotl;
fs/9p/vfs_inode.c:			inode->i_op = &v9fs_dir_inode_operations_dotu;
fs/9p/vfs_inode.c:			inode->i_op = &v9fs_dir_inode_operations;
fs/9p/vfs_inode.c:			inode->i_fop = &v9fs_dir_operations_dotl;
fs/9p/vfs_inode.c:			inode->i_fop = &v9fs_dir_operations;
fs/9p/vfs_inode.c:	truncate_inode_pages(inode->i_mapping, 0);
fs/9p/vfs_inode.c:	filemap_fdatawrite(inode->i_mapping);
fs/9p/vfs_inode.c:	if (v9inode->writeback_fid) {
fs/9p/vfs_inode.c:		p9_client_clunk(v9inode->writeback_fid);
fs/9p/vfs_inode.c:		v9inode->writeback_fid = NULL;
fs/9p/vfs_inode.c:	if ((inode->i_mode & S_IFMT) != (umode & S_IFMT))
fs/9p/vfs_inode.c:	if (memcmp(&v9inode->qid.version,
fs/9p/vfs_inode.c:		   &st->qid.version, sizeof(v9inode->qid.version)))
fs/9p/vfs_inode.c:	if (v9inode->qid.type != st->qid.type)
fs/9p/vfs_inode.c:	memcpy(&v9inode->qid, &st->qid, sizeof(st->qid));
fs/9p/vfs_inode.c:	if (!(inode->i_state & I_NEW))
fs/9p/vfs_inode.c:	inode->i_ino = i_ino;
fs/9p/vfs_inode.c:	mutex_lock(&v9inode->v_mutex);
fs/9p/vfs_inode.c:	if (v9ses->cache && !v9inode->writeback_fid &&
fs/9p/vfs_inode.c:			mutex_unlock(&v9inode->v_mutex);
fs/9p/vfs_inode.c:		v9inode->writeback_fid = (void *) inode_fid;
fs/9p/vfs_inode.c:	mutex_unlock(&v9inode->v_mutex);
fs/9p/vfs_inode.c:			if (S_ISDIR(new_inode->i_mode))
fs/9p/vfs_inode.c:		if (S_ISDIR(old_inode->i_mode)) {
fs/9p/vfs_inode.c:	v9fs_stat2inode(st, dentry->d_inode, dentry->d_inode->i_sb);
fs/9p/vfs_inode.c:	if (S_ISREG(dentry->d_inode->i_mode))
fs/9p/vfs_inode.c:		filemap_write_and_wait(dentry->d_inode->i_mapping);
fs/9p/vfs_inode.c:	inode->i_atime.tv_sec = stat->atime;
fs/9p/vfs_inode.c:	inode->i_mtime.tv_sec = stat->mtime;
fs/9p/vfs_inode.c:	inode->i_ctime.tv_sec = stat->mtime;
fs/9p/vfs_inode.c:	inode->i_uid = v9ses->dfltuid;
fs/9p/vfs_inode.c:	inode->i_gid = v9ses->dfltgid;
fs/9p/vfs_inode.c:		inode->i_uid = stat->n_uid;
fs/9p/vfs_inode.c:		inode->i_gid = stat->n_gid;
fs/9p/vfs_inode.c:	if ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {
fs/9p/vfs_inode.c:	mode |= inode->i_mode & ~S_IALLUGO;
fs/9p/vfs_inode.c:	inode->i_mode = mode;
fs/9p/vfs_inode.c:	inode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;
fs/9p/vfs_inode.c:	v9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;
fs/9p/vfs_inode.c:	if ((inode->i_mode & S_IFMT) != (umode & S_IFMT))
fs/9p/vfs_inode.c:	spin_lock(&inode->i_lock);
fs/9p/vfs_inode.c:	 * We don't want to refresh inode->i_size,
fs/9p/vfs_inode.c:	i_size = inode->i_size;
fs/9p/vfs_inode.c:	v9fs_stat2inode(st, inode, inode->i_sb);
fs/9p/vfs_inode.c:		inode->i_size = i_size;
fs/9p/vfs_inode.c:	spin_unlock(&inode->i_lock);
security/tomoyo/securityfs_if.c:	const int key = ((u8 *) file->f_path.dentry->d_inode->i_private)
security/tomoyo/realpath.c:			if (inode && S_ISDIR(inode->i_mode)) {
security/tomoyo/realpath.c:			if (inode && S_ISDIR(inode->i_mode)) {
security/tomoyo/realpath.c:		if (inode->i_op && !inode->i_op->rename)
security/tomoyo/realpath.c:		if (!path->mnt || (inode->i_op && !inode->i_op->rename))
security/tomoyo/file.c:		if (!dentry->d_inode || !S_ISDIR(dentry->d_inode->i_mode))
security/tomoyo/condition.c:			stat->uid  = inode->i_uid;
security/tomoyo/condition.c:			stat->gid  = inode->i_gid;
security/tomoyo/condition.c:			stat->ino  = inode->i_ino;
security/tomoyo/condition.c:			stat->mode = inode->i_mode;
security/tomoyo/condition.c:			stat->dev  = inode->i_sb->s_dev;
security/tomoyo/condition.c:			stat->rdev = inode->i_rdev;
security/inode.c:	inode->i_ino = get_next_ino();
security/inode.c:	inode->i_mode = mode;
security/inode.c:	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
security/inode.c:	inode->i_private = data;
security/inode.c:		inode->i_op = &simple_dir_inode_operations;
security/inode.c:		inode->i_fop = &simple_dir_operations;
security/inode.c:		inode->i_fop = fops;
security/inode.c:	mutex_lock(&parent->d_inode->i_mutex);
security/inode.c:			if (S_ISDIR(dentry->d_inode->i_mode))
security/inode.c:	mutex_unlock(&parent->d_inode->i_mutex);
security/commoncap.c:	if (!inode->i_op->getxattr)
security/commoncap.c:	error = inode->i_op->getxattr(dentry, XATTR_NAME_CAPS, NULL, 0);
security/commoncap.c:	if (!inode->i_op->removexattr)
security/commoncap.c:	return inode->i_op->removexattr(dentry, XATTR_NAME_CAPS);
security/commoncap.c:	if (!inode || !inode->i_op->getxattr)
security/commoncap.c:	size = inode->i_op->getxattr((struct dentry *)dentry, XATTR_NAME_CAPS, &caps,
security/device_cgroup.c:	if (S_ISBLK(inode->i_mode))
security/device_cgroup.c:	if (S_ISCHR(inode->i_mode))
security/integrity/iint.c:	inode->i_flags |= S_IMA;
security/integrity/evm/evm_crypto.c:	hmac_misc.ino = inode->i_ino;
security/integrity/evm/evm_crypto.c:	hmac_misc.generation = inode->i_generation;
security/integrity/evm/evm_crypto.c:	hmac_misc.uid = from_kuid(&init_user_ns, inode->i_uid);
security/integrity/evm/evm_crypto.c:	hmac_misc.gid = from_kgid(&init_user_ns, inode->i_gid);
security/integrity/evm/evm_crypto.c:	hmac_misc.mode = inode->i_mode;
security/integrity/evm/evm_crypto.c:	if (!inode->i_op || !inode->i_op->getxattr)
security/integrity/evm/evm_crypto.c:	} else if (rc == -ENODATA && inode->i_op->removexattr) {
security/integrity/evm/evm_crypto.c:		rc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);
security/integrity/evm/evm_main.c:	if (!inode->i_op || !inode->i_op->getxattr)
security/integrity/evm/evm_main.c:		error = inode->i_op->getxattr(dentry, *xattr, NULL, 0);
security/integrity/evm/evm_main.c:	if (!evm_initialized || !S_ISREG(inode->i_mode) || evm_fixmode)
security/integrity/evm/evm_main.c:	mutex_lock(&inode->i_mutex);
security/integrity/evm/evm_main.c:	mutex_unlock(&inode->i_mutex);
security/integrity/ima/ima_audit.c:		audit_log_untrustedstring(ab, inode->i_sb->s_id);
security/integrity/ima/ima_audit.c:		audit_log_format(ab, " ino=%lu", inode->i_ino);
security/integrity/ima/ima_main.c:	if (!S_ISREG(inode->i_mode) || !ima_initialized)
security/integrity/ima/ima_main.c:	mutex_lock(&inode->i_mutex);	/* file metadata: permissions, xattr */
security/integrity/ima/ima_main.c:		if (atomic_read(&inode->i_readcount) && IS_IMA(inode))
security/integrity/ima/ima_main.c:	if (atomic_read(&inode->i_writecount) > 0)
security/integrity/ima/ima_main.c:	mutex_unlock(&inode->i_mutex);
security/integrity/ima/ima_main.c:	mutex_lock(&inode->i_mutex);
security/integrity/ima/ima_main.c:	if (atomic_read(&inode->i_writecount) == 1 &&
security/integrity/ima/ima_main.c:	    iint->version != inode->i_version) {
security/integrity/ima/ima_main.c:	mutex_unlock(&inode->i_mutex);
security/integrity/ima/ima_main.c:	if (!iint_initialized || !S_ISREG(inode->i_mode))
security/integrity/ima/ima_main.c:	if (!ima_initialized || !S_ISREG(inode->i_mode))
security/integrity/ima/ima_main.c:	mutex_lock(&inode->i_mutex);
security/integrity/ima/ima_main.c:	mutex_unlock(&inode->i_mutex);
security/integrity/ima/ima_api.c:		u64 i_version = file->f_dentry->d_inode->i_version;
security/integrity/ima/ima_policy.c:	    && rule->fsmagic != inode->i_sb->s_magic)
security/integrity/ima/ima_policy.c:	if ((rule->flags & IMA_FOWNER) && !uid_eq(rule->fowner, inode->i_uid))
security/integrity/ima/ima_appraise.c:	if (!inode->i_op->getxattr)
security/integrity/ima/ima_appraise.c:		    (inode->i_size == 0) ? INTEGRITY_PASS : INTEGRITY_NOLABEL;
security/integrity/ima/ima_appraise.c:	if (!ima_initialized || !ima_appraise || !S_ISREG(inode->i_mode)
security/integrity/ima/ima_appraise.c:	    || !inode->i_op->removexattr)
security/integrity/ima/ima_appraise.c:		rc = inode->i_op->removexattr(dentry, XATTR_NAME_IMA);
security/integrity/ima/ima_appraise.c:	if (!ima_initialized || !ima_appraise || !S_ISREG(inode->i_mode))
security/lsm_audit.c:			audit_log_untrustedstring(ab, inode->i_sb->s_id);
security/lsm_audit.c:			audit_log_format(ab, " ino=%lu", inode->i_ino);
security/lsm_audit.c:			audit_log_untrustedstring(ab, inode->i_sb->s_id);
security/lsm_audit.c:			audit_log_format(ab, " ino=%lu", inode->i_ino);
security/lsm_audit.c:		audit_log_untrustedstring(ab, inode->i_sb->s_id);
security/lsm_audit.c:		audit_log_format(ab, " ino=%lu", inode->i_ino);
security/apparmor/apparmorfs.c:	return single_open(file, aa_fs_seq_show, inode->i_private);
security/apparmor/lsm.c:	struct path_cond cond = { dentry->d_inode->i_uid,
security/apparmor/lsm.c:				  dentry->d_inode->i_mode
security/apparmor/lsm.c:	cond.uid = inode->i_uid;
security/apparmor/lsm.c:	cond.mode = inode->i_mode;
security/apparmor/lsm.c:	struct path_cond cond = { path->dentry->d_inode->i_uid,
security/apparmor/lsm.c:				  path->dentry->d_inode->i_mode
security/apparmor/lsm.c:		struct path_cond cond = { old_dentry->d_inode->i_uid,
security/apparmor/lsm.c:					  old_dentry->d_inode->i_mode
security/apparmor/lsm.c:	struct path_cond cond =  { path->dentry->d_inode->i_uid,
security/apparmor/lsm.c:				   path->dentry->d_inode->i_mode
security/apparmor/lsm.c:		struct path_cond cond = { inode->i_uid, inode->i_mode };
security/apparmor/file.c:	if (d_unlinked(dentry) && dentry->d_inode->i_nlink == 0)
security/apparmor/file.c:		old_dentry->d_inode->i_uid,
security/apparmor/file.c:		old_dentry->d_inode->i_mode
security/apparmor/file.c:		.uid = file->f_path.dentry->d_inode->i_uid,
security/apparmor/file.c:		.mode = file->f_path.dentry->d_inode->i_mode
security/apparmor/domain.c:		bprm->file->f_path.dentry->d_inode->i_uid,
security/apparmor/domain.c:		bprm->file->f_path.dentry->d_inode->i_mode
security/apparmor/include/apparmor.h:	return !(inode->i_sb->s_flags & MS_NOUSER);
security/selinux/hooks.c:	inode->i_security = isec;
security/selinux/hooks.c:	struct inode_security_struct *isec = inode->i_security;
security/selinux/hooks.c:	struct superblock_security_struct *sbsec = inode->i_sb->s_security;
security/selinux/hooks.c:	inode->i_security = NULL;
security/selinux/hooks.c:		if (!root_inode->i_op->getxattr) {
security/selinux/hooks.c:		rc = root_inode->i_op->getxattr(root, XATTR_NAME_SELINUX, NULL, 0);
security/selinux/hooks.c:	struct inode_security_struct *root_isec = inode->i_security;
security/selinux/hooks.c:			struct inode_security_struct *newisec = newinode->i_security;
security/selinux/hooks.c:		const struct inode_security_struct *oldisec = oldinode->i_security;
security/selinux/hooks.c:		struct inode_security_struct *newisec = newinode->i_security;
security/selinux/hooks.c:	struct inode_security_struct *isec = inode->i_security;
security/selinux/hooks.c:	sbsec = inode->i_sb->s_security;
security/selinux/hooks.c:		if (!inode->i_op->getxattr) {
security/selinux/hooks.c:		rc = inode->i_op->getxattr(dentry, XATTR_NAME_SELINUX,
security/selinux/hooks.c:			rc = inode->i_op->getxattr(dentry, XATTR_NAME_SELINUX,
security/selinux/hooks.c:			rc = inode->i_op->getxattr(dentry,
security/selinux/hooks.c:				       -rc, inode->i_sb->s_id, inode->i_ino);
security/selinux/hooks.c:				char *dev = inode->i_sb->s_id;
security/selinux/hooks.c:				unsigned long ino = inode->i_ino;
security/selinux/hooks.c:		isec->sclass = inode_mode_to_security_class(inode->i_mode);
security/selinux/hooks.c:		if ((sbsec->flags & SE_SBPROC) && !S_ISLNK(inode->i_mode)) {
security/selinux/hooks.c:				isec->sclass = inode_mode_to_security_class(inode->i_mode);
security/selinux/hooks.c:		isec->sclass = inode_mode_to_security_class(inode->i_mode);
security/selinux/hooks.c:	isec = inode->i_security;
security/selinux/hooks.c:	isec = dentry->d_inode->i_security;
security/selinux/hooks.c:	old_isec = old_dentry->d_inode->i_security;
security/selinux/hooks.c:	old_is_dir = S_ISDIR(old_dentry->d_inode->i_mode);
security/selinux/hooks.c:		new_isec = new_dentry->d_inode->i_security;
security/selinux/hooks.c:		new_is_dir = S_ISDIR(new_dentry->d_inode->i_mode);
security/selinux/hooks.c:	isec = inode->i_security;
security/selinux/hooks.c:			   interested in the inode-based check here. */
security/selinux/hooks.c:			root_isec = sb->s_root->d_inode->i_security;
security/selinux/hooks.c:					     inode_mode_to_security_class(inode->i_mode),
security/selinux/hooks.c:			       -rc, inode->i_sb->s_id, inode->i_ino);
security/selinux/hooks.c:		struct inode_security_struct *isec = inode->i_security;
security/selinux/hooks.c:		isec->sclass = inode_mode_to_security_class(inode->i_mode);
security/selinux/hooks.c:	struct inode_security_struct *isec = inode->i_security;
security/selinux/hooks.c:	perms = file_mask_to_av(inode->i_mode, mask);
security/selinux/hooks.c:	isec = inode->i_security;
security/selinux/hooks.c:	struct inode_security_struct *isec = inode->i_security;
security/selinux/hooks.c:	sbsec = inode->i_sb->s_security;
security/selinux/hooks.c:	struct inode_security_struct *isec = inode->i_security;
security/selinux/hooks.c:		       inode->i_sb->s_id, inode->i_ino, -rc);
security/selinux/hooks.c:	struct inode_security_struct *isec = inode->i_security;
security/selinux/hooks.c:	struct inode_security_struct *isec = inode->i_security;
security/selinux/hooks.c:	struct inode_security_struct *isec = inode->i_security;
security/selinux/hooks.c:			     file_mask_to_av(inode->i_mode, mask));
security/selinux/hooks.c:	struct inode_security_struct *isec = inode->i_security;
security/selinux/hooks.c:	isec = file->f_path.dentry->d_inode->i_security;
security/selinux/hooks.c:	struct inode_security_struct *isec = inode->i_security;
security/selinux/hooks.c:	struct inode_security_struct *isec = inode->i_security;
security/selinux/hooks.c: *	called with inode->i_mutex locked
security/selinux/hooks.c: *	called with inode->i_mutex locked
security/selinux/selinuxfs.c:	ino_t ino = filp->f_path.dentry->d_inode->i_ino;
security/selinux/selinuxfs.c:		mutex_lock(&inode->i_mutex);
security/selinux/selinuxfs.c:		mutex_unlock(&inode->i_mutex);
security/selinux/selinuxfs.c:	ino_t ino = file->f_path.dentry->d_inode->i_ino;
security/selinux/selinuxfs.c:	unsigned index = inode->i_ino & SEL_INO_MASK;
security/selinux/selinuxfs.c:	unsigned index = inode->i_ino & SEL_INO_MASK;
security/selinux/selinuxfs.c:		isec = (struct inode_security_struct *)inode->i_security;
security/selinux/selinuxfs.c:		inode->i_fop = &sel_bool_ops;
security/selinux/selinuxfs.c:		inode->i_ino = i|SEL_BOOL_INO_OFFSET;
security/selinux/selinuxfs.c:		inode->i_fop = files[i].ops;
security/selinux/selinuxfs.c:		inode->i_ino = ++sel_last_ino;
security/selinux/selinuxfs.c:	sid = inode->i_ino&SEL_INO_MASK;
security/selinux/selinuxfs.c:		inode->i_fop = &sel_initcon_ops;
security/selinux/selinuxfs.c:		inode->i_ino = i|SEL_INITCON_INO_OFFSET;
security/selinux/selinuxfs.c:	unsigned long ino = file->f_path.dentry->d_inode->i_ino;
security/selinux/selinuxfs.c:	unsigned long ino = file->f_path.dentry->d_inode->i_ino;
security/selinux/selinuxfs.c:	unsigned long i_ino = file->f_path.dentry->d_inode->i_ino;
security/selinux/selinuxfs.c:		inode->i_fop = &sel_perm_ops;
security/selinux/selinuxfs.c:		inode->i_ino = sel_perm_to_ino(classvalue, i + 1);
security/selinux/selinuxfs.c:	inode->i_fop = &sel_class_ops;
security/selinux/selinuxfs.c:	inode->i_ino = sel_class_to_ino(index);
security/selinux/selinuxfs.c:				if (d->d_inode->i_mode & S_IFDIR)
security/selinux/selinuxfs.c:		inode->i_fop = &sel_policycap_ops;
security/selinux/selinuxfs.c:		inode->i_ino = iter | SEL_POLICYCAP_INO_OFFSET;
security/selinux/selinuxfs.c:	inode->i_op = &simple_dir_inode_operations;
security/selinux/selinuxfs.c:	inode->i_fop = &simple_dir_operations;
security/selinux/selinuxfs.c:	inode->i_ino = ++(*ino);
security/selinux/selinuxfs.c:	inode->i_ino = ++sel_last_ino;
security/selinux/selinuxfs.c:	isec = (struct inode_security_struct *)inode->i_security;
security/smack/smack_lsm.c:	isp = inode->i_security;
security/smack/smack_lsm.c:		inode->i_security = new_inode_smack(sp->smk_root);
security/smack/smack_lsm.c:	isp = inode->i_security;
security/smack/smack_lsm.c:	inode->i_security = new_inode_smack(smk_of_current());
security/smack/smack_lsm.c:	if (inode->i_security == NULL)
security/smack/smack_lsm.c:	kfree(inode->i_security);
security/smack/smack_lsm.c:	inode->i_security = NULL;
security/smack/smack_lsm.c:	struct inode_smack *issp = inode->i_security;
security/smack/smack_lsm.c:	struct inode_smack *isp = dentry->d_inode->i_security;
security/smack/smack_lsm.c:		isp = dentry->d_inode->i_security;
security/smack/smack_lsm.c:	struct inode_smack *isp = inode->i_security;
security/smack/smack_lsm.c:	isp = dp->d_inode->i_security;
security/smack/smack_lsm.c:	struct inode_smack *isp = file->f_path.dentry->d_inode->i_security;
security/smack/smack_lsm.c:	struct inode_smack *isp = inode->i_security;
security/smack/smack_lsm.c:	struct inode_smack *isp = inode->i_security;
security/smack/smack_lsm.c:	struct inode_smack *nsp = inode->i_security;
security/smack/smack_lsm.c:	if (inode->i_sb->s_magic != SOCKFS_MAGIC)
security/smack/smack_lsm.c:	isp = inode->i_security;
security/smack/smack_lsm.c:	sbp = inode->i_sb;
security/smack/smack_lsm.c:		if (S_ISSOCK(inode->i_mode)) {
security/smack/smack_lsm.c:		if (inode->i_op->getxattr == NULL)
security/smack/smack_lsm.c:		if (S_ISDIR(inode->i_mode)) {
security/smack/smack_lsm.c:				rc = inode->i_op->setxattr(dp,
security/smack/smack_lsm.c:				rc = inode->i_op->getxattr(dp,
security/security.c:	inode->i_security = NULL;
arch/arm/plat-pxa/dma.c:	return single_open(file, dbg_show_##name, inode->i_private); \
arch/arm/mach-omap1/clock.c:	return single_open(file, clk_dbg_show_summary, inode->i_private);
arch/arm/mach-tegra/powergate.c:	return single_open(file, powergate_show, inode->i_private);
arch/arm/mach-omap2/pm-debug.c:	switch ((int)inode->i_private) {
arch/arm/mach-omap2/pm-debug.c:			&inode->i_private);
arch/arm/mach-omap2/pm-debug.c:			&inode->i_private);
arch/arm/mach-omap2/mux.c:	return single_open(file, omap_mux_dbg_board_show, inode->i_private);
arch/arm/mach-omap2/mux.c:	return single_open(file, omap_mux_dbg_signal_show, inode->i_private);
arch/arm/plat-samsung/clock.c:	return single_open(file, clock_tree_show, inode->i_private);
arch/s390/kernel/debug.c:	debug_info = file->f_path.dentry->d_inode->i_private;
arch/s390/hypfs/inode.c:	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
arch/s390/hypfs/inode.c:	mutex_lock(&parent->d_inode->i_mutex);
arch/s390/hypfs/inode.c:		if (S_ISDIR(dentry->d_inode->i_mode))
arch/s390/hypfs/inode.c:	mutex_unlock(&parent->d_inode->i_mutex);
arch/s390/hypfs/inode.c:	kfree(inode->i_private);
arch/s390/hypfs/inode.c:	char *data = filp->f_path.dentry->d_inode->i_private;
arch/s390/hypfs/inode.c:		if (!(inode->i_mode & S_IWUGO))
arch/s390/hypfs/inode.c:		if (!(inode->i_mode & S_IRUGO))
arch/s390/hypfs/inode.c:	fs_info = inode->i_sb->s_fs_info;
arch/s390/hypfs/inode.c:	sb = iocb->ki_filp->f_path.dentry->d_inode->i_sb;
arch/s390/hypfs/inode.c:	root_inode->i_op = &simple_dir_inode_operations;
arch/s390/hypfs/inode.c:	root_inode->i_fop = &simple_dir_operations;
arch/s390/hypfs/inode.c:	mutex_lock(&parent->d_inode->i_mutex);
arch/s390/hypfs/inode.c:		inode->i_fop = &hypfs_file_ops;
arch/s390/hypfs/inode.c:			inode->i_size = strlen(data);
arch/s390/hypfs/inode.c:			inode->i_size = 0;
arch/s390/hypfs/inode.c:		inode->i_op = &simple_dir_inode_operations;
arch/s390/hypfs/inode.c:		inode->i_fop = &simple_dir_operations;
arch/s390/hypfs/inode.c:	inode->i_private = data;
arch/s390/hypfs/inode.c:	mutex_unlock(&parent->d_inode->i_mutex);
arch/s390/hypfs/hypfs_dbfs.c:	df = file->f_path.dentry->d_inode->i_private;
arch/s390/pci/pci_debug.c:			   filp->f_path.dentry->d_inode->i_private);
arch/s390/pci/pci_debug.c:			   filp->f_path.dentry->d_inode->i_private);
arch/powerpc/kernel/fadump.c:	return single_open(file, fadump_region_show, inode->i_private);
arch/powerpc/kvm/timing.c:	return single_open(file, kvmppc_exit_timing_show, inode->i_private);
arch/powerpc/platforms/cell/spufs/inode.c:	call_rcu(&inode->i_rcu, spufs_i_callback);
arch/powerpc/platforms/cell/spufs/inode.c:	inode->i_ino = get_next_ino();
arch/powerpc/platforms/cell/spufs/inode.c:	inode->i_mode = mode;
arch/powerpc/platforms/cell/spufs/inode.c:	inode->i_uid = current_fsuid();
arch/powerpc/platforms/cell/spufs/inode.c:	inode->i_gid = current_fsgid();
arch/powerpc/platforms/cell/spufs/inode.c:	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
arch/powerpc/platforms/cell/spufs/inode.c:	    (attr->ia_size != inode->i_size))
arch/powerpc/platforms/cell/spufs/inode.c:	inode->i_op = &spufs_file_iops;
arch/powerpc/platforms/cell/spufs/inode.c:	inode->i_fop = fops;
arch/powerpc/platforms/cell/spufs/inode.c:	inode->i_size = size;
arch/powerpc/platforms/cell/spufs/inode.c:	inode->i_private = SPUFS_I(inode)->i_ctx = get_spu_context(ctx);
arch/powerpc/platforms/cell/spufs/inode.c:	mutex_lock(&dir->d_inode->i_mutex);
arch/powerpc/platforms/cell/spufs/inode.c:	mutex_unlock(&dir->d_inode->i_mutex);
arch/powerpc/platforms/cell/spufs/inode.c:		inode->i_gid = dir->i_gid;
arch/powerpc/platforms/cell/spufs/inode.c:		inode->i_mode &= S_ISGID;
arch/powerpc/platforms/cell/spufs/inode.c:	inode->i_op = &simple_dir_inode_operations;
arch/powerpc/platforms/cell/spufs/inode.c:	inode->i_fop = &simple_dir_operations;
arch/powerpc/platforms/cell/spufs/inode.c:		inode->i_gid = dir->i_gid;
arch/powerpc/platforms/cell/spufs/inode.c:		inode->i_mode &= S_ISGID;
arch/powerpc/platforms/cell/spufs/inode.c:	inode->i_op = &simple_dir_inode_operations;
arch/powerpc/platforms/cell/spufs/inode.c:	inode->i_fop = &simple_dir_operations;
arch/powerpc/platforms/cell/spufs/inode.c:	inode->i_op = &simple_dir_inode_operations;
arch/powerpc/platforms/cell/spufs/inode.c:	inode->i_fop = &simple_dir_operations;
arch/powerpc/platforms/cell/spufs/file.c:	attr->data = inode->i_private;
arch/powerpc/platforms/cell/spufs/file.c:		ctx->local_store = inode->i_mapping;
arch/powerpc/platforms/cell/spufs/file.c:		ctx->cntl = inode->i_mapping;
arch/powerpc/platforms/cell/spufs/file.c:		ctx->signal1 = inode->i_mapping;
arch/powerpc/platforms/cell/spufs/file.c:		ctx->signal2 = inode->i_mapping;
arch/powerpc/platforms/cell/spufs/file.c:		ctx->mss = inode->i_mapping;
arch/powerpc/platforms/cell/spufs/file.c:		ctx->psmap = inode->i_mapping;
arch/powerpc/platforms/cell/spufs/file.c:	if (atomic_read(&inode->i_count) != 1)
arch/powerpc/platforms/cell/spufs/file.c:		ctx->mfc = inode->i_mapping;
arch/powerpc/platforms/cell/spufs/file.c:	int err = filemap_write_and_wait_range(inode->i_mapping, start, end);
arch/powerpc/platforms/cell/spufs/file.c:		mutex_lock(&inode->i_mutex);
arch/powerpc/platforms/cell/spufs/file.c:		mutex_unlock(&inode->i_mutex);
arch/powerpc/platforms/pseries/dtl.c:	struct dtl *dtl = inode->i_private;
arch/powerpc/platforms/pseries/dtl.c:	struct dtl *dtl = inode->i_private;
arch/powerpc/platforms/pseries/hvCall_inst.c:	seq->private = file->f_path.dentry->d_inode->i_private;
arch/powerpc/platforms/wsp/wsp_pci.c:	return single_open(file, wsp_pci_regs_show, inode->i_private);
arch/x86/kernel/cpuid.c:	mutex_lock(&inode->i_mutex);
arch/x86/kernel/cpuid.c:	mutex_unlock(&inode->i_mutex);
arch/x86/kernel/msr.c:	mutex_lock(&inode->i_mutex);
arch/x86/kernel/msr.c:	mutex_unlock(&inode->i_mutex);
arch/cris/arch-v10/drivers/sync_serial.c:	int dev = MINOR(inode->i_rdev);
arch/cris/arch-v10/drivers/sync_serial.c:	int dev = MINOR(inode->i_rdev);
arch/cris/arch-v10/drivers/sync_serial.c:	int dev = MINOR(file->f_dentry->d_inode->i_rdev);
arch/cris/arch-v10/drivers/sync_serial.c:	int dev = MINOR(file->f_dentry->d_inode->i_rdev);
arch/cris/arch-v10/drivers/sync_serial.c:	int dev = MINOR(file->f_dentry->d_inode->i_rdev);
arch/cris/arch-v10/drivers/sync_serial.c:	int dev = MINOR(file->f_dentry->d_inode->i_rdev);
arch/sh/boards/mach-landisk/gio.c:	minor = MINOR(inode->i_rdev);
arch/sh/boards/mach-landisk/gio.c:	minor = MINOR(inode->i_rdev);
arch/sh/mm/cache-debugfs.c:	return single_open(file, cache_seq_show, inode->i_private);
arch/sh/mm/asids-debugfs.c:	return single_open(file, asids_seq_show, inode->i_private);
arch/sh/mm/tlb-debugfs.c:	return single_open(file, tlb_seq_show, inode->i_private);
arch/ia64/kernel/perfmon.c:			     dentry->d_inode->i_ino);
arch/ia64/kernel/perfmon.c:	DPRINT(("new inode ino=%ld @%p\n", inode->i_ino, inode));
arch/ia64/kernel/perfmon.c:	inode->i_mode = S_IFCHR|S_IRUGO;
arch/ia64/kernel/perfmon.c:	inode->i_uid  = current_fsuid();
arch/ia64/kernel/perfmon.c:	inode->i_gid  = current_fsgid();
ipc/shm.c:		user_shm_unlock(shp->shm_file->f_path.dentry->d_inode->i_size,
ipc/shm.c:	file->f_dentry->d_inode->i_ino = shp->shm_perm.id;
ipc/shm.c:		struct address_space *mapping = inode->i_mapping;
ipc/shm.c:		*rss_add += inode->i_mapping->nrpages;
ipc/shm.c:		*rss_add += inode->i_mapping->nrpages;
ipc/shm.c:			size = vma->vm_file->f_path.dentry->d_inode->i_size;
ipc/mqueue.c:	return get_ipc_ns(inode->i_sb->s_fs_info);
ipc/mqueue.c:	inode->i_ino = get_next_ino();
ipc/mqueue.c:	inode->i_mode = mode;
ipc/mqueue.c:	inode->i_uid = current_fsuid();
ipc/mqueue.c:	inode->i_gid = current_fsgid();
ipc/mqueue.c:	inode->i_mtime = inode->i_ctime = inode->i_atime = CURRENT_TIME;
ipc/mqueue.c:		inode->i_fop = &mqueue_file_operations;
ipc/mqueue.c:		inode->i_size = FILENT_SIZE;
ipc/mqueue.c:		inode->i_size = 2 * DIRENT_SIZE;
ipc/mqueue.c:		inode->i_op = &mqueue_dir_inode_operations;
ipc/mqueue.c:		inode->i_fop = &simple_dir_operations;
ipc/mqueue.c:	call_rcu(&inode->i_rcu, mqueue_i_callback);
ipc/mqueue.c:	if (S_ISDIR(inode->i_mode))
ipc/mqueue.c:	filp->f_path.dentry->d_inode->i_atime = filp->f_path.dentry->d_inode->i_ctime = CURRENT_TIME;
ipc/mqueue.c:	mutex_lock(&root->d_inode->i_mutex);
ipc/mqueue.c:	mutex_unlock(&root->d_inode->i_mutex);
ipc/mqueue.c:	mutex_lock_nested(&mnt->mnt_root->d_inode->i_mutex, I_MUTEX_PARENT);
ipc/mqueue.c:	mutex_unlock(&mnt->mnt_root->d_inode->i_mutex);
ipc/mqueue.c:		inode->i_atime = inode->i_mtime = inode->i_ctime =
ipc/mqueue.c:		inode->i_atime = inode->i_mtime = inode->i_ctime =
ipc/mqueue.c:			inode->i_atime = inode->i_ctime = CURRENT_TIME;
ipc/mqueue.c:		inode->i_atime = inode->i_ctime = CURRENT_TIME;
ipc/mqueue.c:		inode->i_atime = inode->i_ctime = CURRENT_TIME;
sound/core/pcm_native.c:	if (!S_ISCHR(inode->i_mode) ||
drivers/oprofile/oprofilefs.c:		inode->i_ino = get_next_ino();
drivers/oprofile/oprofilefs.c:		inode->i_mode = mode;
drivers/oprofile/oprofilefs.c:		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
drivers/oprofile/oprofilefs.c:	inode->i_fop = fops;
drivers/oprofile/oprofilefs.c:	dentry->d_inode->i_private = priv;
drivers/oprofile/oprofilefs.c:	inode->i_op = &simple_dir_inode_operations;
drivers/oprofile/oprofilefs.c:	inode->i_fop = &simple_dir_operations;
drivers/oprofile/oprofilefs.c:	root_inode->i_op = &simple_dir_inode_operations;
drivers/oprofile/oprofilefs.c:	root_inode->i_fop = &simple_dir_operations;
drivers/iommu/tegra-smmu.c:	info = dent->d_inode->i_private;
drivers/iommu/tegra-smmu.c:	info = dent->d_inode->i_private;
drivers/memory/emif.c:	return single_open(file, emif_regdump_show, inode->i_private);
drivers/memory/emif.c:	return single_open(file, emif_mr4_show, inode->i_private);
drivers/pps/pps.c:	struct pps_device *pps = container_of(inode->i_cdev,
drivers/pps/pps.c:	struct pps_device *pps = container_of(inode->i_cdev,
drivers/s390/block/dasd_ioctl.c:		bdev->bd_inode->i_blkbits = blksize_bits(fdata->blksize);
drivers/s390/block/dasd.c:	struct dasd_profile *profile = inode->i_private;
drivers/s390/char/vmur.c:	devno = MINOR(file->f_dentry->d_inode->i_rdev);
drivers/s390/cio/qdio_debug.c:			   filp->f_path.dentry->d_inode->i_private);
drivers/s390/cio/qdio_debug.c:			   filp->f_path.dentry->d_inode->i_private);
drivers/dma/amba-pl08x.c:	return single_open(file, pl08x_debugfs_show, inode->i_private);
drivers/base/regmap/regcache-rbtree.c:	return single_open(file, rbtree_show, inode->i_private);
drivers/base/devtmpfs.c:		dentry->d_inode->i_private = &thread;
drivers/base/devtmpfs.c:		mutex_lock(&dentry->d_inode->i_mutex);
drivers/base/devtmpfs.c:		mutex_unlock(&dentry->d_inode->i_mutex);
drivers/base/devtmpfs.c:		dentry->d_inode->i_private = &thread;
drivers/base/devtmpfs.c:		if (dentry->d_inode->i_private == &thread)
drivers/base/devtmpfs.c:	mutex_unlock(&parent.dentry->d_inode->i_mutex);
drivers/base/devtmpfs.c:	if (inode->i_private != &thread)
drivers/base/devtmpfs.c:			mutex_lock(&dentry->d_inode->i_mutex);
drivers/base/devtmpfs.c:			mutex_unlock(&dentry->d_inode->i_mutex);
drivers/base/devtmpfs.c:	mutex_unlock(&parent.dentry->d_inode->i_mutex);
drivers/rtc/rtc-dev.c:	struct rtc_device *rtc = container_of(inode->i_cdev,
drivers/rtc/rtc-m41t80.c:	if (MINOR(inode->i_rdev) == WATCHDOG_MINOR) {
drivers/rtc/rtc-m41t80.c:	if (MINOR(inode->i_rdev) == WATCHDOG_MINOR)
drivers/pnp/isapnp/proc.c:	mutex_lock(&inode->i_mutex);
drivers/pnp/isapnp/proc.c:	mutex_unlock(&inode->i_mutex);
drivers/mtd/nand/nandsim.c:	return single_open(file, nandsim_debugfs_show, inode->i_private);
drivers/mtd/mtdswap.c:	return single_open(file, mtdswap_show, inode->i_private);
drivers/mtd/devices/block2mtd.c:	struct address_space *mapping = dev->blkdev->bd_inode->i_mapping;
drivers/mtd/devices/block2mtd.c:		page = page_read(dev->blkdev->bd_inode->i_mapping, index);
drivers/mtd/devices/block2mtd.c:	struct address_space *mapping = dev->blkdev->bd_inode->i_mapping;
drivers/mtd/devices/block2mtd.c:		invalidate_mapping_pages(dev->blkdev->bd_inode->i_mapping,
drivers/mtd/devices/block2mtd.c:	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK;
drivers/mtd/devices/docg3.h:	{ return single_open(file, show_fct, inode->i_private); }      \
drivers/mtd/ubi/build.c:	mode = path.dentry->d_inode->i_mode;
drivers/mtd/ubi/cdev.c:	mutex_lock(&inode->i_mutex);
drivers/mtd/ubi/cdev.c:	mutex_unlock(&inode->i_mutex);
drivers/mtd/ubi/kapi.c:	mod = inode->i_mode;
drivers/net/wireless/rt2x00/rt2x00debug.c:	struct rt2x00debug_intf *intf = inode->i_private;
drivers/net/wireless/rt2x00/rt2x00debug.c:	file->private_data = inode->i_private;
drivers/net/wireless/rt2x00/rt2x00debug.c:	struct rt2x00debug_intf *intf = inode->i_private;
drivers/net/wireless/rt2x00/rt2x00debug.c:	struct rt2x00debug_intf *intf = inode->i_private;
drivers/net/wireless/ath/ath6kl/debug.c:	struct ath6kl *ar = inode->i_private;
drivers/net/wireless/ath/ath6kl/debug.c:	file->private_data = inode->i_private;
drivers/net/wireless/ath/ath6kl/debug.c:	struct ath6kl *ar = inode->i_private;
drivers/net/wireless/ath/ath6kl/debug.c:	struct ath6kl *ar = inode->i_private;
drivers/net/wireless/ath/ath9k/debug.c:	struct ath_softc *sc = inode->i_private;
drivers/net/wireless/ath/ath9k/debug.c:	struct ath_softc *sc = inode->i_private;
drivers/net/wireless/ath/wil6210/debugfs.c:	return single_open(file, wil_vring_debugfs_show, inode->i_private);
drivers/net/wireless/ath/wil6210/debugfs.c:	return single_open(file, wil_mbox_debugfs_show, inode->i_private);
drivers/net/wireless/ath/wil6210/debugfs.c:	return single_open(file, wil_memread_debugfs_show, inode->i_private);
drivers/net/wireless/ath/wil6210/debugfs.c:	if (inode->i_private)
drivers/net/wireless/ath/wil6210/debugfs.c:		file->private_data = inode->i_private;
drivers/net/wireless/ath/wil6210/debugfs.c:	return single_open(file, wil_txdesc_debugfs_show, inode->i_private);
drivers/net/wireless/ath/wil6210/debugfs.c:	return single_open(file, wil_bf_debugfs_show, inode->i_private);
drivers/net/wireless/ath/ath5k/debug.c:		s->private = inode->i_private;
drivers/net/bonding/bond_debugfs.c:	return single_open(file, bond_debug_rlb_hash_show, inode->i_private);
drivers/net/ethernet/stmicro/stmmac/stmmac_main.c:	return single_open(file, stmmac_sysfs_ring_read, inode->i_private);
drivers/net/ethernet/stmicro/stmmac/stmmac_main.c:	return single_open(file, stmmac_sysfs_dma_cap_read, inode->i_private);
drivers/net/ethernet/brocade/bna/bnad_debugfs.c:	struct bnad *bnad = inode->i_private;
drivers/net/ethernet/brocade/bna/bnad_debugfs.c:	struct bnad *bnad = inode->i_private;
drivers/net/ethernet/brocade/bna/bnad_debugfs.c:	reg_debug->i_private = inode->i_private;
drivers/net/ethernet/brocade/bna/bnad_debugfs.c:	struct bnad *bnad = inode->i_private;
drivers/net/ethernet/marvell/sky2.c:	return single_open(file, sky2_debug_show, inode->i_private);
drivers/net/ethernet/marvell/skge.c:	return single_open(file, skge_debug_show, inode->i_private);
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:	loff_t avail = file->f_path.dentry->d_inode->i_size;
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:		de->d_inode->i_size = size_mb << 20;
drivers/net/ethernet/chelsio/cxgb4/l2t.c:		struct adapter *adap = inode->i_private;
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:		seq->private = inode->i_private;
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:		seq->private = inode->i_private;
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:	return single_open(file, resources_show, inode->i_private);
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:		seq->private = inode->i_private;
drivers/input/mousedev.c:		mousedev = container_of(inode->i_cdev, struct mousedev, cdev);
drivers/input/evdev.c:	struct evdev *evdev = container_of(inode->i_cdev, struct evdev, cdev);
drivers/input/joydev.c:			container_of(inode->i_cdev, struct joydev, cdev);
drivers/md/md.c:	spin_lock(&inode->i_lock);
drivers/md/md.c:	if (atomic_read(&inode->i_writecount) > 1) {
drivers/md/md.c:		spin_unlock(&inode->i_lock);
drivers/md/md.c:	atomic_set(&inode->i_writecount, -1);
drivers/md/md.c:	spin_unlock(&inode->i_lock);
drivers/md/md.c:	spin_lock(&inode->i_lock);
drivers/md/md.c:	atomic_set(&inode->i_writecount, 1);
drivers/md/md.c:	spin_unlock(&inode->i_lock);
drivers/md/bitmap.c:	bh = alloc_page_buffers(page, 1<<inode->i_blkbits, 0);
drivers/md/bitmap.c:	block = index << (PAGE_SHIFT - inode->i_blkbits);
drivers/md/bitmap.c:			bh->b_bdev = inode->i_sb->s_bdev;
drivers/md/bitmap.c:			if (count < (1<<inode->i_blkbits))
drivers/md/bitmap.c:				count -= (1<<inode->i_blkbits);
drivers/md/bitmap.c:		invalidate_mapping_pages(inode->i_mapping, 0, -1);
drivers/tty/tty_io.c:		tty_update_time(&inode->i_atime);
drivers/tty/tty_io.c:		tty_update_time(&inode->i_mtime);
drivers/tty/tty_io.c: *	number of opens done on a tty. We cannot use the inode-count, as
drivers/tty/tty_io.c:	dev_t device = inode->i_rdev;
drivers/infiniband/ulp/ipoib/ipoib_fs.c:	seq->private = inode->i_private;
drivers/infiniband/ulp/ipoib/ipoib_fs.c:	seq->private = inode->i_private;
drivers/infiniband/hw/cxgb4/device.c:	qpd->devp = inode->i_private;
drivers/infiniband/hw/cxgb4/device.c:	stagd->devp = inode->i_private;
drivers/infiniband/hw/cxgb4/device.c:	return single_open(file, stats_show, inode->i_private);
drivers/infiniband/hw/cxgb4/device.c:	epd->devp = inode->i_private;
drivers/infiniband/hw/cxgb4/device.c:		de->d_inode->i_size = 4096;
drivers/infiniband/hw/cxgb4/device.c:		de->d_inode->i_size = 4096;
drivers/infiniband/hw/cxgb4/device.c:		de->d_inode->i_size = 4096;
drivers/infiniband/hw/cxgb4/device.c:		de->d_inode->i_size = 4096;
drivers/infiniband/hw/ipath/ipath_file_ops.c:		   (long)fp->f_path.dentry->d_inode->i_rdev, i_minor);
drivers/infiniband/hw/ipath/ipath_fs.c:	inode->i_ino = get_next_ino();
drivers/infiniband/hw/ipath/ipath_fs.c:	inode->i_mode = mode;
drivers/infiniband/hw/ipath/ipath_fs.c:	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
drivers/infiniband/hw/ipath/ipath_fs.c:	inode->i_private = data;
drivers/infiniband/hw/ipath/ipath_fs.c:		inode->i_op = &simple_dir_inode_operations;
drivers/infiniband/hw/ipath/ipath_fs.c:	inode->i_fop = fops;
drivers/infiniband/hw/ipath/ipath_fs.c:	mutex_lock(&parent->d_inode->i_mutex);
drivers/infiniband/hw/ipath/ipath_fs.c:	mutex_unlock(&parent->d_inode->i_mutex);
drivers/infiniband/hw/ipath/ipath_fs.c:	dd = file->f_path.dentry->d_inode->i_private;
drivers/infiniband/hw/ipath/ipath_fs.c:	dd = file->f_path.dentry->d_inode->i_private;
drivers/infiniband/hw/ipath/ipath_fs.c:	dd = file->f_path.dentry->d_inode->i_private;
drivers/infiniband/hw/ipath/ipath_fs.c:	mutex_lock(&root->d_inode->i_mutex);
drivers/infiniband/hw/ipath/ipath_fs.c:	mutex_unlock(&root->d_inode->i_mutex);
drivers/infiniband/hw/qib/qib_fs.c:#define private2dd(file) ((file)->f_dentry->d_inode->i_private)
drivers/infiniband/hw/qib/qib_fs.c:	inode->i_ino = get_next_ino();
drivers/infiniband/hw/qib/qib_fs.c:	inode->i_mode = mode;
drivers/infiniband/hw/qib/qib_fs.c:	inode->i_uid = GLOBAL_ROOT_UID;
drivers/infiniband/hw/qib/qib_fs.c:	inode->i_gid = GLOBAL_ROOT_GID;
drivers/infiniband/hw/qib/qib_fs.c:	inode->i_blocks = 0;
drivers/infiniband/hw/qib/qib_fs.c:	inode->i_atime = CURRENT_TIME;
drivers/infiniband/hw/qib/qib_fs.c:	inode->i_mtime = inode->i_atime;
drivers/infiniband/hw/qib/qib_fs.c:	inode->i_ctime = inode->i_atime;
drivers/infiniband/hw/qib/qib_fs.c:	inode->i_private = data;
drivers/infiniband/hw/qib/qib_fs.c:		inode->i_op = &simple_dir_inode_operations;
drivers/infiniband/hw/qib/qib_fs.c:	inode->i_fop = fops;
drivers/infiniband/hw/qib/qib_fs.c:	mutex_lock(&parent->d_inode->i_mutex);
drivers/infiniband/hw/qib/qib_fs.c:	mutex_unlock(&parent->d_inode->i_mutex);
drivers/infiniband/hw/qib/qib_fs.c: * Could use file->f_dentry->d_inode->i_ino to figure out which file,
drivers/infiniband/hw/qib/qib_fs.c:	mutex_lock(&root->d_inode->i_mutex);
drivers/infiniband/hw/qib/qib_fs.c:	mutex_unlock(&root->d_inode->i_mutex);
drivers/infiniband/core/user_mad.c:	port = container_of(inode->i_cdev, struct ib_umad_port, cdev);
drivers/infiniband/core/user_mad.c:	port = container_of(inode->i_cdev, struct ib_umad_port, sm_cdev);
drivers/infiniband/core/uverbs_main.c:	dev = container_of(inode->i_cdev, struct ib_uverbs_device, cdev);
drivers/infiniband/core/ucm.c:	file->device = container_of(inode->i_cdev, struct ib_ucm_device, cdev);
drivers/block/pktcdvd.c:	return single_open(file, pkt_debugfs_seq_show, inode->i_private);
drivers/block/loop.c:	if (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))
drivers/block/loop.c:	q->limits.discard_granularity = inode->i_sb->s_blocksize;
drivers/block/loop.c:	if (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))
drivers/block/loop.c:	lo_blocksize = S_ISBLK(inode->i_mode) ?
drivers/block/loop.c:		inode->i_bdev->bd_block_size : PAGE_SIZE;
drivers/block/xen-blkback/xenbus.c:	err = filemap_write_and_wait(blkif->vbd.bdev->bd_inode->i_mapping);
drivers/block/xen-blkback/xenbus.c:	invalidate_inode_pages2(blkif->vbd.bdev->bd_inode->i_mapping);
drivers/block/drbd/drbd_wrappers.h:	mdev->this_bdev->bd_inode->i_size = (loff_t)size << 9;
drivers/block/nbd.c:			if (S_ISSOCK(inode->i_mode)) {
drivers/block/nbd.c:		bdev->bd_inode->i_size = nbd->bytesize;
drivers/block/nbd.c:		bdev->bd_inode->i_size = nbd->bytesize;
drivers/block/nbd.c:		bdev->bd_inode->i_size = nbd->bytesize;
drivers/block/nbd.c:		bdev->bd_inode->i_size = 0;
drivers/block/aoe/aoecmd.c:			mutex_lock(&bd->bd_inode->i_mutex);
drivers/block/aoe/aoecmd.c:			mutex_unlock(&bd->bd_inode->i_mutex);
drivers/firmware/efivars.c:	file->private_data = inode->i_private;
drivers/firmware/efivars.c:		mutex_lock(&inode->i_mutex);
drivers/firmware/efivars.c:		mutex_unlock(&inode->i_mutex);
drivers/firmware/efivars.c:		inode->i_ino = get_next_ino();
drivers/firmware/efivars.c:		inode->i_mode = mode;
drivers/firmware/efivars.c:		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
drivers/firmware/efivars.c:			inode->i_fop = &efivarfs_file_operations;
drivers/firmware/efivars.c:			inode->i_op = &efivarfs_dir_inode_operations;
drivers/firmware/efivars.c:			inode->i_fop = &simple_dir_operations;
drivers/firmware/efivars.c:	inode->i_private = var;
drivers/firmware/efivars.c:	struct efivar_entry *var = dentry->d_inode->i_private;
drivers/firmware/efivars.c:	inode->i_op = &efivarfs_dir_inode_operations;
drivers/firmware/efivars.c:		mutex_lock(&inode->i_mutex);
drivers/firmware/efivars.c:		inode->i_private = entry;
drivers/firmware/efivars.c:		mutex_unlock(&inode->i_mutex);
drivers/staging/ozwpan/ozcdev.c:	dev = container_of(inode->i_cdev, struct oz_cdev, cdev);
drivers/staging/bcm/Misc.c:	BCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Opened file is = %s and length =0x%lx to be downloaded at =0x%x", path, (unsigned long)flp->f_dentry->d_inode->i_size, loc);
drivers/staging/csr/drv.c:    devno = MINOR(inode->i_rdev) >> 1;
drivers/staging/csr/drv.c:    if (MINOR(inode->i_rdev) & 0x1) {
drivers/staging/csr/drv.c:    devno = MINOR(inode->i_rdev) >> 1;
drivers/staging/csr/drv.c:    if ((MINOR(inode->i_rdev) & 0x1) == 0) {
drivers/staging/dgrp/dgrp_common.c:	return dgrp_chk_perm(inode->i_mode, op);
drivers/staging/android/binder.c:	return single_open(file, binder_##name##_show, inode->i_private); \
drivers/staging/android/logger.c:	log = get_log_from_minor(MINOR(inode->i_rdev));
drivers/staging/omapdrm/omap_gem_helpers.c:	mapping = inode->i_mapping;
drivers/staging/vme/devices/vme_user.c:	unsigned int minor = MINOR(inode->i_rdev);
drivers/staging/vme/devices/vme_user.c:	unsigned int minor = MINOR(inode->i_rdev);
drivers/staging/vme/devices/vme_user.c:	unsigned int minor = MINOR(file->f_dentry->d_inode->i_rdev);
drivers/staging/vme/devices/vme_user.c:	unsigned int minor = MINOR(file->f_dentry->d_inode->i_rdev);
drivers/staging/vme/devices/vme_user.c:	unsigned int minor = MINOR(file->f_dentry->d_inode->i_rdev);
drivers/staging/vme/devices/vme_user.c:	unsigned int minor = MINOR(inode->i_rdev);
drivers/staging/usbip/usbip_common.c:	if (!inode || !S_ISSOCK(inode->i_mode)) {
drivers/staging/ccg/f_fs.c:	struct ffs_data *ffs = inode->i_private;
drivers/staging/ccg/f_fs.c:	struct ffs_epfile *epfile = inode->i_private;
drivers/staging/ccg/f_fs.c:	struct ffs_epfile *epfile = inode->i_private;
drivers/staging/ccg/f_fs.c:		inode->i_ino	 = get_next_ino();
drivers/staging/ccg/f_fs.c:		inode->i_mode    = perms->mode;
drivers/staging/ccg/f_fs.c:		inode->i_uid     = perms->uid;
drivers/staging/ccg/f_fs.c:		inode->i_gid     = perms->gid;
drivers/staging/ccg/f_fs.c:		inode->i_atime   = current_time;
drivers/staging/ccg/f_fs.c:		inode->i_mtime   = current_time;
drivers/staging/ccg/f_fs.c:		inode->i_ctime   = current_time;
drivers/staging/ccg/f_fs.c:		inode->i_private = data;
drivers/staging/ccg/f_fs.c:			inode->i_fop = fops;
drivers/staging/ccg/f_fs.c:			inode->i_op  = iops;
drivers/staging/ccg/f_mass_storage.c:	rc = invalidate_mapping_pages(inode->i_mapping, 0, -1);
drivers/staging/ccg/storage_common.c:	if ((!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))) {
drivers/staging/ccg/storage_common.c:	size = i_size_read(inode->i_mapping->host);
drivers/staging/ccg/storage_common.c:	} else if (inode->i_bdev) {
drivers/staging/ccg/storage_common.c:		blksize = bdev_logical_block_size(inode->i_bdev);
drivers/staging/ft1000/ft1000-usb/ft1000_debug.c:	struct ft1000_device *dev = (struct ft1000_device *)inode->i_private;
drivers/staging/ft1000/ft1000-usb/ft1000_debug.c:    num = (MINOR(inode->i_rdev) & 0xf);
drivers/staging/slicoss/slicoss.c:	return single_open(file, slic_debug_adapter_show, inode->i_private);
drivers/staging/slicoss/slicoss.c:	return single_open(file, slic_debug_card_show, inode->i_private);
drivers/char/ps3flash.c:	mutex_lock(&inode->i_mutex);
drivers/char/ps3flash.c:	mutex_unlock(&inode->i_mutex);
drivers/char/sonypi.c:		inode->i_atime = current_fs_time(inode->i_sb);
drivers/char/snsc.c:	scd = container_of(inode->i_cdev, struct sysctl_data_s, scd_cdev);
drivers/char/msm_smd_pkt.c:	smd_pkt_devp = container_of(inode->i_cdev, struct smd_pkt_dev, cdev);
drivers/char/raw.c:	filp->f_mapping = bdev->bd_inode->i_mapping;
drivers/char/raw.c:		filp->f_path.dentry->d_inode->i_mapping =
drivers/char/raw.c:			bdev->bd_inode->i_mapping;
drivers/char/raw.c:		/* Here  inode->i_mapping == bdev->bd_inode->i_mapping  */
drivers/char/raw.c:		inode->i_mapping = &inode->i_data;
drivers/char/raw.c:		inode->i_mapping->backing_dev_info = &default_backing_dev_info;
drivers/char/virtio_console.c:	struct cdev *cdev = inode->i_cdev;
drivers/char/xilinx_hwicap/xilinx_hwicap.c:	drvdata = container_of(inode->i_cdev, struct hwicap_drvdata, cdev);
drivers/char/bsr.c:	struct cdev *cdev = inode->i_cdev;
drivers/char/mem.c:	mutex_lock(&file->f_path.dentry->d_inode->i_mutex);
drivers/char/mem.c:	mutex_unlock(&file->f_path.dentry->d_inode->i_mutex);
drivers/media/pci/cx23885/altera-ci.c:					prev_node->next_inode->next_inode;
drivers/media/dvb-frontends/stv0900_core.c:					prev_node->next_inode->next_inode;
drivers/media/usb/uvc/uvc_debugfs.c:	struct uvc_streaming *stream = inode->i_private;
drivers/media/rc/lirc_dev.c:	    file->f_dentry->d_inode->i_rdev) {
drivers/media/media-devnode.c:	mdev = container_of(inode->i_cdev, struct media_devnode, cdev);
drivers/iio/industrialio-core.c:	struct iio_dev *indio_dev = container_of(inode->i_cdev,
drivers/iio/industrialio-core.c:	struct iio_dev *indio_dev = container_of(inode->i_cdev,
drivers/watchdog/watchdog_dev.c:		wdd = container_of(inode->i_cdev, struct watchdog_device, cdev);
drivers/pci/proc.c:	mutex_lock(&inode->i_mutex);
drivers/pci/proc.c:		new = inode->i_size + off;
drivers/pci/proc.c:	if (new < 0 || new > inode->i_size)
drivers/pci/proc.c:	mutex_unlock(&inode->i_mutex);
drivers/pci/hotplug/cpqphp_sysfs.c:	struct controller *ctrl = inode->i_private;
drivers/spi/spidev.c:		if (spidev->devt == inode->i_rdev) {
drivers/power/da9030_battery.c:	return single_open(file, bat_debug_show, inode->i_private);
drivers/usb/otg/msm_otg.c:	return single_open(file, msm_otg_mode_show, inode->i_private);
drivers/usb/host/isp116x-hcd.c:	return single_open(file, isp116x_show_dbg, inode->i_private);
drivers/usb/host/imx21-dbg.c:	return single_open(file, debug_status_show, inode->i_private);
drivers/usb/host/imx21-dbg.c:	return single_open(file, debug_dmem_show, inode->i_private);
drivers/usb/host/imx21-dbg.c:	return single_open(file, debug_etd_show, inode->i_private);
drivers/usb/host/imx21-dbg.c:	return single_open(file, debug_statistics_show, inode->i_private);
drivers/usb/host/imx21-dbg.c:	return single_open(file, debug_isoc_show, inode->i_private);
drivers/usb/host/fhci-dbg.c:	return single_open(file, fhci_dfs_regs_show, inode->i_private);
drivers/usb/host/fhci-dbg.c:	return single_open(file, fhci_dfs_irq_stat_show, inode->i_private);
drivers/usb/host/whci/debug.c:	return single_open(file, di_print, inode->i_private);
drivers/usb/host/whci/debug.c:	return single_open(file, asl_print, inode->i_private);
drivers/usb/host/whci/debug.c:	return single_open(file, pzl_print, inode->i_private);
drivers/usb/host/ohci-dbg.c:	file->private_data = alloc_buffer(inode->i_private, fill_async_buffer);
drivers/usb/host/ohci-dbg.c:	file->private_data = alloc_buffer(inode->i_private,
drivers/usb/host/ohci-dbg.c:	file->private_data = alloc_buffer(inode->i_private,
drivers/usb/host/ehci-dbg.c:	file->private_data = alloc_buffer(inode->i_private, fill_async_buffer);
drivers/usb/host/ehci-dbg.c:	buf = alloc_buffer(inode->i_private, fill_periodic_buffer);
drivers/usb/host/ehci-dbg.c:	file->private_data = alloc_buffer(inode->i_private,
drivers/usb/host/uhci-debug.c:	struct uhci_hcd *uhci = inode->i_private;
drivers/usb/core/devio.c:	mutex_lock(&file->f_dentry->d_inode->i_mutex);
drivers/usb/core/devio.c:	mutex_unlock(&file->f_dentry->d_inode->i_mutex);
drivers/usb/core/devio.c:		dev = usbdev_lookup_by_devt(inode->i_rdev);
drivers/usb/core/devio.c:			inode->i_mtime = CURRENT_TIME;
drivers/usb/core/devio.c:			inode->i_mtime = CURRENT_TIME;
drivers/usb/core/devio.c:			inode->i_mtime = CURRENT_TIME;
drivers/usb/core/devio.c:			inode->i_mtime = CURRENT_TIME;
drivers/usb/core/devio.c:			inode->i_mtime = CURRENT_TIME;
drivers/usb/core/devio.c:			inode->i_mtime = CURRENT_TIME;
drivers/usb/core/devio.c:			inode->i_mtime = CURRENT_TIME;
drivers/usb/core/devio.c:			inode->i_mtime = CURRENT_TIME;
drivers/usb/core/devio.c:		inode->i_atime = CURRENT_TIME;
drivers/usb/core/devices.c:	mutex_lock(&file->f_dentry->d_inode->i_mutex);
drivers/usb/core/devices.c:	mutex_unlock(&file->f_dentry->d_inode->i_mutex);
drivers/usb/dwc3/debugfs.c:	return single_open(file, dwc3_regdump_show, inode->i_private);
drivers/usb/dwc3/debugfs.c:	return single_open(file, dwc3_mode_show, inode->i_private);
drivers/usb/dwc3/debugfs.c:	return single_open(file, dwc3_testmode_show, inode->i_private);
drivers/usb/dwc3/debugfs.c:	return single_open(file, dwc3_link_state_show, inode->i_private);
drivers/usb/musb/musb_debugfs.c:	return single_open(file, musb_regdump_show, inode->i_private);
drivers/usb/musb/musb_debugfs.c:	return single_open(file, musb_test_mode_show, inode->i_private);
drivers/usb/mon/mon_text.c:	mbus = inode->i_private;
drivers/usb/mon/mon_text.c:	mbus = inode->i_private;
drivers/usb/mon/mon_stat.c:	mbus = inode->i_private;
drivers/usb/gadget/inode.c:	struct ep_data		*data = inode->i_private;
drivers/usb/gadget/inode.c:	struct dev_data		*dev = inode->i_private;
drivers/usb/gadget/inode.c:		inode->i_ino = get_next_ino();
drivers/usb/gadget/inode.c:		inode->i_mode = mode;
drivers/usb/gadget/inode.c:		inode->i_uid = make_kuid(&init_user_ns, default_uid);
drivers/usb/gadget/inode.c:		inode->i_gid = make_kgid(&init_user_ns, default_gid);
drivers/usb/gadget/inode.c:		inode->i_atime = inode->i_mtime = inode->i_ctime
drivers/usb/gadget/inode.c:		inode->i_private = data;
drivers/usb/gadget/inode.c:		inode->i_fop = fops;
drivers/usb/gadget/inode.c:	inode->i_op = &simple_dir_inode_operations;
drivers/usb/gadget/pxa25x_udc.c:	return single_open(file, udc_seq_show, inode->i_private);
drivers/usb/gadget/bcm63xx_udc.c:	return single_open(file, bcm63xx_usbd_dbg_show, inode->i_private);
drivers/usb/gadget/bcm63xx_udc.c:	return single_open(file, bcm63xx_iudma_dbg_show, inode->i_private);
drivers/usb/gadget/f_hid.c:		container_of(inode->i_cdev, struct f_hidg, cdev);
drivers/usb/gadget/printer.c:	dev = container_of(inode->i_cdev, struct printer_dev, printer_cdev);
drivers/usb/gadget/printer.c:	mutex_lock(&inode->i_mutex);
drivers/usb/gadget/printer.c:	mutex_unlock(&inode->i_mutex);
drivers/usb/gadget/f_fs.c:	struct ffs_data *ffs = inode->i_private;
drivers/usb/gadget/f_fs.c:	struct ffs_epfile *epfile = inode->i_private;
drivers/usb/gadget/f_fs.c:	struct ffs_epfile *epfile = inode->i_private;
drivers/usb/gadget/f_fs.c:		inode->i_ino	 = get_next_ino();
drivers/usb/gadget/f_fs.c:		inode->i_mode    = perms->mode;
drivers/usb/gadget/f_fs.c:		inode->i_uid     = perms->uid;
drivers/usb/gadget/f_fs.c:		inode->i_gid     = perms->gid;
drivers/usb/gadget/f_fs.c:		inode->i_atime   = current_time;
drivers/usb/gadget/f_fs.c:		inode->i_mtime   = current_time;
drivers/usb/gadget/f_fs.c:		inode->i_ctime   = current_time;
drivers/usb/gadget/f_fs.c:		inode->i_private = data;
drivers/usb/gadget/f_fs.c:			inode->i_fop = fops;
drivers/usb/gadget/f_fs.c:			inode->i_op  = iops;
drivers/usb/gadget/f_mass_storage.c:	rc = invalidate_mapping_pages(inode->i_mapping, 0, -1);
drivers/usb/gadget/atmel_usba_udc.c:	struct usba_ep *ep = inode->i_private;
drivers/usb/gadget/atmel_usba_udc.c:	mutex_lock(&file->f_dentry->d_inode->i_mutex);
drivers/usb/gadget/atmel_usba_udc.c:	mutex_unlock(&file->f_dentry->d_inode->i_mutex);
drivers/usb/gadget/atmel_usba_udc.c:	mutex_lock(&inode->i_mutex);
drivers/usb/gadget/atmel_usba_udc.c:	udc = inode->i_private;
drivers/usb/gadget/atmel_usba_udc.c:	data = kmalloc(inode->i_size, GFP_KERNEL);
drivers/usb/gadget/atmel_usba_udc.c:	for (i = 0; i < inode->i_size / 4; i++)
drivers/usb/gadget/atmel_usba_udc.c:	mutex_unlock(&inode->i_mutex);
drivers/usb/gadget/atmel_usba_udc.c:	mutex_lock(&inode->i_mutex);
drivers/usb/gadget/atmel_usba_udc.c:			file->f_dentry->d_inode->i_size);
drivers/usb/gadget/atmel_usba_udc.c:	mutex_unlock(&inode->i_mutex);
drivers/usb/gadget/atmel_usba_udc.c:	regs->d_inode->i_size = resource_size(regs_resource);
drivers/usb/gadget/s3c-hsotg.c:	return single_open(file, state_show, inode->i_private);
drivers/usb/gadget/s3c-hsotg.c:	return single_open(file, fifo_show, inode->i_private);
drivers/usb/gadget/s3c-hsotg.c:	return single_open(file, ep_show, inode->i_private);
drivers/usb/gadget/pxa27x_udc.c:	return single_open(file, eps_dbg_show, inode->i_private);
drivers/usb/gadget/pxa27x_udc.c:	return single_open(file, queues_dbg_show, inode->i_private);
drivers/usb/gadget/pxa27x_udc.c:	return single_open(file, state_dbg_show, inode->i_private);
drivers/usb/gadget/storage_common.c:	if ((!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))) {
drivers/usb/gadget/storage_common.c:	size = i_size_read(inode->i_mapping->host);
drivers/usb/gadget/storage_common.c:	} else if (inode->i_bdev) {
drivers/usb/gadget/storage_common.c:		blksize = bdev_logical_block_size(inode->i_bdev);
drivers/gpio/gpio-tegra.c:	return single_open(file, dbg_gpio_show, &inode->i_private);
drivers/pinctrl/pinmux.c:	return single_open(file, pinmux_functions_show, inode->i_private);
drivers/pinctrl/pinmux.c:	return single_open(file, pinmux_pins_show, inode->i_private);
drivers/pinctrl/pinconf.c:	return single_open(file, pinconf_pins_show, inode->i_private);
drivers/pinctrl/pinconf.c:	return single_open(file, pinconf_groups_show, inode->i_private);
drivers/pinctrl/core.c:	return single_open(file, pinctrl_pins_show, inode->i_private);
drivers/pinctrl/core.c:	return single_open(file, pinctrl_groups_show, inode->i_private);
drivers/pinctrl/core.c:	return single_open(file, pinctrl_gpioranges_show, inode->i_private);
drivers/gpu/drm/gma500/gtt.c:	mapping = inode->i_mapping;
drivers/gpu/drm/drm_fops.c:	old_imapping = inode->i_mapping;
drivers/gpu/drm/drm_fops.c:		dev->dev_mapping = &inode->i_data;
drivers/gpu/drm/drm_fops.c:	inode->i_mapping = dev->dev_mapping;
drivers/gpu/drm/drm_fops.c:	inode->i_mapping = old_imapping;
drivers/gpu/drm/udl/udl_gem.c:	mapping = inode->i_mapping;
drivers/gpu/drm/ttm/ttm_tt.c:	swap_space = swap_storage->f_path.dentry->d_inode->i_mapping;
drivers/gpu/drm/ttm/ttm_tt.c:	swap_space = swap_storage->f_path.dentry->d_inode->i_mapping;
drivers/gpu/drm/drm_debugfs.c:	struct drm_info_node *node = inode->i_private;
drivers/gpu/drm/i915/i915_debugfs.c:	struct drm_device *dev = inode->i_private;
drivers/gpu/drm/i915/i915_debugfs.c:	struct drm_device *dev = inode->i_private;
drivers/gpu/drm/i915/i915_debugfs.c:	struct drm_device *dev = inode->i_private;
drivers/gpu/drm/i915/i915_gem.c:	mapping = obj->base.filp->f_path.dentry->d_inode->i_mapping;
drivers/gpu/drm/i915/i915_gem.c:	mapping = obj->base.filp->f_path.dentry->d_inode->i_mapping;
drivers/gpu/drm/i915/i915_gem.c:	struct address_space *mapping = obj->base.filp->f_path.dentry->d_inode->i_mapping;
drivers/gpu/drm/i915/i915_gem.c:	struct address_space *mapping = obj->base.filp->f_path.dentry->d_inode->i_mapping;
drivers/scsi/osd/osd_uld.c:	struct osd_uld_device *oud = container_of(inode->i_cdev,
drivers/scsi/pmcraid.c:	pinstance = container_of(inode->i_cdev, struct pmcraid_instance, cdev);
drivers/scsi/qla2xxx/qla_dfs.c:	scsi_qla_host_t *vha = inode->i_private;
drivers/scsi/qla2xxx/qla_dfs.c:	scsi_qla_host_t *vha = inode->i_private;
drivers/scsi/csiostor/csio_init.c:	file->private_data = inode->i_private;
drivers/scsi/csiostor/csio_init.c:	loff_t avail = file->f_path.dentry->d_inode->i_size;
drivers/scsi/csiostor/csio_init.c:		de->d_inode->i_size = size_mb << 20;
drivers/scsi/bfa/bfad_debugfs.c:	struct bfad_port_s *port = inode->i_private;
drivers/scsi/bfa/bfad_debugfs.c:	struct bfad_port_s *port = inode->i_private;
drivers/scsi/bfa/bfad_debugfs.c:	struct bfad_port_s *port = inode->i_private;
drivers/scsi/bfa/bfad_debugfs.c:	reg_debug->i_private = inode->i_private;
drivers/scsi/lpfc/lpfc_debugfs.c:	struct lpfc_vport *vport = inode->i_private;
drivers/scsi/lpfc/lpfc_debugfs.c:	struct lpfc_hba *phba = inode->i_private;
drivers/scsi/lpfc/lpfc_debugfs.c:	struct lpfc_hba *phba = inode->i_private;
drivers/scsi/lpfc/lpfc_debugfs.c:	struct lpfc_hba *phba = inode->i_private;
drivers/scsi/lpfc/lpfc_debugfs.c:	struct lpfc_hba *phba = inode->i_private;
drivers/scsi/lpfc/lpfc_debugfs.c:	struct lpfc_vport *vport = inode->i_private;
drivers/scsi/lpfc/lpfc_debugfs.c:	debug->i_private = inode->i_private;
drivers/target/target_core_file.c:	if (S_ISBLK(inode->i_mode)) {
drivers/target/target_core_file.c:		struct request_queue *q = bdev_get_queue(inode->i_bdev);
drivers/target/target_core_file.c:			bdev_logical_block_size(inode->i_bdev);
drivers/target/target_core_file.c:		if (S_ISBLK(fd->f_dentry->d_inode->i_mode)) {
drivers/xen/xenfs/super.c:	inode->i_fop = fops;
drivers/xen/xenfs/super.c:	inode->i_private = data;
drivers/sh/intc/virq-debugfs.c:	return single_open(file, intc_irq_xlate_debug, inode->i_private);
drivers/uwb/uwb-debug.c:	return single_open(file, reservations_print, inode->i_private);
drivers/uwb/uwb-debug.c:	return single_open(file, drp_avail_print, inode->i_private);
drivers/zorro/proc.c:	mutex_lock(&inode->i_mutex);
drivers/zorro/proc.c:	mutex_unlock(&inode->i_mutex);
drivers/firewire/core-cdev.c:	device = fw_device_get_by_devt(inode->i_rdev);
drivers/misc/vmw_balloon.c:	return single_open(file, vmballoon_debug_show, inode->i_private);
drivers/misc/ibmasm/ibmasmfs.c:	inode->i_fop = fops;
drivers/misc/ibmasm/ibmasmfs.c:	inode->i_private = data;
drivers/misc/ibmasm/ibmasmfs.c:	inode->i_op = &simple_dir_inode_operations;
drivers/misc/ibmasm/ibmasmfs.c:	inode->i_fop = ibmasmfs_dir_ops;
drivers/misc/ibmasm/ibmasmfs.c:	if (!inode->i_private)
drivers/misc/ibmasm/ibmasmfs.c:	command_data->sp = inode->i_private;
drivers/misc/ibmasm/ibmasmfs.c:	if (!inode->i_private)
drivers/misc/ibmasm/ibmasmfs.c:	sp = inode->i_private;
drivers/misc/ibmasm/ibmasmfs.c:	if (!inode->i_private)
drivers/misc/ibmasm/ibmasmfs.c:	rhbeat->sp = inode->i_private;
drivers/misc/carma/carma-fpga.c:	return single_open(file, data_debug_show, inode->i_private);
drivers/misc/phantom.c:	struct phantom_device *dev = container_of(inode->i_cdev,
drivers/mmc/host/omap_hsmmc.c:	return single_open(file, omap_hsmmc_regs_show, inode->i_private);
drivers/mmc/host/dw_mmc.c:	return single_open(file, dw_mci_req_show, inode->i_private);
drivers/mmc/host/dw_mmc.c:	return single_open(file, dw_mci_regs_show, inode->i_private);
drivers/mmc/host/s3cmci.c:	return single_open(file, s3cmci_state_show, inode->i_private);
drivers/mmc/host/s3cmci.c:	return single_open(file, s3cmci_regs_show, inode->i_private);
drivers/mmc/host/atmel-mci.c:	return single_open(file, atmci_req_show, inode->i_private);
drivers/mmc/host/atmel-mci.c:	return single_open(file, atmci_regs_show, inode->i_private);
drivers/mmc/core/debugfs.c:	return single_open(file, mmc_ios_show, inode->i_private);
drivers/mmc/core/debugfs.c:	struct mmc_card *card = inode->i_private;
drivers/mmc/card/mmc_test.c:	return single_open(file, mtf_test_show, inode->i_private);
drivers/mmc/card/mmc_test.c:	return single_open(file, mtf_testlist_show, inode->i_private);
drivers/hid/hid-picolcd_debugfs.c:	return single_open(f, picolcd_debug_reset_show, inode->i_private);
drivers/hid/hid-debug.c:	return single_open(file, hid_debug_rdesc_show, inode->i_private);
drivers/hid/hid-debug.c:	list->hdev = (struct hid_device *) inode->i_private;
drivers/video/omap2/dss/core.c:	return single_open(file, dss_debug_show, inode->i_private);
drivers/video/fb_defio.c:	int err = filemap_write_and_wait_range(inode->i_mapping, start, end);
drivers/video/fb_defio.c:	mutex_lock(&inode->i_mutex);
drivers/video/fb_defio.c:	mutex_unlock(&inode->i_mutex);
drivers/video/msm/mdp.c:	if (MAJOR(f.file->f_dentry->d_inode->i_rdev) == FB_MAJOR) {
drivers/video/mbx/mbxdebugfs.c:	file->private_data = inode->u.generic_ip;
drivers/hwmon/asus_atk0110.c:	struct atk_data *data = inode->i_private;
drivers/platform/x86/samsung-laptop.c:	return single_open(file, show_call, inode->i_private);
drivers/platform/x86/sony-laptop.c:		inode->i_atime = current_fs_time(inode->i_sb);
drivers/platform/x86/dell-laptop.c:	return single_open(file, dell_debugfs_show, inode->i_private);
drivers/platform/x86/asus-wmi.c:	struct asus_wmi_debugfs_node *node = inode->i_private;
drivers/platform/x86/intel_ips.c:	struct ips_debugfs_node *node = inode->i_private;
drivers/regulator/dbx500-prcmu.c:		inode->i_private);
drivers/regulator/dbx500-prcmu.c:		inode->i_private);
drivers/hsi/clients/hsi_char.c:	cl_data = container_of(inode->i_cdev, struct hsc_client_data, cdev);
drivers/mfd/ab3100-otp.c:	return single_open(file, ab3100_show_otp, inode->i_private);
drivers/mfd/tps65010.c:	return single_open(file, dbg_show, inode->i_private);
drivers/mfd/ab3100-core.c:	return single_open(file, ab3100_registers_print, inode->i_private);
drivers/mfd/ab8500-debugfs.c:	return single_open(file, ab8500_registers_print, inode->i_private);
drivers/mfd/ab8500-debugfs.c:	return single_open(file, ab8500_bank_print, inode->i_private);
drivers/mfd/ab8500-debugfs.c:	return single_open(file, ab8500_address_print, inode->i_private);
drivers/mfd/ab8500-debugfs.c:	return single_open(file, ab8500_val_print, inode->i_private);
include/uapi/linux/bfs_fs.h:/* SVR4 vnode type values (bfs_inode->i_vtype) */
include/trace/events/writeback.h:		__entry->ino		= inode->i_ino;
include/trace/events/writeback.h:		__entry->state		= inode->i_state;
include/trace/events/writeback.h:		__entry->dirtied_when	= inode->dirtied_when;
include/trace/events/writeback.h:		__entry->ino		= inode->i_ino;
include/trace/events/writeback.h:		__entry->state		= inode->i_state;
include/trace/events/writeback.h:		__entry->dirtied_when	= inode->dirtied_when;
include/trace/events/writeback.h:		__entry->writeback_index = inode->i_mapping->writeback_index;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->blocks	= inode->i_blocks;
include/trace/events/ext4.h:		__entry->mode	= inode->i_mode;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->nlink	= inode->i_nlink;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext4.h:		__entry->writeback_index = inode->i_mapping->writeback_index;
include/trace/events/ext4.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext4.h:		__entry->writeback_index = inode->i_mapping->writeback_index;
include/trace/events/ext4.h:		__entry->ino		= ac->ac_inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= pa->pa_inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= pa->pa_inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= ar->inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= ar->inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= ar->inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= ar->inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext4.h:		__entry->mode		= inode->i_mode;
include/trace/events/ext4.h:		__entry->dev		= dentry->d_inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= dentry->d_inode->i_ino;
include/trace/events/ext4.h:		__entry->parent		= dentry->d_parent->d_inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= ac->ac_inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= ac->ac_inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= ac->ac_inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= ac->ac_inode->i_ino;
include/trace/events/ext4.h:		__entry->ino		= inode ? inode->i_ino : 0;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->mode	= inode->i_mode;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->i_blocks = inode->i_blocks;
include/trace/events/ext4.h:		__entry->mode	= inode->i_mode;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->i_blocks = inode->i_blocks;
include/trace/events/ext4.h:		__entry->mode	= inode->i_mode;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->i_blocks = inode->i_blocks;
include/trace/events/ext4.h:		__entry->mode	= inode->i_mode;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= dentry->d_inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= dentry->d_inode->i_ino;
include/trace/events/ext4.h:		__entry->size		= dentry->d_inode->i_size;
include/trace/events/ext4.h:		__entry->dev		= dentry->d_inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= dentry->d_inode->i_ino;
include/trace/events/ext4.h:		__entry->dev    = inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino    = inode->i_ino;
include/trace/events/ext4.h:		__entry->blocks	= inode->i_blocks;
include/trace/events/ext4.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev    = inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino    = inode->i_ino;
include/trace/events/ext4.h:		__entry->dev    = inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino    = inode->i_ino;
include/trace/events/ext4.h:		__entry->dev    = inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino    = inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext4.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= inode->i_ino;
include/trace/events/jbd2.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/jbd2.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext3.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext3.h:		__entry->mode	= inode->i_mode;
include/trace/events/ext3.h:		__entry->blocks	= inode->i_blocks;
include/trace/events/ext3.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext3.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext3.h:		__entry->nlink	= inode->i_nlink;
include/trace/events/ext3.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext3.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext3.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext3.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext3.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext3.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext3.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext3.h:		__entry->mode		= inode->i_mode;
include/trace/events/ext3.h:		__entry->dev		= dentry->d_inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino		= dentry->d_inode->i_ino;
include/trace/events/ext3.h:		__entry->parent		= dentry->d_parent->d_inode->i_ino;
include/trace/events/ext3.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext3.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext3.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext3.h:		__entry->mode	= inode->i_mode;
include/trace/events/ext3.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext3.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino	= inode->i_ino;
include/trace/events/ext3.h:		__entry->dev	= inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino		= dentry->d_inode->i_ino;
include/trace/events/ext3.h:		__entry->size		= dentry->d_inode->i_size;
include/trace/events/ext3.h:		__entry->dev		= dentry->d_inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino		= dentry->d_inode->i_ino;
include/trace/events/ext3.h:		__entry->dev		= dentry->d_inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino    = inode->i_ino;
include/trace/events/ext3.h:		__entry->dev    = inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->blocks	= inode->i_blocks;
include/trace/events/ext3.h:		__entry->ino    = inode->i_ino;
include/trace/events/ext3.h:		__entry->dev    = inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino    = inode->i_ino;
include/trace/events/ext3.h:		__entry->dev    = inode->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino		= inode->i_ino;
include/trace/events/ext3.h:		__entry->dev		= inode->i_sb->s_dev;
include/trace/events/btrfs.h:		__entry->ino	= inode->i_ino;
include/trace/events/btrfs.h:		__entry->blocks	= inode->i_blocks;
include/trace/events/btrfs.h:		__entry->ino 		= inode->i_ino;
include/trace/events/btrfs.h:		__entry->ino		= inode->i_ino;
include/trace/events/btrfs.h:		__entry->writeback_index = inode->i_mapping->writeback_index;
include/trace/events/btrfs.h:		__entry->ino		= inode->i_ino;
include/trace/events/btrfs.h:		__entry->parent		= dentry->d_parent->d_inode->i_ino;
include/linux/writeback.h:	wait_on_bit(&inode->i_state, __I_NEW, inode_wait, TASK_UNINTERRUPTIBLE);
include/linux/fsnotify.h:	if (S_ISDIR(inode->i_mode))
include/linux/fsnotify.h:	if (S_ISDIR(inode->i_mode))
include/linux/fsnotify.h:	if (S_ISDIR(inode->i_mode))
include/linux/fsnotify.h:	if (S_ISDIR(inode->i_mode))
include/linux/fsnotify.h:	if (S_ISDIR(inode->i_mode))
include/linux/fsnotify.h:		if (S_ISDIR(inode->i_mode))
include/linux/quotaops.h:	return (ia->ia_valid & ATTR_SIZE && ia->ia_size != inode->i_size) ||
include/linux/quotaops.h:		(ia->ia_valid & ATTR_UID && !uid_eq(ia->ia_uid, inode->i_uid)) ||
include/linux/quotaops.h:		(ia->ia_valid & ATTR_GID && !gid_eq(ia->ia_gid, inode->i_gid));
include/linux/quotaops.h:	return dquot_alloc_space_nodirty(inode, nr << inode->i_blkbits);
include/linux/quotaops.h:	dquot_alloc_space_nofail(inode, nr << inode->i_blkbits);
include/linux/quotaops.h:	return dquot_alloc_space(inode, nr << inode->i_blkbits);
include/linux/quotaops.h:	return __dquot_alloc_space(inode, nr << inode->i_blkbits, 0);
include/linux/quotaops.h:	return __dquot_alloc_space(inode, nr << inode->i_blkbits,
include/linux/quotaops.h:	ret = dquot_claim_space_nodirty(inode, nr << inode->i_blkbits);
include/linux/quotaops.h:	dquot_free_space_nodirty(inode, nr << inode->i_blkbits);
include/linux/quotaops.h:	dquot_free_space(inode, nr << inode->i_blkbits);
include/linux/quotaops.h:	__dquot_free_space(inode, nr << inode->i_blkbits, DQUOT_SPACE_RESERVE);
include/linux/ceph/debugfs.h:	sf->private = inode->i_private;					\
include/linux/nfs_fs.h:	return NFS_SB(inode->i_sb);
include/linux/nfs_fs.h:	return S_ISDIR(inode->i_mode) ? nfss->acdirmin : nfss->acregmin;
include/linux/nfs_fs.h:	return S_ISDIR(inode->i_mode) ? nfss->acdirmax : nfss->acregmax;
include/linux/nfs_fs.h:	spin_lock(&inode->i_lock);
include/linux/nfs_fs.h:	if (S_ISDIR(inode->i_mode))
include/linux/nfs_fs.h:	spin_unlock(&inode->i_lock);
include/linux/fs.h:#define i_size_ordered_init(inode) seqcount_init(&inode->i_size_seqcount)
include/linux/fs.h:	return hlist_unhashed(&inode->i_hash);
include/linux/fs.h: * inode->i_mutex nesting subclasses for the lock validator:
include/linux/fs.h:		seq = read_seqcount_begin(&inode->i_size_seqcount);
include/linux/fs.h:		i_size = inode->i_size;
include/linux/fs.h:	} while (read_seqcount_retry(&inode->i_size_seqcount, seq));
include/linux/fs.h:	i_size = inode->i_size;
include/linux/fs.h:	return inode->i_size;
include/linux/fs.h:	write_seqcount_begin(&inode->i_size_seqcount);
include/linux/fs.h:	inode->i_size = i_size;
include/linux/fs.h:	write_seqcount_end(&inode->i_size_seqcount);
include/linux/fs.h:	inode->i_size = i_size;
include/linux/fs.h:	inode->i_size = i_size;
include/linux/fs.h:	return from_kuid(&init_user_ns, inode->i_uid);
include/linux/fs.h:	return from_kgid(&init_user_ns, inode->i_gid);
include/linux/fs.h:	inode->i_uid = make_kuid(&init_user_ns, uid);
include/linux/fs.h:	inode->i_gid = make_kgid(&init_user_ns, gid);
include/linux/fs.h:	return MINOR(inode->i_rdev);
include/linux/fs.h:	return MAJOR(inode->i_rdev);
include/linux/fs.h: * Note that nosuid etc flags are inode-specific: setting some file-system
include/linux/fs.h: * Inode state bits.  Protected by inode->i_lock
include/linux/fs.h:       spin_lock(&inode->i_lock);
include/linux/fs.h:       inode->i_version++;
include/linux/fs.h:       spin_unlock(&inode->i_lock);
include/linux/fs.h:	if (inode->i_flock && mandatory_lock(inode))
include/linux/fs.h:			size < inode->i_size ? size : inode->i_size,
include/linux/fs.h:			(size < inode->i_size ? inode->i_size - size
include/linux/fs.h:			 : size - inode->i_size)
include/linux/fs.h:	if (inode->i_flock)
include/linux/fs.h:	if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
include/linux/fs.h:	    S_ISLNK(inode->i_mode))
include/linux/fs.h:		invalidate_mapping_pages(inode->i_mapping, 0, -1);
include/linux/fs.h:	return (inode->i_mode & S_IXUGO) || S_ISDIR(inode->i_mode);
include/linux/fs.h:	return atomic_inc_unless_negative(&inode->i_writecount) ? 0 : -ETXTBSY;
include/linux/fs.h:	return atomic_dec_unless_positive(&inode->i_writecount) ? 0 : -ETXTBSY;
include/linux/fs.h:	atomic_dec(&inode->i_writecount);
include/linux/fs.h:		atomic_inc(&file->f_path.dentry->d_inode->i_writecount);
include/linux/fs.h:	BUG_ON(!atomic_read(&inode->i_readcount));
include/linux/fs.h:	atomic_dec(&inode->i_readcount);
include/linux/fs.h:	atomic_inc(&inode->i_readcount);
include/linux/fs.h:	return !inode->i_nlink || inode_unhashed(inode);
include/linux/fs.h:	__insert_inode_hash(inode, inode->i_ino);
include/linux/fs.h:	return __blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev, iov,
include/linux/fs.h:	res = dentry->d_parent->d_inode->i_ino;
include/linux/fs.h:	if (!is_sxid(inode->i_mode) && (inode->i_sb->s_flags & MS_NOSEC))
include/linux/fs.h:		inode->i_flags |= S_NOSEC;
include/linux/jbd2.h:/* Flags in jbd_inode->i_flags */
include/linux/security.h: *	Allocate and attach a security structure to @inode->i_security.  The
include/linux/security.h: *	Deallocate the inode security structure and set @inode->i_security to
include/linux/security.h: *	Called with the dentry->d_inode->i_mutex held.
include/linux/security.h: *	sock->inode->i_security.  This hook may be used to update the
include/linux/security.h: *	sock->inode->i_security field with additional information that wasn't
include/linux/security.h: * 	Must be called with inode->i_mutex locked.
include/linux/security.h: * 	Must be called with inode->i_mutex locked.
include/linux/fsnotify_backend.h:	struct hlist_node i_list;	/* list of marks by inode->i_fsnotify_marks */
include/linux/fsnotify_backend.h:	struct hlist_node m_list;	/* list of marks by inode->i_fsnotify_marks */
include/linux/fsnotify_backend.h:	if (!(inode->i_fsnotify_mask & FS_EVENT_ON_CHILD))
include/linux/fsnotify_backend.h:	return inode->i_fsnotify_mask & FS_EVENTS_POSS_ON_CHILD;
include/linux/fsnotify_backend.h:/* run all marks associated with an inode and update inode->i_fsnotify_mask */
include/linux/exportfs.h: *    get_parent is called with child->d_inode->i_mutex down
include/linux/posix_acl.h:		return &inode->i_acl;
include/linux/posix_acl.h:		return &inode->i_default_acl;
include/linux/posix_acl.h:		spin_lock(&inode->i_lock);
include/linux/posix_acl.h:		spin_unlock(&inode->i_lock);
include/linux/posix_acl.h:	spin_lock(&inode->i_lock);
include/linux/posix_acl.h:	spin_unlock(&inode->i_lock);
include/linux/posix_acl.h:	spin_lock(&inode->i_lock);
include/linux/posix_acl.h:	spin_unlock(&inode->i_lock);
include/linux/posix_acl.h:	spin_lock(&inode->i_lock);
include/linux/posix_acl.h:	old_access = inode->i_acl;
include/linux/posix_acl.h:	old_default = inode->i_default_acl;
include/linux/posix_acl.h:	inode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;
include/linux/posix_acl.h:	spin_unlock(&inode->i_lock);
include/linux/posix_acl.h:	inode->i_acl = NULL;
include/linux/posix_acl.h:	inode->i_default_acl = NULL;
include/linux/device_cgroup.h:	if (likely(!inode->i_rdev))
include/linux/device_cgroup.h:	if (!S_ISBLK(inode->i_mode) && !S_ISCHR(inode->i_mode))
